<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Reference.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.signature</a> &gt; <span class="el_source">Reference.java</span></div><h1>Reference.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.signature;



import java.io.*;
import java.math.BigInteger;
import java.util.*;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import org.apache.xml.serialize.OutputFormat;
import org.apache.xml.serialize.Serializer;
import org.apache.xml.serialize.SerializerFactory;
import org.apache.xml.serialize.XMLSerializer;
import org.apache.xml.utils.PrefixResolverDefault;
import org.apache.xpath.NodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathAPI;
import org.apache.xpath.XPathContext;
import org.w3c.dom.*;
import org.w3c.dom.traversal.NodeIterator;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.apache.xml.security.algorithms.MessageDigestAlgorithm;
import org.apache.xml.security.c14n.*;
import org.apache.xml.security.transforms.params.XPathContainer;
import org.apache.xml.security.exceptions.*;
import org.apache.xml.security.signature.*;
import org.apache.xml.security.transforms.*;
import org.apache.xml.security.utils.*;
import org.apache.xml.security.utils.resolver.*;
import javax.xml.transform.TransformerException;


/**
 * Handles &lt;code&gt;&amp;lt;ds:Reference&amp;gt;&lt;/code&gt; elements.
 *
 * This includes:
 *
 * Constuct a &lt;CODE&gt;ds:Reference&lt;/CODE&gt; from an {@link org.w3c.dom.Element}.
 *
 * &lt;p&gt;Create a new reference&lt;/p&gt;
 * &lt;pre&gt;
 * Document _doc;
 * MessageDigestAlgorithm sha1 = MessageDigestAlgorithm.getInstance(&quot;http://#sha1&quot;);
 * Reference ref = new Reference(new XMLSignatureInput(new FileInputStream(&quot;1.gif&quot;),
 *                               &quot;http://localhost/1.gif&quot;,
 *                               (Transforms) null, sha1);
 * Element refElem = ref.toElement(_doc);
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Verify a reference&lt;/p&gt;
 * &lt;pre&gt;
 * Element refElem = _doc.getElement(&quot;Reference&quot;); // PSEUDO
 * Reference ref = new Reference(refElem);
 * String url = ref.getURI();
 * ref.setData(new XMLSignatureInput(new FileInputStream(url)));
 * if (ref.verify()) {
 *    System.out.println(&quot;verified&quot;);
 * }
 * &lt;/pre&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;element name=&quot;Reference&quot; type=&quot;ds:ReferenceType&quot;/&amp;gt;
 *  &amp;lt;complexType name=&quot;ReferenceType&quot;&amp;gt;
 *    &amp;lt;sequence&amp;gt;
 *      &amp;lt;element ref=&quot;ds:Transforms&quot; minOccurs=&quot;0&quot;/&amp;gt;
 *      &amp;lt;element ref=&quot;ds:DigestMethod&quot;/&amp;gt;
 *      &amp;lt;element ref=&quot;ds:DigestValue&quot;/&amp;gt;
 *    &amp;lt;/sequence&amp;gt;
 *    &amp;lt;attribute name=&quot;Id&quot; type=&quot;ID&quot; use=&quot;optional&quot;/&amp;gt;
 *    &amp;lt;attribute name=&quot;URI&quot; type=&quot;anyURI&quot; use=&quot;optional&quot;/&amp;gt;
 *    &amp;lt;attribute name=&quot;Type&quot; type=&quot;anyURI&quot; use=&quot;optional&quot;/&amp;gt;
 *  &amp;lt;/complexType&amp;gt;
 * &lt;/pre&gt;
 *
 * @author Christian Geuer-Pollmann
 * @see ObjectContainer
 * @see Manifest
 */
public class Reference extends SignatureElementProxy {

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L144">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category.getInstance(Reference.class.getName());

   /** Field OBJECT_URI */
   public static final String OBJECT_URI = Constants.SignatureSpecNS
                                           + Constants._TAG_OBJECT;

   /** Field MANIFEST_URI */
   public static final String MANIFEST_URI = Constants.SignatureSpecNS
                                             + Constants._TAG_MANIFEST;
   //J-
<span class="pc" id="L155">   Manifest _manifest = null;</span>
   XMLSignatureInput _transformsInput;
   XMLSignatureInput _transformsOutput;
   //J+

   /**
    * Constructor Reference
    *
    * @param doc the {@link Document} in which &lt;code&gt;XMLsignature&lt;/code&gt; is placed
    * @param BaseURI the URI of the resource where the XML instance will be stored
    * @param ReferenceURI URI indicate where is data which will digested
    * @param manifest
    * @param transforms {@link transforms} applied to data
    * @param messageDigestAlgorithm {@link algorithms.MessageDigestAlgorithm Digest algorithm} which is applied to the data
    * @todo should we throw XMLSignatureException if MessageDigestAlgoURI is wrong?
    * @throws XMLSignatureException
    */
   protected Reference(
           Document doc, String BaseURI, String ReferenceURI, Manifest manifest, Transforms transforms, String messageDigestAlgorithm)
              throws XMLSignatureException {

<span class="nc" id="L176">      super(doc);</span>

<span class="nc" id="L178">      XMLUtils.addReturnToElement(this._constructionElement);</span>

<span class="nc" id="L180">      this._baseURI = BaseURI;</span>
<span class="nc" id="L181">      this._manifest = manifest;</span>

<span class="nc" id="L183">      this.setURI(ReferenceURI);</span>

      // important: The ds:Reference must be added to the associated ds:Manifest
      //            or ds:SignedInfo _before_ the this.resolverResult() is called.
      // this._manifest.appendChild(this._constructionElement);
      // this._manifest.appendChild(this._doc.createTextNode(&quot;\n&quot;));
<span class="nc" id="L189">      Element nscontext = XMLUtils.createDSctx(this._doc, &quot;ds&quot;);</span>

<span class="nc bnc" id="L191" title="All 2 branches missed.">      if (transforms != null) {</span>
<span class="nc" id="L192">         this._constructionElement.appendChild(transforms.getElement());</span>
<span class="nc" id="L193">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
      {
<span class="nc" id="L196">         MessageDigestAlgorithm mda =</span>
            MessageDigestAlgorithm.getInstance(this._doc,
                                               messageDigestAlgorithm);

<span class="nc" id="L200">         this._constructionElement.appendChild(mda.getElement());</span>
<span class="nc" id="L201">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
      {
<span class="nc" id="L204">         Element digestValueElement =</span>
            XMLUtils.createElementInSignatureSpace(this._doc,
                                                   Constants._TAG_DIGESTVALUE);

<span class="nc" id="L208">         this._constructionElement.appendChild(digestValueElement);</span>
<span class="nc" id="L209">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L211">   }</span>

   /**
    * Constructor Reference
    *
    * @param doc this {@link Document} in which &lt;code&gt;XMLsignature&lt;/code&gt; is placed
    * @param BaseURI the URI of the resource where the XML instance will be stored
    * @param ReferenceURI This referenceURI indicate where the data will for signature validation
    * @param manifest
    * @param messageDigestAlgorithm  {@link algorithms.MessageDigestAlgorithm Digest algorithm} which is applied to the data
    * @throws XMLSignatureException
    */
   protected Reference(
           Document doc, String BaseURI, String ReferenceURI, Manifest manifest, String messageDigestAlgorithm)
              throws XMLSignatureException {
<span class="nc" id="L226">      this(doc, BaseURI, ReferenceURI, manifest, (Transforms) null,</span>
           messageDigestAlgorithm);
<span class="nc" id="L228">   }</span>

   /**
    * Constructor Reference
    *
    * @param doc this {@link Document} in which &lt;code&gt;XMLsignature&lt;/code&gt; is placed
    * @param BaseURI the URI of the resource where the XML instance will be stored
    * @param ReferenceURI This referenceURI indicate where the data is for signature validation
    * @param manifest
    * @param transforms {@link transforms} applied to data
    * @throws XMLSignatureException
    */
   protected Reference(
           Document doc, String BaseURI, String ReferenceURI, Manifest manifest, Transforms transforms)
              throws XMLSignatureException {
<span class="nc" id="L243">      this(doc, BaseURI, ReferenceURI, manifest, transforms,</span>
           Constants.ALGO_ID_DIGEST_SHA1);
<span class="nc" id="L245">   }</span>

   /**
    * Constructor Reference
    *
    * @param doc this {@link Document} in which &lt;code&gt;XMLsignature&lt;/code&gt; is placed
    * @param BaseURI the URI of the resource where the XML instance will be stored
    * @param ReferenceURI This referenceURI indicate where the data is for signature validation
    * @param manifest
    * @throws XMLSignatureException
    */
   protected Reference(
           Document doc, String BaseURI, String ReferenceURI, Manifest manifest)
              throws XMLSignatureException {
<span class="nc" id="L259">      this(doc, BaseURI, ReferenceURI, manifest, (Transforms) null,</span>
           Constants.ALGO_ID_DIGEST_SHA1);
<span class="nc" id="L261">   }</span>

   /**
    * Build a {@link Reference} from an {@link Element}
    *
    * @param element &lt;code&gt;Reference&lt;/code&gt; element
    * @param BaseURI the URI of the resource where the XML instance was stored
    * @param manifest is the {@link Manifest} of {@link SignedInfo} in which the Reference occurs. We need this because the Manifest has the individual {@link ResourceResolver}s whcih have been set by the user
    * @throws XMLSecurityException
    */
   protected Reference(Element element, String BaseURI, Manifest manifest)
           throws XMLSecurityException {

<span class="fc" id="L274">      super(element, BaseURI);</span>

<span class="fc" id="L276">      this._manifest = manifest;</span>
<span class="fc" id="L277">   }</span>

   /**
    * Returns {@link MessageDigestAlgorithm}
    *
    *
    * @return {@link MessageDigestAlgorithm}
    *
    * @throws XMLSignatureException
    */
   public MessageDigestAlgorithm getMessageDigestAlgorithm()
           throws XMLSignatureException {

<span class="fc" id="L290">      Element digestMethodElem = this.getChildElementLocalName(0,</span>
                                    Constants.SignatureSpecNS,
                                    Constants._TAG_DIGESTMETHOD);

<span class="pc bpc" id="L294" title="1 of 2 branches missed.">      if (digestMethodElem == null) {</span>
<span class="nc" id="L295">         return null;</span>
      }

<span class="fc" id="L298">      String uri = digestMethodElem.getAttributeNS(null, Constants._ATT_ALGORITHM);</span>

<span class="fc" id="L300">      return MessageDigestAlgorithm.getInstance(this._doc, uri);</span>
   }

   /**
    * Sets the &lt;code&gt;URI&lt;/code&gt; of this &lt;code&gt;Reference&lt;/code&gt; element
    *
    * @param URI the &lt;code&gt;URI&lt;/code&gt; of this &lt;code&gt;Reference&lt;/code&gt; element
    */
   public void setURI(String URI) {

<span class="nc bnc" id="L310" title="All 4 branches missed.">      if ((this._state == MODE_SIGN) &amp;&amp; (URI != null)) {</span>
<span class="nc" id="L311">         this._constructionElement.setAttributeNS(null, Constants._ATT_URI, URI);</span>
      }
<span class="nc" id="L313">   }</span>

   /**
    * Returns the &lt;code&gt;URI&lt;/code&gt; of this &lt;code&gt;Reference&lt;/code&gt; element
    *
    * @return URI the &lt;code&gt;URI&lt;/code&gt; of this &lt;code&gt;Reference&lt;/code&gt; element
    */
   public String getURI() {
<span class="fc" id="L321">      return this._constructionElement.getAttributeNS(null, Constants._ATT_URI);</span>
   }

   /**
    * Sets the &lt;code&gt;Id&lt;/code&gt; attribute of this &lt;code&gt;Reference&lt;/code&gt; element
    *
    * @param Id the &lt;code&gt;Id&lt;/code&gt; attribute of this &lt;code&gt;Reference&lt;/code&gt; element
    */
   public void setId(String Id) {

<span class="nc bnc" id="L331" title="All 4 branches missed.">      if ((this._state == MODE_SIGN) &amp;&amp; (Id != null)) {</span>
<span class="nc" id="L332">         this._constructionElement.setAttributeNS(null, Constants._ATT_ID, Id);</span>
<span class="nc" id="L333">         IdResolver.registerElementById(this._constructionElement, Id);</span>
      }
<span class="nc" id="L335">   }</span>

   /**
    * Returns the &lt;code&gt;Id&lt;/code&gt; attribute of this &lt;code&gt;Reference&lt;/code&gt; element
    *
    * @return Id the &lt;code&gt;Id&lt;/code&gt; attribute of this &lt;code&gt;Reference&lt;/code&gt; element
    */
   public String getId() {
<span class="nc" id="L343">      return this._constructionElement.getAttributeNS(null, Constants._ATT_ID);</span>
   }

   /**
    * Sets the &lt;code&gt;type&lt;/code&gt; atttibute of the Reference indicate whether an &lt;code&gt;ds:Object&lt;/code&gt;, &lt;code&gt;ds:SignatureProperty&lt;/code&gt;, or &lt;code&gt;ds:Manifest&lt;/code&gt; element
    *
    * @param Type the &lt;code&gt;type&lt;/code&gt; attribute of the Reference
    */
   public void setType(String Type) {

<span class="nc bnc" id="L353" title="All 4 branches missed.">      if ((this._state == MODE_SIGN) &amp;&amp; (Type != null)) {</span>
<span class="nc" id="L354">         this._constructionElement.setAttributeNS(null, Constants._ATT_TYPE, Type);</span>
      }
<span class="nc" id="L356">   }</span>

   /**
    * Return the &lt;code&gt;type&lt;/code&gt; atttibute of the Reference indicate whether an &lt;code&gt;ds:Object&lt;/code&gt;, &lt;code&gt;ds:SignatureProperty&lt;/code&gt;, or &lt;code&gt;ds:Manifest&lt;/code&gt; element
    *
    * @return the &lt;code&gt;type&lt;/code&gt; attribute of the Reference
    */
   public String getType() {
<span class="fc" id="L364">      return this._constructionElement.getAttributeNS(null, Constants._ATT_TYPE);</span>
   }

   /**
    * Method isReferenceToObject
    *
    * This returns true if the &lt;CODE&gt;Type&lt;/CODE&gt; attribute of the
    * &lt;CODE&gt;Refernce&lt;/CODE&gt; element points to a &lt;CODE&gt;#Object&lt;/CODE&gt; element
    *
    * @return true if the Reference type indicates that this Reference points to an &lt;code&gt;Object&lt;/code&gt;
    */
   public boolean typeIsReferenceToObject() {

<span class="nc bnc" id="L377" title="All 4 branches missed.">      if ((this.getType() != null)</span>
              &amp;&amp; this.getType().equals(Reference.OBJECT_URI)) {
<span class="nc" id="L379">         return true;</span>
      }

<span class="nc" id="L382">      return false;</span>
   }

   /**
    * Method isReferenceToManifest
    *
    * This returns true if the &lt;CODE&gt;Type&lt;/CODE&gt; attribute of the
    * &lt;CODE&gt;Refernce&lt;/CODE&gt; element points to a &lt;CODE&gt;#Manifest&lt;/CODE&gt; element
    *
    * @return true if the Reference type indicates that this Reference points to a {@link Manifest}
    */
   public boolean typeIsReferenceToManifest() {

<span class="pc bpc" id="L395" title="1 of 4 branches missed.">      if ((this.getType() != null)</span>
              &amp;&amp; this.getType().equals(Reference.MANIFEST_URI)) {
<span class="fc" id="L397">         return true;</span>
      }

<span class="fc" id="L400">      return false;</span>
   }

   /**
    * Method setDigestValueElement
    *
    * @param digestValue
    * @throws XMLSignatureException
    */
   private void setDigestValueElement(byte[] digestValue)
           throws XMLSignatureException {

<span class="nc bnc" id="L412" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L413">         Element digestValueElement = this.getChildElementLocalName(0,</span>
                                         Constants.SignatureSpecNS,
                                         Constants._TAG_DIGESTVALUE);
<span class="nc" id="L416">         NodeList children = digestValueElement.getChildNodes();</span>

<span class="nc bnc" id="L418" title="All 2 branches missed.">         for (int i = 0; i &lt; children.getLength(); i++) {</span>
<span class="nc" id="L419">            digestValueElement.removeChild(children.item(i));</span>
         }

<span class="nc" id="L422">         String base64codedValue = Base64.encode(digestValue);</span>
<span class="nc" id="L423">         Text t = this._doc.createTextNode(base64codedValue);</span>

<span class="nc" id="L425">         digestValueElement.appendChild(t);</span>
      }
<span class="nc" id="L427">   }</span>

   /**
    * Method generateDigestValue
    *
    * @throws ReferenceNotInitializedException
    * @throws XMLSignatureException
    */
   public void generateDigestValue()
           throws XMLSignatureException, ReferenceNotInitializedException {

<span class="nc bnc" id="L438" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L439">         byte calculatedBytes[] = this.calculateDigest();</span>

<span class="nc" id="L441">         this.setDigestValueElement(calculatedBytes);</span>
      }
<span class="nc" id="L443">   }</span>

   /**
    * This method returns the {@link XMLSignatureInput} which is referenced by the
    * &lt;CODE&gt;URI&lt;/CODE&gt; Attribute.
    *
    * @throws ReferenceNotInitializedException
    * @throws XMLSignatureException
    * @ see Manifest#verifyReferences
    */
   protected void dereferenceURIandPerformTransforms()
           throws ReferenceNotInitializedException, XMLSignatureException {

      try {
<span class="fc" id="L457">         Attr URIAttr =</span>
            this._constructionElement.getAttributeNode(Constants._ATT_URI);
         String URI;

<span class="fc bfc" id="L461" title="All 2 branches covered.">         if (URIAttr == null) {</span>
<span class="fc" id="L462">            URI = null;</span>
         } else {
<span class="fc" id="L464">            URI = URIAttr.getNodeValue();</span>
         }

<span class="fc" id="L467">         ResourceResolver resolver = ResourceResolver.getInstance(URIAttr,</span>
                                        this._baseURI,
                                        this._manifest._perManifestResolvers);

<span class="pc bpc" id="L471" title="1 of 2 branches missed.">         if (resolver == null) {</span>
<span class="nc" id="L472">            Object exArgs[] = { URI };</span>

<span class="nc" id="L474">            throw new ReferenceNotInitializedException(</span>
               &quot;signature.Verification.Reference.NoInput&quot;, exArgs);
         }

<span class="fc" id="L478">         resolver.addProperties(this._manifest._resolverProperties);</span>

<span class="fc" id="L480">         this._transformsInput = resolver.resolve(URIAttr, this._baseURI);</span>

<span class="fc" id="L482">         Transforms transforms = this.getTransforms();</span>

<span class="fc bfc" id="L484" title="All 2 branches covered.">         if (transforms != null) {</span>
<span class="fc" id="L485">            this._transformsOutput =</span>
               transforms.performTransforms(this._transformsInput);
         } else {
<span class="fc" id="L488">            this._transformsOutput = this._transformsInput;</span>
         }
<span class="nc" id="L490">      } catch (ResourceResolverException ex) {</span>
<span class="nc" id="L491">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L492">      } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L493">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L494">      } catch (InvalidCanonicalizerException ex) {</span>
<span class="nc" id="L495">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L496">      } catch (TransformationException ex) {</span>
<span class="nc" id="L497">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L498">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L499">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="fc" id="L500">      }</span>
<span class="fc" id="L501">   }</span>

   /**
    * Method getTransforms
    *
    * @return
    * @throws InvalidTransformException
    * @throws TransformationException
    * @throws XMLSecurityException
    * @throws XMLSignatureException
    */
   public Transforms getTransforms()
           throws XMLSignatureException, InvalidTransformException,
                  TransformationException, XMLSecurityException {

<span class="fc" id="L516">      Element transformsElement = this.getChildElementLocalName(0,</span>
                                     Constants.SignatureSpecNS,
                                     Constants._TAG_TRANSFORMS);

<span class="fc bfc" id="L520" title="All 2 branches covered.">      if (transformsElement != null) {</span>
<span class="fc" id="L521">         Transforms transforms = new Transforms(transformsElement,</span>
                                                this._baseURI);

<span class="fc" id="L524">         return transforms;</span>
      } else {
<span class="fc" id="L526">         return null;</span>
      }
   }

   /**
    * Method getReferencedBytes
    *
    * @return
    * @throws ReferenceNotInitializedException
    * @throws XMLSignatureException
    */
   public byte[] getReferencedBytes()
           throws ReferenceNotInitializedException, XMLSignatureException {

      try {
<span class="fc" id="L541">         this.dereferenceURIandPerformTransforms();</span>

<span class="fc" id="L543">         byte[] signedBytes = this.getTransformsOutput().getBytes();</span>

<span class="fc" id="L545">         return signedBytes;</span>
<span class="nc" id="L546">      } catch (IOException ex) {</span>
<span class="nc" id="L547">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L548">      } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L549">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L550">      } catch (InvalidCanonicalizerException ex) {</span>
<span class="nc" id="L551">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
      }
   }

   /**
    * Method resolverResult
    *
    * @return
    * @throws ReferenceNotInitializedException
    * @throws XMLSignatureException
    */
   private byte[] calculateDigest()
           throws ReferenceNotInitializedException, XMLSignatureException {

      try {
<span class="fc" id="L566">         byte[] data = this.getReferencedBytes();</span>
<span class="fc" id="L567">         MessageDigestAlgorithm mda = this.getMessageDigestAlgorithm();</span>

<span class="fc" id="L569">         mda.reset();</span>
<span class="fc" id="L570">         mda.update(data);</span>

<span class="fc" id="L572">         byte calculatedDigestValue[] = mda.digest();</span>

         //J-
<span class="fc bfc" id="L575" title="All 2 branches covered.">         if (data.length &lt; 20) {</span>
<span class="fc" id="L576">            cat.debug(new String(data));</span>
         } else {
<span class="fc" id="L578">            cat.debug(new String(data).substring(0, 20) + &quot; ...&quot;);</span>
         }
         //J+
<span class="fc" id="L581">         return calculatedDigestValue;</span>
<span class="nc" id="L582">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L583">         throw new ReferenceNotInitializedException(&quot;empty&quot;, ex);</span>
      }
   }

   /**
    * Tests reference valdiation is success or false
    *
    * @return true if reference valdiation is success, otherwise false
    * @throws ReferenceNotInitializedException
    * @throws XMLSecurityException
    */
   public boolean verify()
           throws ReferenceNotInitializedException, XMLSecurityException {

<span class="fc" id="L597">      Element digestValueElem = this.getChildElementLocalName(0,</span>
                                   Constants.SignatureSpecNS,
                                   Constants._TAG_DIGESTVALUE);
<span class="fc" id="L600">      byte[] elemDig = Base64.decode(digestValueElem);</span>
<span class="fc" id="L601">      byte[] calcDig = this.calculateDigest();</span>
<span class="fc" id="L602">      boolean equal = MessageDigestAlgorithm.isEqual(elemDig, calcDig);</span>

<span class="fc bfc" id="L604" title="All 2 branches covered.">      if (!equal) {</span>
<span class="fc" id="L605">         cat.warn(&quot;Verification failed for URI \&quot;&quot; + this.getURI() + &quot;\&quot;&quot;);</span>

<span class="pc bpc" id="L607" title="1 of 2 branches missed.">         if (cat.isDebugEnabled()) {</span>
<span class="nc" id="L608">            cat.debug(&quot;unverifiedDigestValue= &quot; + Base64.encode(elemDig));</span>
<span class="nc" id="L609">            cat.debug(&quot;calculatedDigestValue= &quot; + Base64.encode(calcDig));</span>

            /*
            try {
               String tmp = new Long(System.currentTimeMillis()).toString()
                            + &quot;.txt&quot;;

               cat.warn(&quot;Wrote \&quot;&quot; + this.getURI() + &quot;\&quot; to file &quot; + tmp);
               JavaUtils.writeBytesToFilename(tmp, this.getReferencedBytes());
            } catch (Exception ex) {}
            */
         }
      } else {
<span class="fc" id="L622">         cat.info(&quot;Verification successful for URI \&quot;&quot; + this.getURI() + &quot;\&quot;&quot;);</span>
      }

<span class="fc" id="L625">      return equal;</span>
   }

   /**
    * Method getTransformsInput
    *
    * @return
    */
   public XMLSignatureInput getTransformsInput() {
<span class="nc" id="L634">      return this._transformsInput;</span>
   }

   /**
    * Method getTransformsOutput
    *
    * @return
    */
   public XMLSignatureInput getTransformsOutput() {
<span class="fc" id="L643">      return this._transformsOutput;</span>
   }

   /**
    * Method getBaseLocalName
    *
    * @return
    */
   public String getBaseLocalName() {
<span class="fc" id="L652">      return Constants._TAG_REFERENCE;</span>
   }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>