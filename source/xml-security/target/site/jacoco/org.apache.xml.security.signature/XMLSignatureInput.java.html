<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XMLSignatureInput.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.signature</a> &gt; <span class="el_source">XMLSignatureInput.java</span></div><h1>XMLSignatureInput.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.signature;



import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import org.w3c.dom.*;
import org.xml.sax.InputSource;
import javax.xml.parsers.*;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.c14n.InvalidCanonicalizerException;
import org.apache.xml.security.c14n.CanonicalizationException;
import org.apache.xml.security.c14n.Canonicalizer;
import org.apache.xml.security.utils.XMLUtils;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import java.io.IOException;
import org.xml.sax.SAXException;
import org.apache.xpath.CachedXPathAPI;
import org.apache.xpath.XPathContext;


/**
 * Class XMLSignatureInput
 *
 * @author Christian Geuer-Pollmann
 * @todo check whether an XMLSignatureInput can be _both_, octet stream _and_ node set?
 */
public class XMLSignatureInput {

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L99">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category.getInstance(XMLSignatureInput.class.getName());

   /** Field useFlatNodes */
   static final boolean useFlatNodes = false;

   /**
    * The original InputStream for this XMLSignatureInput
    */
<span class="pc" id="L108">   InputStream _inputOctetStream = null;</span>

   /**
    * Some InputStreams do not support the {@link java.io.InputStream#reset}
    * method, so we read it in completely and work on our Proxy.
    */
<span class="pc" id="L114">   ByteArrayInputStream _inputOctetStreamProxy = null;</span>

   /**
    * The original NodeSet for this XMLSignatureInput
    */
<span class="pc" id="L119">   NodeList _inputNodeSet = null;</span>

   /** Field _cxpathAPI */
   CachedXPathAPI _cxpathAPI;

   /**
    *  If we serialize a NodeSet, will Comment nodes be included?
    *  &lt;p&gt;
    *  If we look in section 4.3.3.2 The Reference Processing Model, there is stated:
    *  &lt;ul&gt;
    *  &lt;li&gt;If the data object is a node-set and the next transform requires
    *      octets, the signature application MUST attempt to convert the
    *      node-set to an octet stream using the REQUIRED canonicalization algorithm [XML-C14N].&lt;/li&gt;
    *  &lt;/ul&gt;
    * &lt;p&gt;
    * From my understanding, Canonical XML (omits comments) is the only c14n algorithm which is REQUIRED.
    */
<span class="pc" id="L136">   String _canonicalizerURI = Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS;</span>

   /** Field _xpathString */
<span class="pc" id="L139">   String _xpathString = Canonicalizer.XPATH_C14N_OMIT_COMMENTS;</span>

   /**
    * Constructs a &lt;code&gt;XMLSignatureInput&lt;/code&gt; from {@link InputStream an octet stream} which made from XML document , node
    *
    * @param inputOctetStream {@link InputStream} which including XML document or node
    */
<span class="fc" id="L146">   public XMLSignatureInput(InputStream inputOctetStream) {</span>
<span class="fc" id="L147">      this._inputOctetStream = inputOctetStream;</span>
<span class="fc" id="L148">      this._cxpathAPI = new CachedXPathAPI();</span>
<span class="fc" id="L149">   }</span>

   /**
    * Construct a XMLSignatureInput from an octet array.
    * &lt;p&gt;
    * This is a comfort method, which internally converts the byte[] array into an InputStream
    *
    * @param inputOctets an octet array which including XML document or node
    */
<span class="nc" id="L158">   public XMLSignatureInput(byte[] inputOctets) {</span>
<span class="nc" id="L159">      this._inputOctetStream = new ByteArrayInputStream(inputOctets);</span>
<span class="nc" id="L160">      this._cxpathAPI = new CachedXPathAPI();</span>
<span class="nc" id="L161">   }</span>

   /**
    * Construct a XMLSignatureInput from a String.
    * &lt;p&gt;
    * This is a comfort method, which internally converts the String into a byte[] array using the {@link java.lang.String#getBytes} method.
    *
    * @param inputStr the input String which including XML document or node
    */
<span class="nc" id="L170">   public XMLSignatureInput(String inputStr) {</span>
<span class="nc" id="L171">      this._inputOctetStream = new ByteArrayInputStream(inputStr.getBytes());</span>
<span class="nc" id="L172">      this._cxpathAPI = new CachedXPathAPI();</span>
<span class="nc" id="L173">   }</span>

   /**
    * Construct a XMLSignatureInput from a String with a given encoding.
    * &lt;p&gt;
    * This is a comfort method, which internally converts the String into a byte[] array using the {@link java.lang.String#getBytes} method.
    *
    * @param inputStr the input String with encoding &lt;code&gt;encoding&lt;/code&gt;
    * @param encoding the encoding of &lt;code&gt;inputStr&lt;/code&gt;
    * @throws UnsupportedEncodingException
    */
   public XMLSignatureInput(String inputStr, String encoding)
<span class="nc" id="L185">           throws UnsupportedEncodingException {</span>

<span class="nc" id="L187">      this._inputOctetStream =</span>
         new ByteArrayInputStream(inputStr.getBytes(encoding));
<span class="nc" id="L189">      this._cxpathAPI = new CachedXPathAPI();</span>
<span class="nc" id="L190">   }</span>

   /**
    * Construct a XMLSignatureInput from a node set. Only the nodes from the
    * &lt;CODE&gt;inputNodeSet&lt;/CODE&gt; occur in the output.
    *
    * @param inputNodeSet is the node set
    */
<span class="nc" id="L198">   private XMLSignatureInput(NodeList inputNodeSet) {</span>
<span class="nc" id="L199">      this._inputNodeSet = inputNodeSet;</span>
<span class="nc" id="L200">      this._cxpathAPI = new CachedXPathAPI();</span>
<span class="nc" id="L201">   }</span>

   /**
    * Construct a XMLSignatureInput from a Node. This method included the node
    * and &lt;I&gt;all&lt;/I&gt; his descendants in the output.
    *
    * @param node
    * @throws TransformerException
    */
<span class="fc" id="L210">   public XMLSignatureInput(Node node) throws TransformerException {</span>

<span class="fc" id="L212">      cat.debug(&quot;Start &quot; + _xpathString + &quot; on Node &quot; + node.getNodeName());</span>

<span class="fc" id="L214">      this._cxpathAPI = new CachedXPathAPI();</span>
<span class="fc" id="L215">      this._inputNodeSet = this._cxpathAPI.selectNodeList(node,</span>
              Canonicalizer.XPATH_C14N_WITH_COMMENTS_SINGLE_NODE);
<span class="fc" id="L217">   }</span>

   /**
    * Construct a XMLSignatureInput from a node set. Only the nodes from the
    * &lt;CODE&gt;inputNodeSet&lt;/CODE&gt; occur in the output.
    *
    * @param inputNodeSet is the node set
    * @param usedXPathAPI
    */
   public XMLSignatureInput(NodeList inputNodeSet,
<span class="fc" id="L227">                            CachedXPathAPI usedXPathAPI) {</span>
<span class="fc" id="L228">      this._inputNodeSet = inputNodeSet;</span>
<span class="fc" id="L229">      this._cxpathAPI = usedXPathAPI;</span>
<span class="fc" id="L230">   }</span>

   /**
    * Construct a XMLSignatureInput from a Node. This method included the node
    * and &lt;I&gt;all&lt;/I&gt; his descendants in the output.
    *
    * @param node
    * @param usedXPathAPI
    * @throws TransformerException
    */
   public XMLSignatureInput(Node node, CachedXPathAPI usedXPathAPI)
<span class="nc" id="L241">           throws TransformerException {</span>

<span class="nc" id="L243">      cat.debug(&quot;Start &quot; + _xpathString + &quot; on Node &quot; + node.getNodeName());</span>

<span class="nc" id="L245">      this._cxpathAPI = usedXPathAPI;</span>
<span class="nc" id="L246">      this._inputNodeSet = this._cxpathAPI.selectNodeList(node,</span>
              Canonicalizer.XPATH_C14N_WITH_COMMENTS_SINGLE_NODE);
<span class="nc" id="L248">   }</span>

   /**
    * Returns the node set from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    *
    * @return the node set
    * @throws CanonicalizationException
    * @throws IOException
    * @throws InvalidCanonicalizerException
    * @throws ParserConfigurationException
    * @throws SAXException
    */
   public NodeList getNodeSet()
           throws ParserConfigurationException, IOException, SAXException,
                  CanonicalizationException, InvalidCanonicalizerException {

<span class="fc bfc" id="L264" title="All 2 branches covered.">      if (this.isNodeSet()) {</span>
<span class="fc" id="L265">         return this._inputNodeSet;</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">      } else if (this.isOctetStream()) {</span>
<span class="fc" id="L267">         DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();</span>

<span class="fc" id="L269">         dfactory.setValidating(false);</span>
<span class="fc" id="L270">         dfactory.setNamespaceAware(true);</span>

<span class="fc" id="L272">         DocumentBuilder db = dfactory.newDocumentBuilder();</span>

         try {
<span class="fc" id="L275">            db.setErrorHandler(new org.apache.xml.security.utils</span>
               .IgnoreAllErrorHandler());

<span class="fc" id="L278">            Document document = db.parse(this.getOctetStream());</span>

            if (XMLSignatureInput.useFlatNodes) {
               return document.getChildNodes();
            } else {
<span class="fc" id="L283">               return this._cxpathAPI.selectNodeList(document, _xpathString);</span>
            }
<span class="nc" id="L285">         } catch (TransformerException ex) {</span>
<span class="nc" id="L286">            throw new CanonicalizationException(&quot;generic.EmptyMessage&quot;, ex);</span>
<span class="fc" id="L287">         } catch (SAXException ex) {</span>

            // if a not-wellformed nodeset exists, put a container around it...
<span class="fc" id="L290">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="fc" id="L291">            String container = &quot;container&quot;;</span>

<span class="fc" id="L293">            baos.write((new String(&quot;&lt;&quot; + container + &quot;&gt;&quot;)).getBytes());</span>
<span class="fc" id="L294">            baos.write(this.getBytes());</span>
<span class="fc" id="L295">            baos.write((new String(&quot;&lt;/&quot; + container + &quot;&gt;&quot;)).getBytes());</span>

            if (XMLSignatureInput.useFlatNodes) {
               byte result[] = baos.toByteArray();
               Document document = db.parse(new ByteArrayInputStream(result));

               return document.getFirstChild().getChildNodes();
            } else {
<span class="fc" id="L303">               byte result[] = baos.toByteArray();</span>
<span class="fc" id="L304">               Document document = db.parse(new ByteArrayInputStream(result));</span>

               try {
<span class="fc" id="L307">                  String noDocument = &quot;not(self::node()=/)&quot;;</span>

                  // String noDocumentElement = &quot;not(local-name()='&quot; + container + &quot;')&quot;
<span class="fc" id="L310">                  String noDocumentElement = &quot;not(self::node=/node())&quot;;</span>
<span class="fc" id="L311">                  String xpathStr =</span>
                     &quot;(//. | //@* | //namespace::*)[not(self::comment()) and &quot;
                     + noDocument + &quot; and &quot; + noDocumentElement + &quot;]&quot;;
<span class="fc" id="L314">                  NodeList nodes = this._cxpathAPI.selectNodeList(document,</span>
                                      xpathStr);

<span class="fc" id="L317">                  return nodes;</span>
<span class="nc" id="L318">               } catch (TransformerException ex2) {</span>
<span class="nc" id="L319">                  throw new CanonicalizationException(&quot;generic.EmptyMessage&quot;,</span>
                                                      ex2);
               }
            }
         }
      }

<span class="nc" id="L326">      throw new RuntimeException(</span>
         &quot;getNodeSet() called but no input data present&quot;);
   }

   /**
    * Returns the Octect stream(byte Stream) from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    *
    * @return the Octect stream(byte Stream) from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    * @throws CanonicalizationException
    * @throws IOException
    * @throws InvalidCanonicalizerException
    */
   public InputStream getOctetStream()
           throws IOException, CanonicalizationException,
                  InvalidCanonicalizerException {

<span class="fc bfc" id="L342" title="All 2 branches covered.">      if (this.isOctetStream()) {</span>
<span class="fc bfc" id="L343" title="All 2 branches covered.">         if (this._inputOctetStream.markSupported()) {</span>

            // no need to read in the complete stream, because we can reset()
<span class="fc" id="L346">            this._inputOctetStream.reset();</span>

<span class="fc" id="L348">            return this._inputOctetStream;</span>
         } else {
<span class="pc bpc" id="L350" title="1 of 2 branches missed.">            if (this._inputOctetStreamProxy == null) {</span>

               // read in complete InputStream into internal byte[] array.
<span class="fc" id="L353">               byte[] _inputOctets =</span>
                  new byte[this._inputOctetStream.available()];

<span class="fc" id="L356">               this._inputOctetStream.read(_inputOctets);</span>

<span class="fc" id="L358">               this._inputOctetStreamProxy =</span>
                  new ByteArrayInputStream(_inputOctets);
<span class="fc" id="L360">            } else {</span>
<span class="nc" id="L361">               this._inputOctetStreamProxy.reset();</span>
            }

<span class="fc" id="L364">            return this._inputOctetStreamProxy;</span>
         }
<span class="pc bpc" id="L366" title="1 of 2 branches missed.">      } else if (this.isNodeSet()) {</span>

         /* serialize Element(s) and output them
          */
<span class="fc" id="L370">         Canonicalizer c14nizer =</span>
            Canonicalizer.getInstance(this._canonicalizerURI);
<span class="fc" id="L372">         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>

<span class="pc bpc" id="L374" title="1 of 2 branches missed.">         if (this._inputNodeSet.getLength() == 0) {</span>

            // empty nodeset
<span class="nc" id="L377">            return new ByteArrayInputStream(baos.toByteArray());</span>
         }

<span class="fc" id="L380">         cat.debug(&quot;set XPathNodeSet with &quot; + this._inputNodeSet.getLength()</span>
                   + &quot; nodes&quot;);
<span class="fc" id="L382">         c14nizer.setXPathNodeSet(this._inputNodeSet);</span>
<span class="fc" id="L383">         cat.debug(&quot;The nodeset _inputNodeSet has &quot;</span>
                   + this._inputNodeSet.getLength() + &quot; Nodes&quot;);

         /* We want to output the NodeList and do this by retrieving the Document Node
          * and outputting the Document
          */
<span class="fc" id="L389">         cat.debug(&quot;node(0) is &quot; + this._inputNodeSet.item(0));</span>

<span class="fc" id="L391">         Document doc = XMLUtils.getOwnerDocument(this._inputNodeSet.item(0));</span>
<span class="fc" id="L392">         byte bytes[] = c14nizer.canonicalize(doc);</span>

<span class="fc" id="L394">         baos.write(bytes);</span>

         /** @todo Clarify behavior. If isNodeSet() and we getOctetStream, do we have to this._inputOctetStream=xxx ? */

         /*
         this._inputOctetStream = new ByteArrayInputStream(baos.toByteArray());
         this._inputNodeSet = null;
         return this._inputOctetStream;
         */
<span class="fc" id="L403">         return new ByteArrayInputStream(baos.toByteArray());</span>
      }

<span class="nc" id="L406">      throw new RuntimeException(</span>
         &quot;getOctetStream() called but no input data present&quot;);
   }

   /**
    * Returns the byte array from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    *
    * @return the byte[] from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    *
    * @throws CanonicalizationException
    * @throws IOException
    * @throws InvalidCanonicalizerException
    */
   public byte[] getBytes()
           throws IOException, CanonicalizationException,
                  InvalidCanonicalizerException {

<span class="fc" id="L423">      InputStream is = this.getOctetStream();</span>
<span class="fc" id="L424">      int available = is.available();</span>
<span class="fc" id="L425">      byte[] data = new byte[available];</span>

<span class="fc" id="L427">      is.read(data);</span>

<span class="pc bpc" id="L429" title="1 of 2 branches missed.">      if (available != data.length) {</span>
<span class="nc" id="L430">         throw new IOException(&quot;Not enough bytes read&quot;);</span>
      }

<span class="fc" id="L433">      return data;</span>
   }

   /**
    * Determines if the object has been set up with a Node set
    *
    * @return true is the object has been set up with a Node set
    */
   public boolean isNodeSet() {
<span class="pc bpc" id="L442" title="1 of 4 branches missed.">      return ((this._inputOctetStream == null) &amp;&amp; (this._inputNodeSet != null));</span>
   }

   /**
    * Determines if the object has been set up with an octet stream
    *
    * @return true is the object has been set up with an octet stream
    */
   public boolean isOctetStream() {
<span class="pc bpc" id="L451" title="1 of 4 branches missed.">      return ((this._inputOctetStream != null) &amp;&amp; (this._inputNodeSet == null));</span>
   }

   /**
    * Is the object correctly set up?
    *
    * @return true if the object has been set up correctly
    */
   public boolean isInitialized() {
<span class="pc bpc" id="L460" title="1 of 4 branches missed.">      return (this.isOctetStream() || this.isNodeSet());</span>
   }

   /**
    * Defines whether Comment nodes should be included if we serialize a NodeSet
    *
    * @param canonicalizerURI
    */
   public void setCanonicalizerURI(String canonicalizerURI) {
<span class="fc" id="L469">      this._canonicalizerURI = canonicalizerURI;</span>
<span class="fc" id="L470">   }</span>

   /**
    * If we serialize a NodeSet, will Comment nodes be included?
    *
    * @return true if Comment nodes are included in a serialized node set
    */
   public String getCanonicalizerURI() {
<span class="nc" id="L478">      return this._canonicalizerURI;</span>
   }

   /**
    * Sets &lt;code&gt;XPath expression&lt;/code&gt; want to get node set
    *
    * @param selectedNodesetXPath &lt;code&gt;XPath&lt;/code&gt; want to get node set
    */
   public void setNodesetXPath(String selectedNodesetXPath) {
<span class="fc" id="L487">      this._xpathString = selectedNodesetXPath;</span>
<span class="fc" id="L488">   }</span>

   /**
    * Returns &lt;code&gt;XPath expression&lt;/code&gt; want to get node set
    *
    * @return &lt;code&gt;XPath expression&lt;/code&gt; want to get node set
    */
   public String getNodesetXPath() {
<span class="nc" id="L496">      return this._xpathString;</span>
   }

   /**
    * Some Transforms may require explicit MIME type, charset (IANA registered
    * &quot;character set&quot;), or other such information concerning the data they
    * are receiving from an earlier Transform or the source data, although no
    * Transform algorithm specified in this document needs such explicit
    * information. Such data characteristics are provided as parameters to the
    * Transform algorithm and should be described in the specification for the
    * algorithm.
    */
<span class="pc" id="L508">   private String _MIMEType = null;</span>

   /**
    * Returns MIMEType
    *
    * @return MIMEType
    */
   public String getMIMEType() {
<span class="nc" id="L516">      return this._MIMEType;</span>
   }

   /**
    * Sets MIMEType
    *
    * @param MIMEType
    */
   public void setMIMEType(String MIMEType) {
<span class="fc" id="L525">      this._MIMEType = MIMEType;</span>
<span class="fc" id="L526">   }</span>

   /** Field _SourceURI */
<span class="pc" id="L529">   private String _SourceURI = null;</span>

   /**
    * Return SourceURI
    *
    * @return SourceURI
    */
   public String getSourceURI() {
<span class="fc" id="L537">      return this._SourceURI;</span>
   }

   /**
    * Sets SourceURI
    *
    * @param SourceURI
    */
   public void setSourceURI(String SourceURI) {
<span class="fc" id="L546">      this._SourceURI = SourceURI;</span>
<span class="fc" id="L547">   }</span>

   /**
    * Method main
    *
    * @param args
    * @throws Exception
    */
   public static void main(String args[]) throws Exception {

<span class="nc" id="L557">      String inputStr =</span>
         &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot; + &quot;&lt;!-- full document --&gt;&lt;_doc&gt;&quot;
         + &quot;&lt;n xmlns:ietf='http://www.ietf.org/'&gt;&lt;ietf:comment&gt;1&lt;/ietf:comment&gt;&lt;/n&gt;&lt;n&gt;2&lt;/n&gt;&lt;n&gt;3&lt;/n&gt;&lt;n&gt;4&lt;/n&gt;&quot;
         + &quot;&lt;/_doc&gt;&quot;;

<span class="nc" id="L562">      inputStr =</span>
         &quot;&lt;n xmlns:ietf='http://www.ietf.org/'&gt;&lt;ietf:comment xmlns:ietf='http://www.ietf.org/'&gt;1&lt;/ietf:comment&gt;&lt;/n&gt;&lt;n&gt;2&lt;/n&gt;&lt;n&gt;3&lt;/n&gt;&lt;n&gt;4&lt;/n&gt;&quot;;

<span class="nc" id="L565">      XMLSignatureInput input = new XMLSignatureInput(inputStr.getBytes());</span>
<span class="nc" id="L566">      NodeList nl = input.getNodeSet();</span>

<span class="nc bnc" id="L568" title="All 2 branches missed.">      if (nl.getLength() == 0) {</span>
<span class="nc" id="L569">         System.out.println(&quot;No Nodes found&quot;);</span>
      } else {
<span class="nc bnc" id="L571" title="All 2 branches missed.">         for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="nc" id="L572">            Node n = nl.item(i);</span>

<span class="nc" id="L574">            System.out.println(XMLUtils.getNodeTypeString(n) + &quot; &quot;</span>
                               + n.getNodeName());
         }
      }

<span class="nc" id="L579">      Canonicalizer c =</span>
         Canonicalizer.getInstance(Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS);

<span class="nc" id="L582">      c.setXPathNodeSet(nl);</span>
<span class="nc" id="L583">      System.out.println(new String(c.canonicalize(nl)));</span>
<span class="nc" id="L584">   }</span>

   /**
    * This method gives access to an {@link org.apache.xpath.CachedXPathAPI}
    * object which was used for creating the internal node set and which MUST be
    * used for subsequent operations on this node set.
    *
    * @return an existing {@link org.apache.xpath.CachedXPathAPI}
    */
   public CachedXPathAPI getCachedXPathAPI() {
<span class="fc" id="L594">      return this._cxpathAPI;</span>
   }

   /**
    * Method toString
    *
    * @return
    */
   public String toString() {

<span class="nc bnc" id="L604" title="All 2 branches missed.">      if (this.isNodeSet()) {</span>
         try {
<span class="nc" id="L606">            return &quot;XMLSignatureInput/NodeSet/&quot; + this.getNodeSet().getLength()</span>
                   + &quot; nodes/&quot; + this.getSourceURI();
<span class="nc" id="L608">         } catch (Exception ex) {</span>
<span class="nc" id="L609">            return &quot;XMLSignatureInput/NodeSet//&quot; + this.getSourceURI();</span>
         }
      } else {
         try {
<span class="nc" id="L613">            return &quot;XMLSignatureInput/OctetStream/&quot; + this.getBytes().length</span>
                   + &quot; octets/&quot; + this.getSourceURI();
<span class="nc" id="L615">         } catch (Exception ex) {</span>
<span class="nc" id="L616">            return &quot;XMLSignatureInput/OctetStream//&quot; + this.getSourceURI();</span>
         }
      }
   }

   static {
<span class="fc" id="L622">      org.apache.xml.security.Init.init();</span>
<span class="fc" id="L623">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>