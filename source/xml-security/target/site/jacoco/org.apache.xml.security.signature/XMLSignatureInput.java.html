<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XMLSignatureInput.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.signature</a> &gt; <span class="el_source">XMLSignatureInput.java</span></div><h1>XMLSignatureInput.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.signature;



import java.io.File;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.UnsupportedEncodingException;
import java.util.*;
import org.w3c.dom.*;
import org.xml.sax.InputSource;
import javax.xml.parsers.*;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.c14n.*;
import org.apache.xml.security.c14n.implementations.*;
import org.apache.xml.security.utils.XMLUtils;
import org.apache.xml.security.utils.JavaUtils;
import org.apache.xml.security.utils.HelperNodeList;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import java.io.IOException;
import org.xml.sax.SAXException;
import org.apache.xpath.CachedXPathAPI;
import org.apache.xpath.XPathContext;


/**
 * Class XMLSignatureInput
 *
 * @author Christian Geuer-Pollmann
 * @todo check whether an XMLSignatureInput can be _both_, octet stream _and_ node set?
 */
public class XMLSignatureInput {

   /**
    * Some InputStreams do not support the {@link java.io.InputStream#reset}
    * method, so we read it in completely and work on our Proxy.
    */
<span class="fc" id="L104">   InputStream _inputOctetStreamProxy = null;</span>

   /**
    * The original NodeSet for this XMLSignatureInput
    */
<span class="fc" id="L109">   Set _inputNodeSet = null;</span>

   /** Field _cxpathAPI */
   CachedXPathAPI _cxpathAPI;

   /**
    * Construct a XMLSignatureInput from an octet array.
    * &lt;p&gt;
    * This is a comfort method, which internally converts the byte[] array into an InputStream
    *
    * @param inputOctets an octet array which including XML document or node
    */
<span class="fc" id="L121">   public XMLSignatureInput(byte[] inputOctets) {</span>

      // defensive copy
<span class="fc" id="L124">      byte[] copy = new byte[inputOctets.length];</span>

<span class="fc" id="L126">      System.arraycopy(inputOctets, 0, copy, 0, inputOctets.length);</span>

<span class="fc" id="L128">      this._inputOctetStreamProxy = new ByteArrayInputStream(copy);</span>
<span class="fc" id="L129">      this._cxpathAPI = new CachedXPathAPI();</span>
<span class="fc" id="L130">   }</span>

   /**
    * Constructs a &lt;code&gt;XMLSignatureInput&lt;/code&gt; from an octet stream. The
    * stream is directly read.
    *
    * @param inputOctetStream
    * @throws IOException
    */
   public XMLSignatureInput(InputStream inputOctetStream) throws IOException {

<span class="fc" id="L141">      this(JavaUtils.getBytesFromStream(inputOctetStream));</span>

<span class="fc" id="L143">      inputOctetStream = null;    // free object reference</span>
<span class="fc" id="L144">   }</span>

   /**
    * Construct a XMLSignatureInput from a String.
    * &lt;p&gt;
    * This is a comfort method, which internally converts the String into a byte[] array using the {@link java.lang.String#getBytes} method.
    *
    * @param inputStr the input String which including XML document or node
    */
   public XMLSignatureInput(String inputStr) {
<span class="nc" id="L154">      this(inputStr.getBytes());</span>
<span class="nc" id="L155">   }</span>

   /**
    * Construct a XMLSignatureInput from a String with a given encoding.
    * &lt;p&gt;
    * This is a comfort method, which internally converts the String into a byte[] array using the {@link java.lang.String#getBytes} method.
    *
    * @param inputStr the input String with encoding &lt;code&gt;encoding&lt;/code&gt;
    * @param encoding the encoding of &lt;code&gt;inputStr&lt;/code&gt;
    * @throws UnsupportedEncodingException
    */
   public XMLSignatureInput(String inputStr, String encoding)
           throws UnsupportedEncodingException {
<span class="nc" id="L168">      this(inputStr.getBytes(encoding));</span>
<span class="nc" id="L169">   }</span>

   /**
    * Construct a XMLSignatureInput from a subtree rooted by rootNode. This
    * method included the node and &lt;I&gt;all&lt;/I&gt; his descendants in the output.
    *
    * @param rootNode
    * @param usedXPathAPI
    * @throws TransformerException
    */
   public XMLSignatureInput(Node rootNode, CachedXPathAPI usedXPathAPI)
<span class="fc" id="L180">           throws TransformerException {</span>

<span class="fc" id="L182">      this._cxpathAPI = usedXPathAPI;</span>

      // get the Document and make all namespace nodes visible in DOM space
<span class="fc" id="L185">      Document doc = XMLUtils.getOwnerDocument(rootNode);</span>
<span class="fc" id="L186">      XMLUtils.circumventBug2650(doc);</span>

<span class="fc" id="L188">      NodeList result = this._cxpathAPI.selectNodeList(rootNode,</span>
                           Canonicalizer.XPATH_C14N_WITH_COMMENTS_SINGLE_NODE);

<span class="fc" id="L191">      this._inputNodeSet = XMLUtils.convertNodelistToSet(result);</span>
<span class="fc" id="L192">   }</span>

   /**
    * Construct a XMLSignatureInput from a subtree rooted by rootNode. This method included the node
    * and &lt;I&gt;all&lt;/I&gt; his descendants in the output.
    *
    * @param rootNode
    * @throws TransformerException
    */
   public XMLSignatureInput(Node rootNode) throws TransformerException {
<span class="fc" id="L202">      this(rootNode, new CachedXPathAPI());</span>
<span class="fc" id="L203">   }</span>

   /**
    * Constructor XMLSignatureInput
    *
    * @param inputNodeSet
    * @param usedXPathAPI
    */
<span class="fc" id="L211">   public XMLSignatureInput(Set inputNodeSet, CachedXPathAPI usedXPathAPI) {</span>
<span class="fc" id="L212">      this._inputNodeSet = inputNodeSet;</span>
<span class="fc" id="L213">      this._cxpathAPI = usedXPathAPI;</span>
<span class="fc" id="L214">   }</span>

   /**
    * Constructor XMLSignatureInput
    *
    * @param inputNodeSet
    */
   public XMLSignatureInput(Set inputNodeSet) {
<span class="nc" id="L222">      this(inputNodeSet, new CachedXPathAPI());</span>
<span class="nc" id="L223">   }</span>

   /**
    * Returns the node set from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    *
    * @return the node set
    * @throws CanonicalizationException
    * @throws IOException
    * @throws InvalidCanonicalizerException
    * @throws ParserConfigurationException
    * @throws SAXException
    */
   public Set getNodeSet()
           throws ParserConfigurationException, IOException, SAXException,
                  CanonicalizationException, InvalidCanonicalizerException {

<span class="fc bfc" id="L239" title="All 2 branches covered.">      if (this.isNodeSet()) {</span>
<span class="fc" id="L240">         return this._inputNodeSet;</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">      } else if (this.isOctetStream()) {</span>
<span class="fc" id="L242">         DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();</span>

<span class="fc" id="L244">         dfactory.setValidating(false);</span>
<span class="fc" id="L245">         dfactory.setNamespaceAware(true);</span>

<span class="fc" id="L247">         DocumentBuilder db = dfactory.newDocumentBuilder();</span>

         try {
<span class="fc" id="L250">            db.setErrorHandler(new org.apache.xml.security.utils</span>
               .IgnoreAllErrorHandler());

<span class="fc" id="L253">            Document doc = db.parse(this.getOctetStream());</span>

<span class="fc" id="L255">            XMLUtils.circumventBug2650(doc);</span>

            // select all nodes, also the comments.
<span class="fc" id="L258">            NodeList nodeList =</span>
               this._cxpathAPI
                  .selectNodeList(doc,
                                  Canonicalizer
                                     .XPATH_C14N_WITH_COMMENTS_SINGLE_NODE);

<span class="fc" id="L264">            return XMLUtils.convertNodelistToSet(nodeList);</span>
<span class="nc" id="L265">         } catch (TransformerException ex) {</span>
<span class="nc" id="L266">            throw new CanonicalizationException(&quot;generic.EmptyMessage&quot;, ex);</span>
<span class="fc" id="L267">         } catch (SAXException ex) {</span>

            // if a not-wellformed nodeset exists, put a container around it...
<span class="fc" id="L270">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>

<span class="fc" id="L272">            baos.write(&quot;&lt;container&gt;&quot;.getBytes());</span>
<span class="fc" id="L273">            baos.write(this.getBytes());</span>
<span class="fc" id="L274">            baos.write(&quot;&lt;/container&gt;&quot;.getBytes());</span>

<span class="fc" id="L276">            byte result[] = baos.toByteArray();</span>
<span class="fc" id="L277">            Document document = db.parse(new ByteArrayInputStream(result));</span>
<span class="fc" id="L278">            XMLUtils.circumventBug2650(document);</span>

            try {
<span class="fc" id="L281">               NodeList nodeList = this._cxpathAPI.selectNodeList(</span>
                  document,
                  &quot;(//. | //@* | //namespace::*)[not(self::node()=/) and not(self::node=/container)]&quot;);

<span class="fc" id="L285">               return XMLUtils.convertNodelistToSet(nodeList);</span>
<span class="nc" id="L286">            } catch (TransformerException ex2) {</span>
<span class="nc" id="L287">               throw new CanonicalizationException(&quot;generic.EmptyMessage&quot;, ex2);</span>
            }
         }
      }

<span class="nc" id="L292">      throw new RuntimeException(</span>
         &quot;getNodeSet() called but no input data present&quot;);
   }

   /**
    * Returns the Octect stream(byte Stream) from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    *
    * @return the Octect stream(byte Stream) from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    * @throws CanonicalizationException
    * @throws IOException
    * @throws InvalidCanonicalizerException
    */
   public InputStream getOctetStream()
           throws IOException, CanonicalizationException,
                  InvalidCanonicalizerException {

<span class="fc bfc" id="L308" title="All 2 branches covered.">      if (this.isOctetStream()) {</span>
<span class="fc" id="L309">         this._inputOctetStreamProxy.reset();</span>

<span class="fc" id="L311">         return this._inputOctetStreamProxy;</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">      } else if (this.isNodeSet()) {</span>

         /* If we have a node set but an octet stream is needed, we MUST c14nize
          * without any comments.
          *
          * We don't use the factory because direct instantiation should be a
          * little bit faster...
          */
<span class="fc" id="L320">         Canonicalizer20010315OmitComments c14nizer =</span>
            new Canonicalizer20010315OmitComments();
<span class="fc" id="L322">         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>

<span class="pc bpc" id="L324" title="1 of 2 branches missed.">         if (this._inputNodeSet.size() == 0) {</span>

            // empty nodeset
<span class="nc" id="L327">            return new ByteArrayInputStream(baos.toByteArray());</span>
         }

         try {
<span class="fc" id="L331">            Set nodes = this.getNodeSet();</span>
<span class="fc" id="L332">            byte bytes[] = c14nizer.engineCanonicalizeXPathNodeSet(nodes);</span>

<span class="fc" id="L334">            baos.write(bytes);</span>

            /** @todo Clarify behavior. If isNodeSet() and we getOctetStream, do we have to this._inputOctetStream=xxx ? */

            /*
            this._inputOctetStream = new ByteArrayInputStream(baos.toByteArray());
            this._inputNodeSet = null;
            return this._inputOctetStream;
            */
<span class="fc" id="L343">            return new ByteArrayInputStream(baos.toByteArray());</span>
<span class="nc" id="L344">         } catch (SAXException ex) {</span>
<span class="nc" id="L345">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L346">         } catch (ParserConfigurationException ex) {</span>
<span class="nc" id="L347">            throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
         }
      }

<span class="nc" id="L351">      throw new RuntimeException(</span>
         &quot;getOctetStream() called but no input data present&quot;);
   }

   /**
    * Returns the byte array from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    *
    * @return the byte[] from input which was specified as the parameter of {@link XMLSignatureInput} constructor
    *
    * @throws CanonicalizationException
    * @throws IOException
    * @throws InvalidCanonicalizerException
    */
   public byte[] getBytes()
           throws IOException, CanonicalizationException,
                  InvalidCanonicalizerException {

<span class="fc" id="L368">      InputStream is = this.getOctetStream();</span>
<span class="fc" id="L369">      int available = is.available();</span>
<span class="fc" id="L370">      byte[] data = new byte[available];</span>

<span class="fc" id="L372">      is.read(data);</span>

<span class="pc bpc" id="L374" title="1 of 2 branches missed.">      if (available != data.length) {</span>
<span class="nc" id="L375">         throw new IOException(&quot;Not enough bytes read&quot;);</span>
      }

<span class="fc" id="L378">      return data;</span>
   }

   /**
    * Determines if the object has been set up with a Node set
    *
    * @return true is the object has been set up with a Node set
    */
   public boolean isNodeSet() {
<span class="pc bpc" id="L387" title="1 of 4 branches missed.">      return ((this._inputOctetStreamProxy == null)</span>
              &amp;&amp; (this._inputNodeSet != null));
   }

   /**
    * Determines if the object has been set up with an octet stream
    *
    * @return true is the object has been set up with an octet stream
    */
   public boolean isOctetStream() {
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">      return ((this._inputOctetStreamProxy != null)</span>
              &amp;&amp; (this._inputNodeSet == null));
   }

   /**
    * Is the object correctly set up?
    *
    * @return true if the object has been set up correctly
    */
   public boolean isInitialized() {
<span class="pc bpc" id="L407" title="1 of 4 branches missed.">      return (this.isOctetStream() || this.isNodeSet());</span>
   }

   /**
    * Some Transforms may require explicit MIME type, charset (IANA registered
    * &quot;character set&quot;), or other such information concerning the data they
    * are receiving from an earlier Transform or the source data, although no
    * Transform algorithm specified in this document needs such explicit
    * information. Such data characteristics are provided as parameters to the
    * Transform algorithm and should be described in the specification for the
    * algorithm.
    */
<span class="fc" id="L419">   private String _MIMEType = null;</span>

   /**
    * Returns MIMEType
    *
    * @return MIMEType
    */
   public String getMIMEType() {
<span class="nc" id="L427">      return this._MIMEType;</span>
   }

   /**
    * Sets MIMEType
    *
    * @param MIMEType
    */
   public void setMIMEType(String MIMEType) {
<span class="fc" id="L436">      this._MIMEType = MIMEType;</span>
<span class="fc" id="L437">   }</span>

   /** Field _SourceURI */
<span class="fc" id="L440">   private String _SourceURI = null;</span>

   /**
    * Return SourceURI
    *
    * @return SourceURI
    */
   public String getSourceURI() {
<span class="fc" id="L448">      return this._SourceURI;</span>
   }

   /**
    * Sets SourceURI
    *
    * @param SourceURI
    */
   public void setSourceURI(String SourceURI) {
<span class="fc" id="L457">      this._SourceURI = SourceURI;</span>
<span class="fc" id="L458">   }</span>

   /**
    * This method gives access to an {@link org.apache.xpath.CachedXPathAPI}
    * object which was used for creating the internal node set and which MUST be
    * used for subsequent operations on this node set.
    *
    * @return an existing {@link org.apache.xpath.CachedXPathAPI}
    */
   public CachedXPathAPI getCachedXPathAPI() {
<span class="fc" id="L468">      return this._cxpathAPI;</span>
   }

   /**
    * Method toString
    *
    * @return
    */
   public String toString() {

<span class="nc bnc" id="L478" title="All 2 branches missed.">      if (this.isNodeSet()) {</span>
         try {
<span class="nc" id="L480">            return &quot;XMLSignatureInput/NodeSet/&quot; + this._inputNodeSet.size()</span>
                   + &quot; nodes/&quot; + this.getSourceURI();
<span class="nc" id="L482">         } catch (Exception ex) {</span>
<span class="nc" id="L483">            return &quot;XMLSignatureInput/NodeSet//&quot; + this.getSourceURI();</span>
         }
      } else {
         try {
<span class="nc" id="L487">            return &quot;XMLSignatureInput/OctetStream/&quot; + this.getBytes().length</span>
                   + &quot; octets/&quot; + this.getSourceURI();
<span class="nc" id="L489">         } catch (Exception ex) {</span>
<span class="nc" id="L490">            return &quot;XMLSignatureInput/OctetStream//&quot; + this.getSourceURI();</span>
         }
      }
   }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>