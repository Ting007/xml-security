<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>XMLSignature.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.signature</a> &gt; <span class="el_source">XMLSignature.java</span></div><h1>XMLSignature.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.signature;



import java.io.IOException;
import java.security.Key;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.util.Vector;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;
import org.apache.xml.security.algorithms.*;
import org.apache.xml.security.algorithms.implementations.*;
import org.apache.xml.security.c14n.*;
import org.apache.xml.security.c14n.helper.XPathContainer;
import org.apache.xml.security.exceptions.*;
import org.apache.xml.security.keys.*;
import org.apache.xml.security.keys.content.*;
import org.apache.xml.security.keys.content.keyvalues.*;
import org.apache.xml.security.keys.content.x509.*;
import org.apache.xml.security.keys.keyresolver.*;
import org.apache.xml.security.keys.storage.*;
import org.apache.xml.security.transforms.Transform;
import org.apache.xml.security.transforms.Transforms;
import org.apache.xml.security.utils.*;
import org.apache.xml.security.utils.resolver.*;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.*;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;


/**
 * Handles &lt;code&gt;&amp;lt;ds:Signature&amp;gt;&lt;/code&gt; elements
 *
 * @author $Author: dohy $
 */
public class XMLSignature extends SignatureElementProxy {

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L102">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category.getInstance(XMLSignature.class.getName());
   //J-
   /** MAC - Required HMAC-SHA1 */
   public static final String ALGO_ID_MAC_HMAC_SHA1 = Constants.SignatureSpecNS + &quot;hmac-sha1&quot;;

   /** Signature - Required DSAwithSHA1 (DSS) */
   public static final String ALGO_ID_SIGNATURE_DSA = Constants.SignatureSpecNS + &quot;dsa-sha1&quot;;

   /** Signature - Recommended RSAwithSHA1 */
   public static final String ALGO_ID_SIGNATURE_RSA = Constants.SignatureSpecNS + &quot;rsa-sha1&quot;;
   public static final String ALGO_ID_SIGNATURE_RSA_SHA1 = Constants.SignatureSpecNS + &quot;rsa-sha1&quot;;

   public static final String ALGO_ID_SIGNATURE_NOT_RECOMMENDED_RSA_MD5 = Constants.MoreAlgorithmsSpecNS + &quot;rsa-md5&quot;;
   public static final String ALGO_ID_SIGNATURE_RSA_RIPEMD160 = Constants.MoreAlgorithmsSpecNS + &quot;rsa-ripemd160&quot;;
   public static final String ALGO_ID_SIGNATURE_RSA_SHA256 = Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha256&quot;;
   public static final String ALGO_ID_SIGNATURE_RSA_SHA384 = Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha384&quot;;
   public static final String ALGO_ID_SIGNATURE_RSA_SHA512 = Constants.MoreAlgorithmsSpecNS + &quot;rsa-sha512&quot;;

   public static final String ALGO_ID_MAC_HMAC_NOT_RECOMMENDED_MD5 = Constants.MoreAlgorithmsSpecNS + &quot;hmac-md5&quot;;
   public static final String ALGO_ID_MAC_HMAC_RIPEMD160 = Constants.MoreAlgorithmsSpecNS + &quot;hmac-ripemd160&quot;;
   public static final String ALGO_ID_MAC_HMAC_SHA256 = Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha256&quot;;
   public static final String ALGO_ID_MAC_HMAC_SHA384 = Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha384&quot;;
   public static final String ALGO_ID_MAC_HMAC_SHA512 = Constants.MoreAlgorithmsSpecNS + &quot;hmac-sha512&quot;;
   //J+

   /** ds:Signature.ds:SignedInfo element */
<span class="pc" id="L129">   SignedInfo _signedInfo = null;</span>

   /** ds:Signature.ds:KeyInfo */
<span class="pc" id="L132">   KeyInfo _keyInfo = null;</span>

   /** Field _followManifestsDuringValidation */
<span class="pc" id="L135">   boolean _followManifestsDuringValidation = false;</span>

   /**
    * This creates a new &lt;CODE&gt;ds:Signature&lt;/CODE&gt; Element and adds an empty
    * &lt;CODE&gt;ds:SignedInfo&lt;/CODE&gt; to it.
    *
    * @param doc
    * @param BaseURI
    * @param signatureAlgorithmURI
    * @throws XMLSecurityException
    */
   public XMLSignature(
           Document doc, String BaseURI, String signatureAlgorithmURI)
              throws XMLSecurityException {

<span class="nc" id="L150">      super(doc);</span>

<span class="nc" id="L152">      XMLUtils.addReturnToElement(this._constructionElement);</span>

<span class="nc" id="L154">      this._baseURI = BaseURI;</span>
<span class="nc" id="L155">      this._signedInfo =</span>
         new SignedInfo(this._doc, Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS,
                        signatureAlgorithmURI);

<span class="nc" id="L159">      this._constructionElement.appendChild(this._signedInfo.getElement());</span>
<span class="nc" id="L160">      XMLUtils.addReturnToElement(this._constructionElement);</span>

      // create an empty SignatureValue; this is filled by setSignatureValueElement
<span class="nc" id="L163">      Element signatureValueElement =</span>
         XMLUtils.createElementInSignatureSpace(this._doc,
                                                Constants._TAG_SIGNATUREVALUE);

<span class="nc" id="L167">      this._constructionElement.appendChild(signatureValueElement);</span>
<span class="nc" id="L168">      XMLUtils.addReturnToElement(this._constructionElement);</span>
<span class="nc" id="L169">   }</span>

   /**
    * Constructor XMLSignature
    *
    * @param element
    * @param BaseURI
    * @throws IOException
    * @throws XMLSecurityException
    * @throws XMLSignatureException
    */
   public XMLSignature(Element element, String BaseURI)
           throws XMLSignatureException, XMLSecurityException, IOException {

<span class="fc" id="L183">      super(element, BaseURI);</span>

      // check out SignedInfo child
<span class="fc" id="L186">      Element signedInfoElem = this.getChildElementLocalName(0,</span>
                                  Constants.SignatureSpecNS,
                                  Constants._TAG_SIGNEDINFO);

<span class="pc bpc" id="L190" title="1 of 2 branches missed.">      if (signedInfoElem == null) {</span>
<span class="nc" id="L191">         Object exArgs[] = { Constants._TAG_SIGNEDINFO,</span>
                             Constants._TAG_SIGNATURE };

<span class="nc" id="L194">         throw new XMLSignatureException(&quot;xml.WrongContent&quot;, exArgs);</span>
      }

<span class="fc" id="L197">      this._signedInfo = new SignedInfo(signedInfoElem, BaseURI);</span>

      // check out SignatureValue child
<span class="fc" id="L200">      Element signatureValueElement = this.getChildElementLocalName(0,</span>
                                         Constants.SignatureSpecNS,
                                         Constants._TAG_SIGNATUREVALUE);

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">      if (signatureValueElement == null) {</span>
<span class="nc" id="L205">         Object exArgs[] = { Constants._TAG_SIGNATUREVALUE,</span>
                             Constants._TAG_SIGNATURE };

<span class="nc" id="L208">         throw new XMLSignatureException(&quot;xml.WrongContent&quot;, exArgs);</span>
      }

      // &lt;element ref=&quot;ds:KeyInfo&quot; minOccurs=&quot;0&quot;/&gt;
<span class="fc" id="L212">      Element keyInfoElem = this.getChildElementLocalName(0,</span>
                               Constants.SignatureSpecNS,
                               Constants._TAG_KEYINFO);

<span class="fc bfc" id="L216" title="All 2 branches covered.">      if (keyInfoElem != null) {</span>
<span class="fc" id="L217">         this._keyInfo = new KeyInfo(keyInfoElem, BaseURI);</span>
      }
<span class="fc" id="L219">   }</span>

   /**
    * Sets the &lt;code&gt;Id&lt;/code&gt; attribute
    *
    * @param Id ID
    */
   public void setId(String Id) {

<span class="nc bnc" id="L228" title="All 4 branches missed.">      if ((this._state == MODE_SIGN) &amp;&amp; (Id != null)) {</span>
<span class="nc" id="L229">         this._constructionElement.setAttribute(Constants._ATT_ID, Id);</span>
<span class="nc" id="L230">         IdResolver.registerElementById(this._constructionElement, Id);</span>
      }
<span class="nc" id="L232">   }</span>

   /**
    * Returns the &lt;code&gt;Id&lt;/code&gt; attribute
    *
    * @return the &lt;code&gt;Id&lt;/code&gt; attribute
    */
   public String getId() {
<span class="nc" id="L240">      return this._constructionElement.getAttribute(Constants._ATT_ID);</span>
   }

   /**
    * Method getSignedInfo
    *
    * @return
    */
   public SignedInfo getSignedInfo() {
<span class="fc" id="L249">      return this._signedInfo;</span>
   }

   /**
    * Method getSignatureValue
    *
    * @return
    * @throws XMLSignatureException
    */
   public byte[] getSignatureValue() throws XMLSignatureException {

      try {
<span class="fc" id="L261">         Element signatureValueElem = this.getChildElementLocalName(0,</span>
                                         Constants.SignatureSpecNS,
                                         Constants._TAG_SIGNATUREVALUE);
<span class="fc" id="L264">         byte[] signatureValue = Base64.decode(signatureValueElem);</span>

<span class="fc" id="L266">         return signatureValue;</span>
<span class="nc" id="L267">      } catch (Base64DecodingException ex) {</span>
<span class="nc" id="L268">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
      }
   }

   /**
    * Method setSignatureValueElement
    *
    * @param bytes
    * @throws XMLSignatureException
    */
   private void setSignatureValueElement(byte[] bytes)
           throws XMLSignatureException {

<span class="nc bnc" id="L281" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L282">         Element signatureValueElem = this.getChildElementLocalName(0,</span>
                                         Constants.SignatureSpecNS,
                                         Constants._TAG_SIGNATUREVALUE);
<span class="nc" id="L285">         NodeList children = signatureValueElem.getChildNodes();</span>

<span class="nc bnc" id="L287" title="All 2 branches missed.">         while (signatureValueElem.hasChildNodes()) {</span>
<span class="nc" id="L288">            signatureValueElem.removeChild(signatureValueElem.getFirstChild());</span>
         }

<span class="nc" id="L291">         String base64codedValue = Base64.encode(bytes);</span>
<span class="nc" id="L292">         Text t = this._doc.createTextNode(base64codedValue);</span>

<span class="nc" id="L294">         signatureValueElem.appendChild(t);</span>
      }
<span class="nc" id="L296">   }</span>

   /**
    * Returns the KeyInfo child. If we are in signing mode and the KeyInfo
    * does not exist yet, we create it and add it to the Signature.
    *
    * @return the KeyInfo object
    */
   public KeyInfo getKeyInfo() {

<span class="pc bpc" id="L306" title="3 of 4 branches missed.">      if ((this._state == MODE_SIGN) &amp;&amp; (this._keyInfo == null)) {</span>
<span class="nc" id="L307">         this._keyInfo = new KeyInfo(this._doc);</span>

<span class="nc" id="L309">         Element keyInfoElement = this._keyInfo.getElement();</span>

         try {
<span class="nc" id="L312">            Element nscontext = XMLUtils.createDSctx(this._doc, &quot;ds&quot;,</span>
                                                     Constants.SignatureSpecNS);
<span class="nc" id="L314">            Element firstObject =</span>
               (Element) XPathAPI.selectSingleNode(this._constructionElement,
                                                   &quot;./ds:&quot;
                                                   + Constants._TAG_OBJECT
                                                   + &quot;[1]&quot;, nscontext);

<span class="nc bnc" id="L320" title="All 2 branches missed.">            if (firstObject != null) {</span>
<span class="nc" id="L321">               cat.debug(&quot;Found a ds:Object&quot;);</span>
<span class="nc" id="L322">               this._constructionElement.insertBefore(keyInfoElement,</span>
                                                      firstObject);
<span class="nc" id="L324">               this._constructionElement</span>
                  .insertBefore(this._doc.createTextNode(&quot;\n&quot;), firstObject);
            } else {
<span class="nc" id="L327">               cat.debug(&quot;Found no ds:Object&quot;);</span>
<span class="nc" id="L328">               this._constructionElement.appendChild(keyInfoElement);</span>
<span class="nc" id="L329">               XMLUtils.addReturnToElement(this._constructionElement);</span>
            }
<span class="nc" id="L331">         } catch (TransformerException ex) {</span>
<span class="nc" id="L332">            ex.printStackTrace();</span>
<span class="nc" id="L333">         }</span>
      }

<span class="fc" id="L336">      return this._keyInfo;</span>
   }

   /**
    * Method setKeyInfo
    *
    * @param keyInfo
    */
   private void setKeyInfo(KeyInfo keyInfo) {
<span class="nc" id="L345">      this._keyInfo = keyInfo;</span>
<span class="nc" id="L346">   }</span>

   /**
    * Method appendObject
    *
    * @param object
    * @throws XMLSignatureException
    */
   public void appendObject(ObjectContainer object)
           throws XMLSignatureException {

      try {
<span class="nc bnc" id="L358" title="All 2 branches missed.">         if (this._state != MODE_SIGN) {</span>
<span class="nc" id="L359">            throw new XMLSignatureException(</span>
               &quot;signature.operationOnlyBeforeSign&quot;);
         }

<span class="nc" id="L363">         cat.debug(&quot;Added ds:Object with Id &quot; + object.getId());</span>
<span class="nc" id="L364">         this._constructionElement.appendChild(object.getElement());</span>
<span class="nc" id="L365">         XMLUtils.addReturnToElement(this._constructionElement);</span>
<span class="nc" id="L366">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L367">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L368">      }</span>
<span class="nc" id="L369">   }</span>

   /**
    * Method objectItem
    *
    * @param i
    * @return
    */
   public ObjectContainer getObjectItem(int i) {

<span class="nc" id="L379">      Element objElem = this.getChildElementLocalName(i,</span>
                           Constants.SignatureSpecNS, Constants._TAG_OBJECT);

      try {
<span class="nc" id="L383">         return new ObjectContainer(objElem, this._baseURI);</span>
<span class="nc" id="L384">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L385">         return null;</span>
      }
   }

   /**
    * Method getObjectLength
    *
    * @return
    */
   public int getObjectLength() {
<span class="nc" id="L395">      return this.length(Constants.SignatureSpecNS, Constants._TAG_OBJECT);</span>
   }

   /**
    * Method sign
    *
    * @param privateKey
    * @throws XMLSignatureException
    */
   public void sign(PrivateKey privateKey) throws XMLSignatureException {

<span class="nc" id="L406">      cat.debug(&quot;sign() called&quot;);</span>

      try {
<span class="nc bnc" id="L409" title="All 2 branches missed.">         if (this._state == MODE_SIGN) {</span>

            // XMLUtils.indentSignature(this._constructionElement, &quot;   &quot;, 0);
<span class="nc" id="L412">            Element signatureMethodElement =</span>
               this._signedInfo.getSignatureMethodElement();
<span class="nc" id="L414">            SignatureAlgorithm sa =</span>
               new SignatureAlgorithm(signatureMethodElement,
                                      this.getBaseURI());

<span class="nc" id="L418">            sa.initSign(privateKey);</span>

<span class="nc" id="L420">            SignedInfo si = this.getSignedInfo();</span>

<span class="nc" id="L422">            si.generateDigestValues();</span>

<span class="nc" id="L424">            byte signedInfoOctets[] = si.getCanonicalizedOctetStream();</span>

<span class="nc" id="L426">            sa.update(signedInfoOctets);</span>

<span class="nc" id="L428">            byte jcebytes[] = sa.sign();</span>

<span class="nc" id="L430">            this.setSignatureValueElement(jcebytes);</span>
<span class="nc" id="L431">            cat.debug(&quot;sa.sign() finished&quot;);</span>
         }
<span class="nc" id="L433">      } catch (IOException ex) {</span>
<span class="nc" id="L434">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L435">      } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L436">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L437">      } catch (InvalidCanonicalizerException ex) {</span>
<span class="nc" id="L438">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L439">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L440">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L441">      }</span>
<span class="nc" id="L442">   }</span>

   /**
    * Method sign
    *
    * @param secretKey
    * @throws XMLSignatureException
    */
   public void sign(SecretKey secretKey) throws XMLSignatureException {

<span class="nc" id="L452">      cat.debug(&quot;sign() called&quot;);</span>

      try {
<span class="nc bnc" id="L455" title="All 2 branches missed.">         if (this._state == MODE_SIGN) {</span>

            // XMLUtils.indentSignature(this._constructionElement, &quot;   &quot;, 0);
<span class="nc" id="L458">            Element signatureMethodElement =</span>
               this._signedInfo.getSignatureMethodElement();
<span class="nc" id="L460">            SignatureAlgorithm sa =</span>
               new SignatureAlgorithm(signatureMethodElement,
                                      this.getBaseURI());

<span class="nc" id="L464">            sa.initSign(secretKey);</span>

<span class="nc" id="L466">            SignedInfo si = this.getSignedInfo();</span>

<span class="nc" id="L468">            si.generateDigestValues();</span>

<span class="nc" id="L470">            byte signedInfoOctets[] = si.getCanonicalizedOctetStream();</span>

<span class="nc" id="L472">            sa.update(signedInfoOctets);</span>

<span class="nc" id="L474">            byte jcebytes[] = sa.sign();</span>

<span class="nc" id="L476">            this.setSignatureValueElement(jcebytes);</span>
<span class="nc" id="L477">            cat.debug(&quot;sa.sign() finished&quot;);</span>
         }
<span class="nc" id="L479">      } catch (IOException ex) {</span>
<span class="nc" id="L480">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L481">      } catch (CanonicalizationException ex) {</span>
<span class="nc" id="L482">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L483">      } catch (InvalidCanonicalizerException ex) {</span>
<span class="nc" id="L484">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L485">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L486">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L487">      }</span>
<span class="nc" id="L488">   }</span>

   /**
    * Method sign
    *
    * @return
    * @throws XMLSignatureException
    */
   public boolean verify() throws XMLSignatureException {

<span class="nc bnc" id="L498" title="All 2 branches missed.">      if (this._state == MODE_VERIFY) {</span>
         try {
<span class="nc" id="L500">            Element signatureMethodElement =</span>
               this._signedInfo.getSignatureMethodElement();
<span class="nc" id="L502">            SignatureAlgorithm sa =</span>
               new SignatureAlgorithm(signatureMethodElement,
                                      this.getBaseURI());

            /** @todo do real work here */
<span class="nc" id="L507">            return false;</span>
<span class="nc" id="L508">         } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L509">            throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
         }
      }

      /** @todo fill in error message */
<span class="nc" id="L514">      throw new XMLSignatureException(&quot;empty&quot;);</span>
   }

   /**
    * Method addResourceResolver
    *
    * @param resolver
    */
   public void addResourceResolver(ResourceResolver resolver) {
<span class="nc" id="L523">      this.getSignedInfo().addResourceResolver(resolver);</span>
<span class="nc" id="L524">   }</span>

   /**
    * Method addResourceResolver
    *
    * @param resolver
    */
   public void addResourceResolver(ResourceResolverSpi resolver) {
<span class="fc" id="L532">      this.getSignedInfo().addResourceResolver(resolver);</span>
<span class="fc" id="L533">   }</span>

   /**
    * Method checkSignatureValue
    *
    * @param cert
    * @return
    * @throws XMLSignatureException
    */
   public boolean checkSignatureValue(X509Certificate cert)
           throws XMLSignatureException {

<span class="pc bpc" id="L545" title="1 of 2 branches missed.">      if (cert != null) {</span>
<span class="fc" id="L546">         return this.checkSignatureValue(cert.getPublicKey());</span>
      } else {
<span class="nc" id="L548">         Object exArgs[] = { &quot;Didn't get a certificate&quot; };</span>

<span class="nc" id="L550">         throw new XMLSignatureException(&quot;empty&quot;, exArgs);</span>
      }
   }

   /**
    * Method checkSignatureValue
    *
    * @param pk
    * @return
    * @throws XMLSignatureException
    */
   public boolean checkSignatureValue(Key pk) throws XMLSignatureException {

<span class="pc bpc" id="L563" title="1 of 2 branches missed.">      if (pk == null) {</span>
<span class="nc" id="L564">         Object exArgs[] = { &quot;Didn't get a key&quot; };</span>

<span class="nc" id="L566">         throw new XMLSignatureException(&quot;empty&quot;, exArgs);</span>
      }

      try {
<span class="pc bpc" id="L570" title="1 of 2 branches missed.">         if (!this.getSignedInfo()</span>
                 .verify(this._followManifestsDuringValidation)) {
<span class="nc" id="L572">            return false;</span>
         }

<span class="fc" id="L575">         SignatureAlgorithm sa =</span>
            new SignatureAlgorithm(this.getSignedInfo()
               .getSignatureMethodElement(), this.getBaseURI());

<span class="fc" id="L579">         cat.debug(&quot;SignatureMethodURI = &quot; + sa.getAlgorithmURI());</span>
<span class="fc" id="L580">         cat.debug(&quot;jceSigAlgorithm    = &quot; + sa.getJCEAlgorithmString());</span>
<span class="fc" id="L581">         cat.debug(&quot;jceSigProvider     = &quot; + sa.getJCEProviderName());</span>
<span class="fc" id="L582">         cat.debug(&quot;PublicKey = &quot; + pk);</span>
<span class="fc" id="L583">         sa.initVerify(pk);</span>

<span class="fc" id="L585">         byte inputBytes[] = this._signedInfo.getCanonicalizedOctetStream();</span>

<span class="fc" id="L587">         sa.update(inputBytes);</span>

<span class="fc" id="L589">         byte sigBytes[] = this.getSignatureValue();</span>

<span class="fc" id="L591">         cat.debug(&quot;SignatureValue = &quot;</span>
                   + HexDump.byteArrayToHexString(sigBytes));

<span class="fc" id="L594">         boolean verify = sa.verify(sigBytes);</span>

<span class="fc" id="L596">         return verify;</span>
<span class="nc" id="L597">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L598">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L599">      } catch (IOException ex) {</span>
<span class="nc" id="L600">         throw new XMLSignatureException(&quot;empty&quot;, ex);</span>
      }
   }

   /**
    * Method addDocument
    *
    * @param referenceURI
    * @param trans
    * @param digestURI
    * @param ReferenceId
    * @param ReferenceType
    * @throws XMLSignatureException
    */
   public void addDocument(
           String referenceURI, Transforms trans, String digestURI, String ReferenceId, String ReferenceType)
              throws XMLSignatureException {
<span class="nc" id="L617">      this._signedInfo.addDocument(this._baseURI, referenceURI, trans,</span>
                                   digestURI, ReferenceId, ReferenceType);
<span class="nc" id="L619">   }</span>

   /**
    * This method is a proxy method for the {@link Manifest#addDocument} method
    *
    * @param referenceURI
    * @param trans
    * @param digestURI
    * @see Manifest#addDocument(org.apache.xml.security.signature.XMLSignatureInput, java.lang.String, org.apache.xml.security.transforms.Transforms, java.lang.String)
    * @throws XMLSignatureException
    */
   public void addDocument(
           String referenceURI, Transforms trans, String digestURI)
              throws XMLSignatureException {
<span class="nc" id="L633">      this._signedInfo.addDocument(this._baseURI, referenceURI, trans,</span>
                                   digestURI, null, null);
<span class="nc" id="L635">   }</span>

   /**
    * Method addDocument
    *
    * @param referenceURI
    * @param trans
    * @throws XMLSignatureException
    */
   public void addDocument(String referenceURI, Transforms trans)
           throws XMLSignatureException {
<span class="nc" id="L646">      this._signedInfo.addDocument(this._baseURI, referenceURI, trans,</span>
                                   Constants.ALGO_ID_DIGEST_SHA1, null, null);
<span class="nc" id="L648">   }</span>

   /**
    * Method addDocument
    *
    * @param referenceURI
    * @throws XMLSignatureException
    */
   public void addDocument(String referenceURI) throws XMLSignatureException {

<span class="nc" id="L658">      cat.debug(&quot;The baseURI is &quot; + this._baseURI);</span>
<span class="nc" id="L659">      this._signedInfo.addDocument(this._baseURI, referenceURI, null,</span>
                                   Constants.ALGO_ID_DIGEST_SHA1, null, null);
<span class="nc" id="L661">   }</span>

   /**
    * Method addToKeyInfoCompleteCertificate
    *
    * @param cert
    * @throws XMLSecurityException
    */
   public void addKeyInfo(X509Certificate cert) throws XMLSecurityException {

<span class="nc" id="L671">      X509Data x509data = new X509Data(this._doc);</span>

<span class="nc" id="L673">      x509data.addCertificate(cert);</span>
<span class="nc" id="L674">      this.getKeyInfo().add(x509data);</span>
<span class="nc" id="L675">   }</span>

   /**
    * Method addToKeyInfo
    *
    * @param pk
    */
   public void addKeyInfo(PublicKey pk) {
<span class="nc" id="L683">      this.getKeyInfo().add(pk);</span>
<span class="nc" id="L684">   }</span>

   /**
    * Proxy method for {@link SignedInfo#createSecretKey(byte[])}
    *
    * @param secretKeyBytes
    * @return
    * @throws XMLSecurityException
    * @see SignedInfo#createSecretKey(byte[])
    */
   public SecretKey createSecretKey(byte[] secretKeyBytes)
           throws XMLSecurityException {
<span class="fc" id="L696">      return this.getSignedInfo().createSecretKey(secretKeyBytes);</span>
   }

   /**
    * Method setFollowNestedManifests
    *
    * @param followManifests
    */
   public void setFollowNestedManifests(boolean followManifests) {
<span class="fc" id="L705">      this._followManifestsDuringValidation = followManifests;</span>
<span class="fc" id="L706">   }</span>

   /**
    * Method getBaseLocalName
    *
    * @return
    */
   public String getBaseLocalName() {
<span class="fc" id="L714">      return Constants._TAG_SIGNATURE;</span>
   }

   static {
<span class="fc" id="L718">      org.apache.xml.security.Init.init();</span>
<span class="fc" id="L719">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>