<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Init.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security</a> &gt; <span class="el_source">Init.java</span></div><h1>Init.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security;



import java.io.*;
import java.lang.reflect.Method;
import java.util.*;
import javax.xml.parsers.*;
import org.apache.xpath.XPathAPI;
import org.apache.xpath.compiler.FunctionTable;
import org.apache.xpath.compiler.FuncLoader;
import org.apache.xpath.functions.Function;
import org.w3c.dom.*;
import org.apache.xml.security.algorithms.encryption.EncryptionMethod;
import org.apache.xml.security.algorithms.SignatureAlgorithm;
import org.apache.xml.security.algorithms.encryption.EncryptionMethod;
import org.apache.xml.security.algorithms.JCEMapper;
import org.apache.xml.security.c14n.Canonicalizer;
import org.apache.xml.security.c14n.helper.XPathContainer;
import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.transforms.Transform;
import org.apache.xml.security.transforms.implementations.FuncHere;
import org.apache.xml.security.utils.*;
import org.apache.xml.security.utils.resolver.ResourceResolver;
import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.keys.ContentHandlerAlreadyRegisteredException;
import org.apache.xml.security.keys.keyresolver.KeyResolver;


/**
 * This class does the configuration of the library. This includes creating
 * the mapping of Canonicalization and Transform algorithms. Initialization is
 * done by calling {@link Init#init} which should be done in any static block
 * of the files of this library. We ensure that this call is only executed once.
 *
 * @author $Author: dohy $
 */
<span class="nc" id="L96">public class Init {</span>

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L99">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category.getInstance(Init.class.getName());

   /** Field _initialized */
<span class="fc" id="L103">   private static boolean _alreadyInitialized = false;</span>

   /**
    * Method init
    *
    */
   public synchronized static void init() {

<span class="fc bfc" id="L111" title="All 2 branches covered.">      if (!_alreadyInitialized) {</span>
<span class="fc" id="L112">         _alreadyInitialized = true;</span>

<span class="fc" id="L114">         PRNG.init(new java.security.SecureRandom());</span>

         try {

            /* read library configuration file */
<span class="fc" id="L119">            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>

<span class="fc" id="L121">            dbf.setNamespaceAware(true);</span>
<span class="fc" id="L122">            dbf.setValidating(false);</span>

<span class="fc" id="L124">            DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="fc" id="L125">            InputStream is =</span>
               Class.forName(&quot;org.apache.xml.security.Init&quot;)
                  .getResourceAsStream(&quot;resource/config.xml&quot;);
<span class="fc" id="L128">            Document doc = db.parse(is);</span>
<span class="fc" id="L129">            Element context = doc.createElement(&quot;nscontext&quot;);</span>

<span class="fc" id="L131">            context.setAttribute(</span>
               &quot;xmlns:x&quot;, &quot;http://www.xmlsecurity.org/NS/#configuration&quot;);
<span class="fc" id="L133">            context.setAttribute(&quot;xmlns:log4j&quot;,</span>
                                 &quot;http://jakarta.apache.org/log4j/&quot;);

            {

               /* configure logging */
<span class="fc" id="L139">               Element log4jElem = (Element) XPathAPI.selectSingleNode(doc,</span>
                                      &quot;//log4j:configuration[1]&quot;, context);

               try {
<span class="fc" id="L143">                  Attr logfile = (Attr) XPathAPI.selectSingleNode(</span>
                     log4jElem,
                     &quot;./x:appender[@name='STDOUT']/x:param[@name='File']/@value&quot;,
                     context);
<span class="fc" id="L147">                  String logFileName = logfile.getNodeValue();</span>
<span class="fc" id="L148">                  File f = new File(logFileName);</span>

<span class="fc" id="L150">                  f.delete();</span>
<span class="pc" id="L151">               } catch (Exception ex) {}</span>

<span class="fc" id="L153">               org.apache.log4j.xml.DOMConfigurator.configure(log4jElem);</span>
<span class="fc" id="L154">               cat.info(&quot;Logging is working&quot;);</span>
            }

            {

               /* configure internationalization */
<span class="fc" id="L160">               Attr langAttr = (Attr) XPathAPI.selectSingleNode(</span>
                  doc,
                  &quot;/x:Configuration/x:ResourceBundles/@defaultLanguageCode&quot;,
                  context);
<span class="fc" id="L164">               Attr countryAttr = (Attr) XPathAPI.selectSingleNode(</span>
                  doc,
                  &quot;/x:Configuration/x:ResourceBundles/@defaultCountryCode&quot;,
                  context);
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">               String languageCode = (langAttr == null)</span>
                                     ? null
                                     : langAttr.getNodeValue();
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">               String countryCode = (countryAttr == null)</span>
                                    ? null
                                    : countryAttr.getNodeValue();

<span class="fc" id="L175">               I18n.init(languageCode, countryCode);</span>
            }

            /**
             * Try to register our here() implementation as internal function.
             */
            {
<span class="fc" id="L182">               FunctionTable.installFunction(&quot;here&quot;, new FuncHere());</span>
<span class="fc" id="L183">               cat.debug(</span>
                  &quot;Registered class &quot; + FuncHere.class.getName()
                  + &quot; for XPath function 'here()' function in internal table&quot;);

               /* The following tweak by &quot;Eric Olson&quot; &lt;ego@alum.mit.edu&gt;
                * is to enable xml-security to play with JDK 1.4 which
                * unfortunately bundles an old version of Xalan
                */
<span class="fc" id="L191">               FuncLoader funcHereLoader = new FuncHereLoader();</span>

<span class="fc bfc" id="L193" title="All 2 branches covered.">               for (int i = 0; i &lt; FunctionTable.m_functions.length; i++) {</span>
<span class="fc" id="L194">                  FuncLoader loader = FunctionTable.m_functions[i];</span>

<span class="fc bfc" id="L196" title="All 2 branches covered.">                  if (loader != null) {</span>
<span class="fc" id="L197">                     cat.debug(&quot;Func &quot; + i + &quot; &quot; + loader.getName());</span>

<span class="fc bfc" id="L199" title="All 2 branches covered.">                     if (loader.getName().equals(funcHereLoader.getName())) {</span>
<span class="fc" id="L200">                        FunctionTable.m_functions[i] = funcHereLoader;</span>
                     }
                  }
               }
            }

            {
<span class="fc" id="L207">               Canonicalizer.init();</span>

<span class="fc" id="L209">               NodeList c14nElem = XPathAPI.selectNodeList(</span>
                  doc,
                  &quot;/x:Configuration/x:CanonicalizationMethods/x:CanonicalizationMethod&quot;,
                  context);

<span class="fc bfc" id="L214" title="All 2 branches covered.">               for (int i = 0; i &lt; c14nElem.getLength(); i++) {</span>
<span class="fc" id="L215">                  String URI = ((Element) c14nElem.item(i)).getAttribute(&quot;URI&quot;);</span>
<span class="fc" id="L216">                  String JAVACLASS =</span>
                     ((Element) c14nElem.item(i)).getAttribute(&quot;JAVACLASS&quot;);
<span class="fc" id="L218">                  boolean registerClass = true;</span>

                  try {
<span class="fc" id="L221">                     Class c = Class.forName(JAVACLASS);</span>
<span class="fc" id="L222">                     Method methods[] = c.getMethods();</span>

<span class="fc bfc" id="L224" title="All 2 branches covered.">                     for (int j = 0; j &lt; methods.length; j++) {</span>
<span class="fc" id="L225">                        Method currMeth = methods[j];</span>

<span class="pc bpc" id="L227" title="1 of 2 branches missed.">                        if (currMeth.getDeclaringClass().getName()</span>
                                .equals(JAVACLASS)) {
<span class="nc" id="L229">                           cat.debug(currMeth.getDeclaringClass());</span>
                        }
                     }
<span class="fc" id="L232">                  } catch (ClassNotFoundException e) {</span>
<span class="fc" id="L233">                     Object exArgs[] = { URI, JAVACLASS };</span>

<span class="fc" id="L235">                     cat.fatal(I18n.translate(&quot;algorithm.classDoesNotExist&quot;,</span>
                                              exArgs));

<span class="fc" id="L238">                     registerClass = false;</span>
<span class="fc" id="L239">                  }</span>

<span class="fc bfc" id="L241" title="All 2 branches covered.">                  if (registerClass) {</span>
<span class="fc" id="L242">                     cat.debug(&quot;Canonicalizer.register(&quot; + URI + &quot;, &quot;</span>
                               + JAVACLASS + &quot;)&quot;);
<span class="fc" id="L244">                     Canonicalizer.register(URI, JAVACLASS);</span>
                  }
               }
            }

            {
<span class="fc" id="L250">               Transform.init();</span>

<span class="fc" id="L252">               NodeList tranElem = XPathAPI.selectNodeList(</span>
                  doc,
                  &quot;/x:Configuration/x:TransformAlgorithms/x:TransformAlgorithm&quot;,
                  context);

<span class="fc bfc" id="L257" title="All 2 branches covered.">               for (int i = 0; i &lt; tranElem.getLength(); i++) {</span>
<span class="fc" id="L258">                  String URI = ((Element) tranElem.item(i)).getAttribute(&quot;URI&quot;);</span>
<span class="fc" id="L259">                  String JAVACLASS =</span>
                     ((Element) tranElem.item(i)).getAttribute(&quot;JAVACLASS&quot;);
<span class="fc" id="L261">                  boolean registerClass = true;</span>

                  try {
<span class="fc" id="L264">                     Class c = Class.forName(JAVACLASS);</span>
<span class="fc" id="L265">                     Method methods[] = c.getMethods();</span>

<span class="fc bfc" id="L267" title="All 2 branches covered.">                     for (int j = 0; j &lt; methods.length; j++) {</span>
<span class="fc" id="L268">                        Method currMeth = methods[j];</span>

<span class="fc bfc" id="L270" title="All 2 branches covered.">                        if (currMeth.getDeclaringClass().getName()</span>
                                .equals(JAVACLASS)) {
<span class="fc" id="L272">                           cat.debug(currMeth.getDeclaringClass());</span>
                        }
                     }
<span class="nc" id="L275">                  } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L276">                     Object exArgs[] = { URI, JAVACLASS };</span>

<span class="nc" id="L278">                     cat.fatal(I18n.translate(&quot;algorithm.classDoesNotExist&quot;,</span>
                                              exArgs));

<span class="nc" id="L281">                     registerClass = false;</span>
<span class="fc" id="L282">                  }</span>

<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                  if (registerClass) {</span>
<span class="fc" id="L285">                     cat.debug(&quot;Transform.register(&quot; + URI + &quot;, &quot; + JAVACLASS</span>
                               + &quot;)&quot;);
<span class="fc" id="L287">                     Transform.register(URI, JAVACLASS);</span>
                  }
               }
            }

            {
<span class="fc" id="L293">               Element jcemapperElem = (Element) XPathAPI.selectSingleNode(</span>
                  doc, &quot;/x:Configuration/x:JCEAlgorithmMappings&quot;, context);

<span class="fc" id="L296">               JCEMapper.init(jcemapperElem);</span>
            }

            {
<span class="fc" id="L300">               SignatureAlgorithm.providerInit();</span>

<span class="fc" id="L302">               NodeList sigElems = XPathAPI.selectNodeList(</span>
                  doc,
                  &quot;/x:Configuration/x:SignatureAlgorithms/x:SignatureAlgorithm&quot;,
                  context);

<span class="fc bfc" id="L307" title="All 2 branches covered.">               for (int i = 0; i &lt; sigElems.getLength(); i++) {</span>
<span class="fc" id="L308">                  String URI = ((Element) sigElems.item(i)).getAttribute(&quot;URI&quot;);</span>
<span class="fc" id="L309">                  String JAVACLASS =</span>
                     ((Element) sigElems.item(i)).getAttribute(&quot;JAVACLASS&quot;);

                  /** @todo handle registering */
<span class="fc" id="L313">                  boolean registerClass = true;</span>

                  try {
<span class="fc" id="L316">                     Class c = Class.forName(JAVACLASS);</span>
<span class="fc" id="L317">                     Method methods[] = c.getMethods();</span>

<span class="fc bfc" id="L319" title="All 2 branches covered.">                     for (int j = 0; j &lt; methods.length; j++) {</span>
<span class="fc" id="L320">                        Method currMeth = methods[j];</span>

<span class="fc bfc" id="L322" title="All 2 branches covered.">                        if (currMeth.getDeclaringClass().getName()</span>
                                .equals(JAVACLASS)) {
<span class="fc" id="L324">                           cat.debug(currMeth.getDeclaringClass());</span>
                        }
                     }
<span class="nc" id="L327">                  } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L328">                     Object exArgs[] = { URI, JAVACLASS };</span>

<span class="nc" id="L330">                     cat.fatal(I18n.translate(&quot;algorithm.classDoesNotExist&quot;,</span>
                                              exArgs));

<span class="nc" id="L333">                     registerClass = false;</span>
<span class="fc" id="L334">                  }</span>

<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                  if (registerClass) {</span>
<span class="fc" id="L337">                     cat.debug(&quot;SignatureAlgorithm.register(&quot; + URI + &quot;, &quot;</span>
                               + JAVACLASS + &quot;)&quot;);
<span class="fc" id="L339">                     SignatureAlgorithm.register(URI, JAVACLASS);</span>
                  }
               }
            }

            /*
            {
               Element cipherAlgos = (Element) XPathAPI.selectSingleNode(doc,
                                        &quot;/x:Configuration/x:EncryptionMethods&quot;,
                                        context);

               EncryptionMethod.init(cipherAlgos);
            }
            */
            {
<span class="fc" id="L354">               ResourceResolver.init();</span>

<span class="fc" id="L356">               NodeList resolverElem = XPathAPI.selectNodeList(</span>
                  doc, &quot;/x:Configuration/x:ResourceResolvers/x:Resolver&quot;,
                  context);

<span class="fc bfc" id="L360" title="All 2 branches covered.">               for (int i = 0; i &lt; resolverElem.getLength(); i++) {</span>
<span class="fc" id="L361">                  String JAVACLASS =</span>
                     ((Element) resolverElem.item(i)).getAttribute(&quot;JAVACLASS&quot;);
<span class="fc" id="L363">                  String Description =</span>
                     ((Element) resolverElem.item(i))
                        .getAttribute(&quot;DESCRIPTION&quot;);

<span class="pc bpc" id="L367" title="2 of 4 branches missed.">                  if ((Description != null) &amp;&amp; (Description.length() &gt; 0)) {</span>
<span class="fc" id="L368">                     cat.debug(&quot;Register Resolver: &quot; + JAVACLASS + &quot;: &quot;</span>
                               + Description);
                  } else {
<span class="nc" id="L371">                     cat.debug(&quot;Register Resolver: &quot; + JAVACLASS</span>
                               + &quot;: For unknown purposes&quot;);
                  }

<span class="fc" id="L375">                  ResourceResolver.register(JAVACLASS);</span>
               }
            }

            {
               try {
<span class="fc" id="L381">                  KeyInfo.init();</span>

<span class="fc" id="L383">                  Init._contentHandlerHash = new HashMap(10);</span>

                  {
<span class="fc" id="L386">                     NodeList keyElem = XPathAPI.selectNodeList(</span>
                        doc, &quot;/x:Configuration/x:KeyInfo/x:ContentHandler&quot;,
                        context);

<span class="fc bfc" id="L390" title="All 2 branches covered.">                     for (int i = 0; i &lt; keyElem.getLength(); i++) {</span>
<span class="fc" id="L391">                        String namespace =</span>
                           ((Element) keyElem.item(i))
                              .getAttribute(&quot;NAMESPACE&quot;);
<span class="fc" id="L394">                        String localname =</span>
                           ((Element) keyElem.item(i))
                              .getAttribute(&quot;LOCALNAME&quot;);
<span class="fc" id="L397">                        String JAVACLASS =</span>
                           ((Element) keyElem.item(i))
                              .getAttribute(&quot;JAVACLASS&quot;);

<span class="fc" id="L401">                        cat.debug(&quot;KeyInfoContent: &quot; + namespace + &quot; &quot;</span>
                                  + localname + &quot; &quot; + JAVACLASS);
<span class="fc" id="L403">                        Init.registerKeyInfoContentHandler(namespace,</span>
                                                           localname,
                                                           JAVACLASS);
                     }
                  }
<span class="nc" id="L408">               } catch (Exception e) {</span>
<span class="nc" id="L409">                  e.printStackTrace();</span>

<span class="nc" id="L411">                  throw e;</span>
<span class="fc" id="L412">               }</span>
            }

            {
<span class="fc" id="L416">               KeyResolver.init();</span>

<span class="fc" id="L418">               NodeList resolverElem = XPathAPI.selectNodeList(</span>
                  doc, &quot;/x:Configuration/x:KeyResolver/x:Resolver&quot;, context);

<span class="fc bfc" id="L421" title="All 2 branches covered.">               for (int i = 0; i &lt; resolverElem.getLength(); i++) {</span>
<span class="fc" id="L422">                  String JAVACLASS =</span>
                     ((Element) resolverElem.item(i)).getAttribute(&quot;JAVACLASS&quot;);
<span class="fc" id="L424">                  String Description =</span>
                     ((Element) resolverElem.item(i))
                        .getAttribute(&quot;DESCRIPTION&quot;);

<span class="pc bpc" id="L428" title="2 of 4 branches missed.">                  if ((Description != null) &amp;&amp; (Description.length() &gt; 0)) {</span>
<span class="fc" id="L429">                     cat.debug(&quot;Register Resolver: &quot; + JAVACLASS + &quot;: &quot;</span>
                               + Description);
                  } else {
<span class="nc" id="L432">                     cat.debug(&quot;Register Resolver: &quot; + JAVACLASS</span>
                               + &quot;: For unknown purposes&quot;);
                  }

<span class="fc" id="L436">                  KeyResolver.register(JAVACLASS);</span>
               }
            }

            {
<span class="fc" id="L441">               cat.debug(&quot;Now I try to bind prefixes:&quot;);</span>

<span class="fc" id="L443">               NodeList nl = XPathAPI.selectNodeList(</span>
                  doc, &quot;/x:Configuration/x:PrefixMappings/x:PrefixMapping&quot;,
                  context);

<span class="fc bfc" id="L447" title="All 2 branches covered.">               for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="fc" id="L448">                  String namespace =</span>
                     ((Element) nl.item(i)).getAttribute(&quot;namespace&quot;);
<span class="fc" id="L450">                  String prefix = ((Element) nl.item(i)).getAttribute(&quot;prefix&quot;);</span>

<span class="fc" id="L452">                  cat.debug(&quot;Now I try to bind &quot; + prefix + &quot; to &quot; + namespace);</span>
<span class="fc" id="L453">                  org.apache.xml.security.utils.ElementProxy</span>
                     .setDefaultPrefix(namespace, prefix);
               }
            }

            //J-
<span class="fc" id="L459">         EncryptionMethod.providerInit();</span>
<span class="fc" id="L460">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_KEYWRAP_TRIPLEDES,     &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.KeyWrapImpl_TRIPLEDES_BC&quot;);</span>
<span class="fc" id="L461">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_KEYWRAP_AES128,        &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.KeyWrapImpl_AES128_BC&quot;);</span>
<span class="fc" id="L462">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_KEYWRAP_AES192,        &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.KeyWrapImpl_AES192_BC&quot;);</span>
<span class="fc" id="L463">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_KEYWRAP_AES256,        &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.KeyWrapImpl_AES256_BC&quot;);</span>
<span class="fc" id="L464">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_BLOCKCIPHER_TRIPLEDES, &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.BlockEncryptionImpl_TRIPLEDES_BC&quot;);</span>
<span class="fc" id="L465">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES128,    &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.BlockEncryptionImpl_AES128_BC&quot;);</span>
<span class="fc" id="L466">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES192,    &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.BlockEncryptionImpl_AES192_BC&quot;);</span>
<span class="fc" id="L467">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES256,    &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.BlockEncryptionImpl_AES256_BC&quot;);</span>
<span class="fc" id="L468">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_KEYTRANSPORT_RSAOAEP,  &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.KeyTransportImpl_RSAOAEP_BC&quot;);</span>
<span class="fc" id="L469">         EncryptionMethod.register(EncryptionConstants.ALGO_ID_KEYTRANSPORT_RSA15,    &quot;org.apache.xml.security.algorithms.encryption.implementations.BC.KeyTransportImpl_RSAPKCS15_BC&quot;);</span>
         //J+
<span class="nc" id="L471">         } catch (Exception e) {</span>
<span class="nc" id="L472">            cat.fatal(&quot;Bad: &quot;, e);</span>
<span class="nc" id="L473">            e.printStackTrace();</span>
<span class="fc" id="L474">         }</span>
      }
<span class="fc" id="L476">   }</span>

   /**
    * This method customizes the library with user supplied configuration.
    * This includes access to keystores etc.
    * By default, this method tries to find the configurationfile in
    * the System.getProperty(&quot;user.home&quot;) directory.
    *
    * @throws XMLSecurityException
    */
   public static void readUserConfiguration() throws XMLSecurityException {

      try {
<span class="nc" id="L489">         String filename = System.getProperty(&quot;user.home&quot;) + &quot;/&quot;</span>
                           + Constants.configurationFileNew;
<span class="nc" id="L491">         InputStream is = new FileInputStream(filename);</span>

<span class="nc" id="L493">         Init.readUserConfiguration(is);</span>
<span class="nc" id="L494">      } catch (IOException ex) {</span>
<span class="nc" id="L495">         throw new XMLSecurityException(&quot;generic.EmptyMessage&quot;, ex);</span>
<span class="nc" id="L496">      }</span>
<span class="nc" id="L497">   }</span>

   /**
    * This method customizes the library with user supplied configuration.
    * This includes access to keystores etc.
    *
    * @param fileURI
    * @throws XMLSecurityException
    */
   public static void readUserConfiguration(String fileURI)
           throws XMLSecurityException {

      try {
<span class="nc" id="L510">         InputStream is = null;</span>

         // first try to interpret fileURI as filename in the local file system
<span class="nc" id="L513">         File f = new File(fileURI);</span>

<span class="nc bnc" id="L515" title="All 2 branches missed.">         if (f.exists()) {</span>
<span class="nc" id="L516">            is = new FileInputStream(f);</span>
         } else {

            // then treat it as USI
<span class="nc" id="L520">            is = new java.net.URL(fileURI).openStream();</span>
         }

<span class="nc" id="L523">         Init.readUserConfiguration(is);</span>
<span class="nc" id="L524">      } catch (IOException ex) {</span>
<span class="nc" id="L525">         throw new XMLSecurityException(&quot;generic.EmptyMessage&quot;, ex);</span>
<span class="nc" id="L526">      }</span>
<span class="nc" id="L527">   }</span>

   /**
    * Method readUserConfiguration
    *
    * @param is
    * @throws XMLSecurityException
    */
   public static void readUserConfiguration(InputStream is)
           throws XMLSecurityException {

      try {

         /* read library configuration file */
<span class="nc" id="L541">         DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();</span>

<span class="nc" id="L543">         dbf.setNamespaceAware(true);</span>
<span class="nc" id="L544">         dbf.setValidating(false);</span>

<span class="nc" id="L546">         DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L547">         Document doc = db.parse(is);</span>
<span class="nc" id="L548">         Element context = XMLUtils.createDSctx(</span>
            doc, &quot;x&quot;, &quot;http://www.xmlsecurity.org/NS/#configuration&quot;);

         {
<span class="nc" id="L552">            NodeList nl =</span>
               XPathAPI.selectNodeList(doc, &quot;/x:AppConfiguration/x:KeyStore&quot;,
                                       context);

<span class="nc bnc" id="L556" title="All 2 branches missed.">            for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="nc" id="L557">               Element e = (Element) nl.item(i);</span>
<span class="nc" id="L558">               String URI = e.getAttribute(&quot;URI&quot;);</span>
<span class="nc" id="L559">               String keyStoreType = e.getAttribute(&quot;Type&quot;);</span>
<span class="nc" id="L560">               String defaultKeyAlias = e.getAttribute(&quot;DefaultKeyAlias&quot;);</span>
<span class="nc" id="L561">               String storePass = e.getAttribute(&quot;StorePass&quot;);</span>
<span class="nc" id="L562">               String KeyPass = e.getAttribute(&quot;KeyPass&quot;);</span>

               // org.apache.xml.security.keys.keyStorage.KeyStorage.registerStore(URI, JAVACLASS, LOCATION, DEFAULTKEYOBJECT, CONTEXT);
            }
         }
<span class="nc" id="L567">      } catch (Exception ex) {</span>
<span class="nc" id="L568">         throw new XMLSecurityException(&quot;generic.EmptyMessage&quot;, ex);</span>
<span class="nc" id="L569">      }</span>
<span class="nc" id="L570">   }</span>

   /** Field _contentHandlerHash */
   public static HashMap _contentHandlerHash;

   /**
    * Method registerKeyinfoContentHandler
    *
    * @param namespace
    * @param localname
    * @param implementingClass
    * @throws ContentHandlerAlreadyRegisteredException
    */
   public static void registerKeyInfoContentHandler(
           String namespace, String localname, String implementingClass)
              throws ContentHandlerAlreadyRegisteredException {

<span class="fc" id="L587">      String namespacequali = Init.qualifyNamespace(namespace, localname);</span>

      // are we already registered?
<span class="pc bpc" id="L590" title="1 of 2 branches missed.">      if (Init._contentHandlerHash.containsKey(namespacequali)) {</span>
<span class="nc" id="L591">         cat.error(&quot;Already registered&quot;);</span>

<span class="nc" id="L593">         Object exArgs[] = { namespacequali,</span>
                             ((String) Init._contentHandlerHash
                                .get(namespacequali)) };

<span class="nc" id="L597">         throw new ContentHandlerAlreadyRegisteredException(</span>
            &quot;algorithm.alreadyRegistered&quot;, exArgs);
      }

<span class="fc" id="L601">      synchronized (Init._contentHandlerHash) {</span>
<span class="fc" id="L602">         Init._contentHandlerHash.put(namespacequali, implementingClass);</span>
<span class="fc" id="L603">         cat.debug(&quot;Init._contentHandlerHash.put(\&quot;&quot; + namespacequali</span>
                   + &quot;\&quot;, \&quot;&quot; + implementingClass + &quot;\&quot;)&quot;);
<span class="fc" id="L605">         cat.debug(&quot;Init._contentHandlerHash.size()=&quot;</span>
                   + Init._contentHandlerHash.size());
<span class="pc" id="L607">      }</span>
<span class="fc" id="L608">   }</span>

   /**
    * Method qualifyNamespace
    *
    * @param namespace
    * @param localname
    * @return
    */
   private static String qualifyNamespace(String namespace, String localname) {
<span class="fc" id="L618">      return &quot;{&quot; + namespace + &quot;}&quot; + localname;</span>
   }

   /**
    * Method getContentHandlerClass
    *
    * @param namespace
    * @param localname
    * @return
    */
   public static String getKeyInfoContentHandler(String namespace,
           String localname) {

      /*
      Iterator i = KeyInfo._contentHandlerHash.keySet().iterator();
      while (i.hasNext()) {
         String key = (String) i.next();
         if (key.equals(URI)) {
            return (String) KeyInfo._contentHandlerHash.get(key);
         }
      }
      return null;
      */
<span class="nc" id="L641">      String namespacequali = Init.qualifyNamespace(namespace, localname);</span>

<span class="nc" id="L643">      cat.debug(&quot;Asked for handler for &quot; + namespacequali);</span>

<span class="nc bnc" id="L645" title="All 2 branches missed.">      if (Init._contentHandlerHash == null) {</span>
<span class="nc" id="L646">         cat.debug(&quot;But I can't help (hash==null) &quot;);</span>

<span class="nc" id="L648">         return null;</span>
      }

<span class="nc bnc" id="L651" title="All 2 branches missed.">      if (Init._contentHandlerHash.size() == 0) {</span>
<span class="nc" id="L652">         cat.debug(&quot;But I can't help (size()==0)&quot;);</span>

<span class="nc" id="L654">         return null;</span>
      }

<span class="nc" id="L657">      Set keyset = Init._contentHandlerHash.keySet();</span>
<span class="nc" id="L658">      Iterator i = keyset.iterator();</span>

<span class="nc bnc" id="L660" title="All 2 branches missed.">      while (i.hasNext()) {</span>
<span class="nc" id="L661">         String key = (String) i.next();</span>

<span class="nc bnc" id="L663" title="All 2 branches missed.">         if (key.equals(namespacequali)) {</span>
<span class="nc" id="L664">            return (String) Init._contentHandlerHash.get(key);</span>
         }
<span class="nc" id="L666">      }</span>

<span class="nc" id="L668">      return null;</span>
   }

   /**
    * Class FuncHereLoader
    *
    * @author $Author: dohy $
    * @version $Revision: 1.1.1.1 $
    */
<span class="nc" id="L677">   public static class FuncHereLoader extends FuncLoader {</span>

      /**
       * Constructor FuncHereLoader
       *
       */
      public FuncHereLoader() {
<span class="fc" id="L684">         super(FuncHere.class.getName(), 0);</span>
<span class="fc" id="L685">      }</span>

      /**
       * Method getFunction
       *
       * @return
       * @throws javax.xml.transform.TransformerException
       */
      public Function getFunction()
              throws javax.xml.transform.TransformerException {
<span class="fc" id="L695">         return new FuncHere();</span>
      }

      /**
       * Method getName
       *
       * @return
       */
      public String getName() {
<span class="fc" id="L704">         return FuncHere.class.getName();</span>
      }
   }

   static {
<span class="fc" id="L709">      Init.init();</span>
<span class="fc" id="L710">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>