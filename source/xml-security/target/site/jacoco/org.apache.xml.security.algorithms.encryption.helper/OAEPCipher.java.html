<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OAEPCipher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.algorithms.encryption.helper</a> &gt; <span class="el_source">OAEPCipher.java</span></div><h1>OAEPCipher.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.algorithms.encryption.helper;



import java.security.*;
import java.security.spec.*;
import java.security.interfaces.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.crypto.interfaces.*;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.apache.xml.security.utils.Base64;
import org.apache.xml.security.utils.HexDump;
import java.math.BigInteger;


/**
 *
 * @author $Author: dohy $
 * @see org.bouncycastle.crypto.encodings.OAEPEncoding
 */
public class OAEPCipher {

   /** Field _cipher */
   Cipher _cipher;

   /** Field _cipherMode */
   int _cipherMode;

   /** Field _digest */
   MessageDigest _digest;

   /** Field _hLen */
   int _hLen;

   /** Field _encodingParams[] */
   byte _encodingParams[];

   /** Field _encodingParamsHash[] */
   byte _encodingParamsHash[];

   /** Field _encodingParams[] */
   SecureRandom _secureRandom;

   /**
    * Constructor OAEPCipher
    *
    * @param cipher
    * @param digest
    * @param encodingParams
    */
   public OAEPCipher(Cipher cipher, MessageDigest digest,
<span class="nc" id="L111">                     byte encodingParams[]) {</span>

<span class="nc" id="L113">      this._cipher = cipher;</span>
<span class="nc" id="L114">      this._digest = digest;</span>
<span class="nc" id="L115">      this._hLen = this._digest.getDigestLength();</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">      if (encodingParams != null) {</span>
<span class="nc" id="L118">         this._encodingParams = encodingParams;</span>
      } else {
<span class="nc" id="L120">         this._encodingParams = new byte[0];</span>
      }

<span class="nc" id="L123">      this._digest.reset();</span>
<span class="nc" id="L124">      this._digest.update(this._encodingParams);</span>

<span class="nc" id="L126">      this._encodingParamsHash = this._digest.digest();</span>

<span class="nc" id="L128">      this._digest.reset();</span>
<span class="nc" id="L129">   }</span>

   /**
    * Method init
    *
    * @param mode
    * @param key
    * @param secureRandom
    * @throws InvalidKeyException
    */
   public void init(int mode, Key key, SecureRandom secureRandom)
           throws InvalidKeyException {

<span class="nc" id="L142">      this._cipherMode = mode;</span>
<span class="nc" id="L143">      this._secureRandom = secureRandom;</span>

<span class="nc" id="L145">      this._cipher.init(this._cipherMode, key, this._secureRandom);</span>
<span class="nc" id="L146">   }</span>

   /**
    * Method getInputBlockSize
    *
    * @return
    */
   public int getInputBlockSize() {

<span class="nc" id="L155">      int baseBlockSize = this._cipher.getBlockSize();</span>
<span class="nc" id="L156">      int hLen = this._digest.getDigestLength();</span>

<span class="nc bnc" id="L158" title="All 2 branches missed.">      if (this._cipherMode == Cipher.ENCRYPT_MODE) {</span>
<span class="nc" id="L159">         return baseBlockSize - 1 - 2 * hLen;</span>
      } else {
<span class="nc" id="L161">         return baseBlockSize;</span>
      }
   }

   /**
    * Method getOutputBlockSize
    *
    * @return
    */
   public int getOutputBlockSize() {

<span class="nc" id="L172">      int baseBlockSize = this._cipher.getBlockSize();</span>
<span class="nc" id="L173">      int hLen = this._digest.getDigestLength();</span>

<span class="nc bnc" id="L175" title="All 2 branches missed.">      if (this._cipherMode == Cipher.ENCRYPT_MODE) {</span>
<span class="nc" id="L176">         return baseBlockSize;</span>
      } else {
<span class="nc" id="L178">         return baseBlockSize - 1 - 2 * hLen;</span>
      }
   }

   /**
    * Method processBlock
    *
    * @param in
    * @param inOff
    * @param inLen
    * @return
    * @throws BadPaddingException
    * @throws IllegalBlockSizeException
    * @throws InvalidCipherTextException
    */
   public byte[] processBlock(byte[] in, int inOff, int inLen)
           throws InvalidCipherTextException, IllegalBlockSizeException,
                  BadPaddingException {

<span class="nc bnc" id="L197" title="All 2 branches missed.">      if (this._cipherMode == Cipher.ENCRYPT_MODE) {</span>
<span class="nc" id="L198">         return this.encodeBlock(in, inOff, inLen);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">      } else if (this._cipherMode == Cipher.DECRYPT_MODE) {</span>
<span class="nc" id="L200">         return this.decodeBlock(in, inOff, inLen);</span>
      } else {
<span class="nc" id="L202">         return null;</span>
      }
   }

   /**
    * Method encodeBlock
    *
    * @param in
    * @param inOff
    * @param inLen
    * @return
    * @throws BadPaddingException
    * @throws IllegalBlockSizeException
    * @throws InvalidCipherTextException
    */
   public byte[] encodeBlock(byte[] in, int inOff, int inLen)
           throws InvalidCipherTextException, IllegalBlockSizeException,
                  BadPaddingException {

<span class="nc" id="L221">      byte[] block = new byte[getInputBlockSize() + 1 + 2 * this._hLen];</span>

      //
      // copy in the message
      //
<span class="nc" id="L226">      System.arraycopy(in, inOff, block, block.length - inLen, inLen);</span>

      //
      // add sentinel
      //
<span class="nc" id="L231">      block[block.length - inLen - 1] = 0x01;</span>

      //
      // as the block is already zeroed - there's no need to add PS (the &gt;= 0 pad of 0)
      // add the hash of the encoding params.
      //
<span class="nc" id="L237">      System.arraycopy(this._encodingParamsHash, 0, block, this._hLen,</span>
                       this._hLen);

      //
      // generate the seed.
      //
<span class="nc" id="L243">      byte[] seed = new byte[this._hLen];</span>

<span class="nc" id="L245">      this._secureRandom.nextBytes(seed);</span>

      //
      // mask the message block.
      //
<span class="nc" id="L250">      byte[] mask = maskGeneratorFunction1(seed, 0, seed.length,</span>
                                           block.length - this._hLen,
                                           this._digest);

<span class="nc bnc" id="L254" title="All 2 branches missed.">      for (int i = this._hLen; i != block.length; i++) {</span>
<span class="nc" id="L255">         block[i] ^= mask[i - this._hLen];</span>
      }

      //
      // add in the seed
      //
<span class="nc" id="L261">      System.arraycopy(seed, 0, block, 0, this._hLen);</span>

      //
      // mask the seed.
      //
<span class="nc" id="L266">      mask = maskGeneratorFunction1(block, this._hLen,</span>
                                    block.length - this._hLen, this._hLen,
                                    this._digest);

<span class="nc bnc" id="L270" title="All 2 branches missed.">      for (int i = 0; i != this._hLen; i++) {</span>
<span class="nc" id="L271">         block[i] ^= mask[i];</span>
      }

<span class="nc" id="L274">      return this._cipher.doFinal(block, 0, block.length);</span>
   }

   /**
    * @param in
    * @param inOff
    * @param inLen
    * @return
    * @throws BadPaddingException
    * @throws IllegalBlockSizeException
    * @exception InvalidCipherTextException if the decryypted block turns out to
    * be badly formatted.
    */
   public byte[] decodeBlock(byte[] in, int inOff, int inLen)
           throws InvalidCipherTextException, IllegalBlockSizeException,
                  BadPaddingException {

<span class="nc" id="L291">      byte[] data = this._cipher.doFinal(in, inOff, inLen);</span>
<span class="nc" id="L292">      byte[] block = null;</span>

      //
      // as we may have zeros in our leading bytes for the block we produced
      // on encryption, we need to make sure our decrypted block comes back
      // the same size.
      //
<span class="nc bnc" id="L299" title="All 2 branches missed.">      if (data.length</span>
              &lt; this.getOutputBlockSize()) {    // this._cipher.getBlockSize()
<span class="nc" id="L301">         block =</span>
            new byte[this.getOutputBlockSize()];    // this._cipher.getBlockSize()

<span class="nc" id="L304">         System.arraycopy(data, 0, block, block.length - data.length,</span>
                          data.length);
      } else {
<span class="nc" id="L307">         block = data;</span>
      }

<span class="nc bnc" id="L310" title="All 2 branches missed.">      if (block.length &lt; (2 * this._hLen) + 1) {</span>
<span class="nc" id="L311">         throw new InvalidCipherTextException(</span>
            &quot;encryption.RSAOAEP.dataTooShort&quot;);
      }

      //
      // unmask the seed.
      //
<span class="nc" id="L318">      byte[] mask = maskGeneratorFunction1(block, this._hLen,</span>
                                           block.length - this._hLen,
                                           this._hLen, this._digest);

<span class="nc bnc" id="L322" title="All 2 branches missed.">      for (int i = 0; i != this._hLen; i++) {</span>
<span class="nc" id="L323">         block[i] ^= mask[i];</span>
      }

      //
      // unmask the message block.
      //
<span class="nc" id="L329">      mask = maskGeneratorFunction1(block, 0, this._hLen,</span>
                                    block.length - this._hLen, this._digest);

<span class="nc bnc" id="L332" title="All 2 branches missed.">      for (int i = this._hLen; i != block.length; i++) {</span>
<span class="nc" id="L333">         block[i] ^= mask[i - this._hLen];</span>
      }

      //
      // check the hash of the encoding params.
      //
<span class="nc bnc" id="L339" title="All 2 branches missed.">      for (int i = 0; i != this._encodingParamsHash.length; i++) {</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">         if (this._encodingParamsHash[i]</span>
                 != block[this._encodingParamsHash.length + i]) {
<span class="nc" id="L342">            throw new InvalidCipherTextException(</span>
               &quot;encryption.RSAOAEP.dataHashWrong&quot;);
         }
      }

      //
      // find the data block
      //
      int start;

<span class="nc bnc" id="L352" title="All 2 branches missed.">      for (start = 2 * this._hLen; start != block.length; start++) {</span>
<span class="nc bnc" id="L353" title="All 4 branches missed.">         if ((block[start] == 1) || (block[start] != 0)) {</span>
<span class="nc" id="L354">            break;</span>
         }
      }

<span class="nc bnc" id="L358" title="All 4 branches missed.">      if ((start &gt;= (block.length - 1)) || (block[start] != 1)) {</span>
<span class="nc" id="L359">         Object exArgs[] = { new Integer(start) };</span>

<span class="nc" id="L361">         throw new InvalidCipherTextException(</span>
            &quot;encryption.RSAOAEP.dataStartWrong&quot;, exArgs);
      }

<span class="nc" id="L365">      start++;</span>

      //
      // extract the data block
      //
<span class="nc" id="L370">      byte[] output = new byte[block.length - start];</span>

<span class="nc" id="L372">      System.arraycopy(block, start, output, 0, output.length);</span>

<span class="nc" id="L374">      return output;</span>
   }

   /**
    * int to octet string.
    *
    * @param i
    * @param sp
    */
   static void ItoOSP(int i, byte[] sp) {

<span class="nc" id="L385">      sp[0] = (byte) (i &gt;&gt;&gt; 24);</span>
<span class="nc" id="L386">      sp[1] = (byte) (i &gt;&gt;&gt; 16);</span>
<span class="nc" id="L387">      sp[2] = (byte) (i &gt;&gt;&gt; 8);</span>
<span class="nc" id="L388">      sp[3] = (byte) (i &gt;&gt;&gt; 0);</span>
<span class="nc" id="L389">   }</span>

   /**
    * mask generator function, as described in PKCS1v2.
    *
    * @param Z
    * @param zOff
    * @param zLen
    * @param length
    * @param Hash
    * @return
    * @throws IllegalArgumentException
    */
   static byte[] maskGeneratorFunction1(
           byte[] Z, int zOff, int zLen, int length, MessageDigest Hash)
              throws IllegalArgumentException {

<span class="nc" id="L406">      int hLen = Hash.getDigestLength();</span>
<span class="nc" id="L407">      byte[] mask = new byte[length];</span>
<span class="nc" id="L408">      byte[] C = new byte[4];</span>
<span class="nc" id="L409">      int counter = 0;</span>

<span class="nc" id="L411">      Hash.reset();</span>

      do {
<span class="nc" id="L414">         ItoOSP(counter, C);</span>
<span class="nc" id="L415">         Hash.update(Z, zOff, zLen);</span>
<span class="nc" id="L416">         Hash.update(C, 0, C.length);</span>

<span class="nc" id="L418">         byte hashBuf[] = Hash.digest();</span>

<span class="nc" id="L420">         System.arraycopy(hashBuf, 0, mask, counter * hLen, hLen);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">      } while (++counter &lt; (length / hLen));</span>

<span class="nc bnc" id="L423" title="All 2 branches missed.">      if ((counter * hLen) &lt; length) {</span>
<span class="nc" id="L424">         ItoOSP(counter, C);</span>
<span class="nc" id="L425">         Hash.update(Z, zOff, zLen);</span>
<span class="nc" id="L426">         Hash.update(C, 0, C.length);</span>

<span class="nc" id="L428">         byte hashBuf[] = Hash.digest();</span>

<span class="nc" id="L430">         System.arraycopy(hashBuf, 0, mask, counter * hLen,</span>
                          mask.length - (counter * hLen));
      }

<span class="nc" id="L434">      return mask;</span>
   }

   /**
    * Method main
    *
    * @param args
    * @throws Exception
    */
   public static void main(String[] args) throws Exception {

<span class="nc" id="L445">      Security.addProvider(new BouncyCastleProvider());</span>

<span class="nc" id="L447">      Cipher rsaCipher = Cipher.getInstance(&quot;RSA&quot;, &quot;BC&quot;);</span>
<span class="nc" id="L448">      MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;, &quot;BC&quot;);</span>
<span class="nc" id="L449">      byte encodingParams[] = Base64.decode(&quot;9lWu3Q==&quot;);</span>
<span class="nc" id="L450">      OAEPCipher OAEPCipher1 = new OAEPCipher(rsaCipher, sha1, null);</span>
      //J-
<span class="nc" id="L452">      BigInteger modulus = new BigInteger(</span>
           &quot;bbf82f090682ce9c2338ac2b9da871f7368d07eed41043a4&quot; +
           &quot;40d6b6f07454f51fb8dfbaaf035c02ab61ea48ceeb6fcd48&quot; +
           &quot;76ed520d60e1ec4619719d8a5b8b807fafb8e0a3dfc73772&quot; +
           &quot;3ee6b4b7d93a2584ee6a649d060953748834b2454598394e&quot; +
           &quot;e0aab12d7b61a51f527a9a41f6c1687fe2537298ca2a8f59&quot; +
           &quot;46f8e5fd091dbdcb&quot;, 16);
<span class="nc" id="L459">      BigInteger privateExponent = new BigInteger(</span>
           &quot;a5dafc5341faf289c4b988db30c1cdf83f31251e0668b427&quot; +
           &quot;84813801579641b29410b3c7998d6bc465745e5c392669d6&quot; +
            &quot;870da2c082a939e37fdcb82ec93edac97ff3ad5950accfbc&quot; +
           &quot;111c76f1a9529444e56aaf68c56c092cd38dc3bef5d20a93&quot; +
           &quot;9926ed4f74a13eddfbe1a1cecc4894af9428c2b7b8883fe4&quot; +
           &quot;463a4bc85b1cb3c1&quot;, 16);
<span class="nc" id="L466">      String cipherText =</span>
         &quot;12 53 e0 4d c0 a5 39 7b b4 4a 7a b8 7e 9b f2 a0 39 a3 3d 1e 99 6f c8 2a &quot; +
         &quot;94 cc d3 00 74 c9 5d f7 63 72 20 17 06 9e 52 68 da 5d 1c 0b 4f 87 2c f6 &quot; +
         &quot;53 c1 1d f8 23 14 a6 79 68 df ea e2 8d ef 04 bb 6d 84 b1 c3 1d 65 4a 19 &quot; +
         &quot;70 e5 78 3b d6 eb 96 a0 24 c2 ca 2f 4a 90 fe 9f 2e f5 c9 c1 40 e5 bb 48 &quot; +
         &quot;da 95 36 ad 87 00 c8 4f c9 13 0a de a7 4e 55 8d 51 a7 4d df 85 d8 b5 0d &quot; +
         &quot;e9 68 38 d6 06 3e 09 55 &quot;;
      //J+
<span class="nc" id="L474">      KeyFactory kf = KeyFactory.getInstance(&quot;RSA&quot;, &quot;BC&quot;);</span>
<span class="nc" id="L475">      KeySpec rsaKeySpec = new RSAPrivateKeySpec(modulus, privateExponent);</span>
<span class="nc" id="L476">      PrivateKey pK = kf.generatePrivate(rsaKeySpec);</span>

<span class="nc" id="L478">      OAEPCipher1.init(Cipher.DECRYPT_MODE, pK, new SecureRandom());</span>

<span class="nc" id="L480">      byte oaepBytes[] = HexDump.hexStringToByteArray(cipherText);</span>
<span class="nc" id="L481">      byte oaepPlainBytes[] = OAEPCipher1.processBlock(oaepBytes, 0,</span>
                                 oaepBytes.length);

<span class="nc" id="L484">      System.out.println(HexDump.byteArrayToHexString(oaepPlainBytes));</span>
<span class="nc" id="L485">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>