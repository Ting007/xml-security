<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyStoreElement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.keys.provider</a> &gt; <span class="el_source">KeyStoreElement.java</span></div><h1>KeyStoreElement.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.keys.provider;



import java.util.Date;
import java.io.*;
import java.security.KeyStoreException;
import java.security.cert.*;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableKeyException;
import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.utils.*;
import org.apache.xml.security.signature.Reference;
import org.apache.xml.security.signature.XMLSignature;
import org.apache.xml.security.signature.XMLSignatureException;
import org.apache.xml.security.transforms.*;
import org.w3c.dom.*;
import javax.crypto.SecretKey;
import javax.xml.transform.TransformerException;
import org.apache.xpath.CachedXPathAPI;
import java.util.Enumeration;
import java.util.Vector;


/**
 *
 * @author $Author: dohy $
 */
public class KeyStoreElement extends ElementProxy {

   /**
    * Constructor KeyStoreElement
    *
    * @param doc
    */
   public KeyStoreElement(Document doc) {

<span class="nc" id="L97">      super(doc);</span>

<span class="nc" id="L99">      XMLUtils.addReturnToElement(this);</span>
<span class="nc" id="L100">   }</span>

   /**
    * Constructor KeyStoreElement
    *
    * @param element
    * @param BaseURI
    * @throws XMLSecurityException
    */
   public KeyStoreElement(Element element, String BaseURI)
           throws XMLSecurityException {
<span class="nc" id="L111">      super(element, BaseURI);</span>
<span class="nc" id="L112">   }</span>

   /**
    * Method getBaseLocalName
    *
    * @return
    */
   public String getBaseLocalName() {
<span class="nc" id="L120">      return ApacheKeyStoreConstants._TAG_KEYSTORE;</span>
   }

   /**
    * Method getBaseNamespace
    *
    * @return
    */
   public String getBaseNamespace() {
<span class="nc" id="L129">      return ApacheKeyStoreConstants.ApacheKeyStore_NAMESPACE;</span>
   }

   /**
    * This method removes all &lt;CODE&gt;ds:Signature&lt;/CODE&gt; children from the
    * KeyStore.
    *
    */
   protected void removeOldSignatures() {

<span class="nc" id="L139">      Element oldSignatureElement = null;</span>

      while ((oldSignatureElement =
              this.getChildElementLocalName(0, Constants
<span class="nc bnc" id="L143" title="All 2 branches missed.">                 .SignatureSpecNS, Constants._TAG_SIGNATURE)) != null) {</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">         if (oldSignatureElement != null) {</span>
<span class="nc" id="L145">            Node parent = oldSignatureElement.getParentNode();</span>

            {

               // just beautifying; remove a possibly following return text node
<span class="nc" id="L150">               Node nextSibl = oldSignatureElement.getNextSibling();</span>

<span class="nc bnc" id="L152" title="All 4 branches missed.">               if ((nextSibl != null)</span>
                       &amp;&amp; (nextSibl.getNodeType() == Node.TEXT_NODE)) {
<span class="nc bnc" id="L154" title="All 2 branches missed.">                  if (((Text) nextSibl).getData().equals(&quot;\n&quot;)) {</span>
<span class="nc" id="L155">                     parent.removeChild(nextSibl);</span>
                  }
               }
            }

<span class="nc" id="L160">            parent.removeChild(oldSignatureElement);</span>
<span class="nc" id="L161">         }</span>
      }
<span class="nc" id="L163">   }</span>

   /**
    * Method sign
    *
    * @param password
    * @throws IOException
    */
   public void sign(char[] password) throws IOException {

      try {
<span class="nc" id="L174">         this.removeOldSignatures();</span>

<span class="nc" id="L176">         XMLSignature signature =</span>
            new XMLSignature(this._doc, &quot;&quot;, XMLSignature.ALGO_ID_MAC_HMAC_SHA1);

<span class="nc" id="L179">         this._constructionElement.appendChild(signature.getElement());</span>
<span class="nc" id="L180">         XMLUtils.addReturnToElement(this);</span>

<span class="nc" id="L182">         Transforms enveloped = new Transforms(this._doc);</span>

<span class="nc" id="L184">         enveloped.addTransform(Transforms.TRANSFORM_ENVELOPED_SIGNATURE);</span>
<span class="nc" id="L185">         signature.addDocument(&quot;&quot;, enveloped);</span>

<span class="nc" id="L187">         SecretKey secretKey = this.generateKeyFromPass(signature, password);</span>

<span class="nc" id="L189">         signature.sign(secretKey);</span>
<span class="nc" id="L190">      } catch (XMLSignatureException ex) {</span>
<span class="nc" id="L191">         throw new IOException(ex.getMessage());</span>
<span class="nc" id="L192">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L193">         throw new IOException(ex.getMessage());</span>
<span class="nc" id="L194">      }</span>
<span class="nc" id="L195">   }</span>

   /**
    * Method getSignatureElement
    *
    * @return
    * @throws XMLSecurityException
    */
   public Element getSignatureElement() throws XMLSecurityException {

<span class="nc" id="L205">      NodeList signatureElems =</span>
         this._doc.getElementsByTagNameNS(Constants.SignatureSpecNS,
                                          Constants._TAG_SIGNATURE);

<span class="nc bnc" id="L209" title="All 2 branches missed.">      if (signatureElems.getLength() == 0) {</span>
<span class="nc" id="L210">         return null;</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">      } else if (signatureElems.getLength() == 1) {</span>
<span class="nc" id="L212">         return (Element) signatureElems.item(0);</span>
      } else {
<span class="nc" id="L214">         throw new XMLSecurityException(&quot;empty&quot;);</span>
      }
   }

   /**
    * Method verify
    *
    * @param password
    * @return
    * @throws IOException
    */
   public boolean verify(char[] password) throws IOException {

      try {
<span class="nc" id="L228">         Element signatureElement = this.getSignatureElement();</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">         if (signatureElement == null) {</span>
<span class="nc" id="L231">            throw new IOException(</span>
               &quot;There must be exactly one ds:Signature in the KeyStore&quot;);
         }

<span class="nc" id="L235">         XMLSignature signature = new XMLSignature(signatureElement,</span>
                                                   &quot;memory://&quot;);

<span class="nc bnc" id="L238" title="All 2 branches missed.">         if (signature.getSignedInfo().getLength() != 1) {</span>
<span class="nc" id="L239">            throw new IOException(</span>
               &quot;ds:Signature/ds:getSignedInfo must contain exactly one ds:Reference but it was &quot;
               + signature.getSignedInfo().getLength());
         }

<span class="nc" id="L244">         Reference reference = signature.getSignedInfo().item(0);</span>

<span class="nc bnc" id="L246" title="All 2 branches missed.">         if (!reference.getURI().equals(&quot;&quot;)) {</span>
<span class="nc" id="L247">            throw new IOException(&quot;ds:Reference/@URI!=\&quot;\&quot;&quot;);</span>
         }

<span class="nc" id="L250">         Transforms transforms = reference.getTransforms();</span>

<span class="nc bnc" id="L252" title="All 4 branches missed.">         if ((transforms == null) || (transforms.getLength() != 1)) {</span>
<span class="nc" id="L253">            throw new IOException(</span>
               &quot;There must be exactly one EnvelopedSignature Transform&quot;);
         }

<span class="nc" id="L257">         Transform transform = transforms.item(0);</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">         if (!transform.getURI()</span>
                 .equals(Transforms.TRANSFORM_ENVELOPED_SIGNATURE)) {
<span class="nc" id="L261">            throw new IOException(</span>
               &quot;There must be exactly one EnvelopedSignature Transform&quot;);
         }

<span class="nc" id="L265">         SecretKey secretKey = this.generateKeyFromPass(signature, password);</span>

<span class="nc" id="L267">         return signature.checkSignatureValue(secretKey);</span>
<span class="nc" id="L268">      } catch (XMLSignatureException ex) {</span>
<span class="nc" id="L269">         throw new IOException(ex.getMessage());</span>
<span class="nc" id="L270">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L271">         throw new IOException(ex.getMessage());</span>
      }
   }

   /**
    * Method generateKeyFromPass
    *
    * @param signature
    * @param password
    * @return
    * @throws XMLSecurityException
    */
   private static SecretKey generateKeyFromPass(
           XMLSignature signature, char[] password)
              throws XMLSecurityException {

<span class="nc" id="L287">      StringBuffer sb = new StringBuffer();</span>

<span class="nc" id="L289">      sb.append(password);</span>

<span class="nc" id="L291">      return signature.createSecretKey(sb.toString().getBytes());</span>
   }

   /**
    * Method getNumberOfKeys
    *
    * @return
    */
   public int getNumberOfKeys() {
<span class="nc" id="L300">      return this.length(ApacheKeyStoreConstants.ApacheKeyStore_NAMESPACE,</span>
                         ApacheKeyStoreConstants._TAG_KEY);
   }

   /**
    * Method getNumberOfCertificates
    *
    * @return
    */
   public int getNumberOfCertificates() {
<span class="nc" id="L310">      return this.length(ApacheKeyStoreConstants.ApacheKeyStore_NAMESPACE,</span>
                         ApacheKeyStoreConstants._TAG_CERTIFICATE);
   }

   /**
    * Method getAliases
    *
    * @return
    */
   public Enumeration aliases() {

      try {
<span class="nc" id="L322">         CachedXPathAPI xpath = new CachedXPathAPI();</span>
<span class="nc" id="L323">         Element nsctx = this._doc.createElement(&quot;nsctx&quot;);</span>

<span class="nc" id="L325">         nsctx.setAttribute(&quot;xmlns:x&quot;,</span>
                            ApacheKeyStoreConstants.ApacheKeyStore_NAMESPACE);

<span class="nc" id="L328">         NodeList aliasNodes =</span>
            xpath.selectNodeList(this._doc,
                                 &quot;/x:&quot; + ApacheKeyStoreConstants._TAG_KEYSTORE
                                 + &quot;/x:*/x:&quot;
                                 + ApacheKeyStoreConstants._TAG_ALIAS
                                 + &quot;/text()&quot;, nsctx);
<span class="nc" id="L334">         Vector result = new Vector(aliasNodes.getLength());</span>

<span class="nc bnc" id="L336" title="All 2 branches missed.">         for (int i = 0; i &lt; aliasNodes.getLength(); i++) {</span>
<span class="nc" id="L337">            Text aliasText = (Text) aliasNodes.item(i);</span>

<span class="nc" id="L339">            result.add(aliasText.getNodeValue());</span>
         }

<span class="nc" id="L342">         return new MyEnumeration(result);</span>
<span class="nc" id="L343">      } catch (TransformerException ex) {}</span>

<span class="nc" id="L345">      return null;</span>
   }

   /**
    * Method isCertificateEntry
    *
    * @param alias
    * @return
    */
   public boolean isCertificateEntry(String alias) {

<span class="nc" id="L356">      Element certElem = this.getCertificateEntryElement(alias);</span>

<span class="nc bnc" id="L358" title="All 2 branches missed.">      return (certElem != null);</span>
   }

   /**
    * Method isKeyEntry
    *
    * @param alias
    * @return
    */
   public boolean isKeyEntry(String alias) {

<span class="nc" id="L369">      Element certElem = this.getKeyEntryElement(alias);</span>

<span class="nc bnc" id="L371" title="All 2 branches missed.">      return (certElem != null);</span>
   }

   /**
    * Method getCertificateEntryElement
    *
    * @param alias
    * @return
    */
   public Element getCertificateEntryElement(String alias) {

      try {
<span class="nc" id="L383">         CachedXPathAPI xpath = new CachedXPathAPI();</span>
<span class="nc" id="L384">         Element nsctx = this._doc.createElement(&quot;nsctx&quot;);</span>

<span class="nc" id="L386">         nsctx.setAttribute(&quot;xmlns:x&quot;,</span>
                            ApacheKeyStoreConstants.ApacheKeyStore_NAMESPACE);

<span class="nc" id="L389">         String searchExpr = &quot;/x:&quot; + ApacheKeyStoreConstants._TAG_KEYSTORE</span>
                             + &quot;/x:&quot; + ApacheKeyStoreConstants._TAG_CERTIFICATE
                             + &quot;[./x:&quot; + ApacheKeyStoreConstants._TAG_ALIAS
                             + &quot;/text()=\&quot;&quot; + alias + &quot;\&quot;]&quot;;
<span class="nc" id="L393">         NodeList aliasNodes = xpath.selectNodeList(this._doc, searchExpr,</span>
                                                    nsctx);

<span class="nc bnc" id="L396" title="All 2 branches missed.">         if (aliasNodes.getLength() == 1) {</span>
<span class="nc" id="L397">            return (Element) aliasNodes.item(0);</span>
         }
<span class="nc" id="L399">      } catch (TransformerException ex) {</span>
<span class="nc" id="L400">         ex.printStackTrace();</span>
<span class="nc" id="L401">      }</span>

<span class="nc" id="L403">      return null;</span>
   }

   /**
    * Method getKeyEntryElement
    *
    * @param alias
    * @return
    */
   public Element getKeyEntryElement(String alias) {

      try {
<span class="nc" id="L415">         CachedXPathAPI xpath = new CachedXPathAPI();</span>
<span class="nc" id="L416">         Element nsctx = this._doc.createElement(&quot;nsctx&quot;);</span>

<span class="nc" id="L418">         nsctx.setAttribute(&quot;xmlns:x&quot;,</span>
                            ApacheKeyStoreConstants.ApacheKeyStore_NAMESPACE);

<span class="nc" id="L421">         String searchExpr = &quot;/x:&quot; + ApacheKeyStoreConstants._TAG_KEYSTORE</span>
                             + &quot;/x:&quot; + ApacheKeyStoreConstants._TAG_KEY
                             + &quot;[./x:&quot; + ApacheKeyStoreConstants._TAG_ALIAS
                             + &quot;/text()=\&quot;&quot; + alias + &quot;\&quot;]&quot;;
<span class="nc" id="L425">         NodeList aliasNodes = xpath.selectNodeList(this._doc, searchExpr,</span>
                                                    nsctx);

<span class="nc bnc" id="L428" title="All 2 branches missed.">         if (aliasNodes.getLength() == 1) {</span>
<span class="nc" id="L429">            return (Element) aliasNodes.item(0);</span>
         }
<span class="nc" id="L431">      } catch (TransformerException ex) {</span>
<span class="nc" id="L432">         ex.printStackTrace();</span>
<span class="nc" id="L433">      }</span>

<span class="nc" id="L435">      return null;</span>
   }

   /**
    * Method getCertificate
    *
    * @param alias
    * @return
    */
   public Certificate getCertificate(String alias) {

      try {
<span class="nc" id="L447">         Element certElement = this.getCertificateEntryElement(alias);</span>

<span class="nc bnc" id="L449" title="All 2 branches missed.">         if (certElement == null) {</span>
<span class="nc" id="L450">            return null;</span>
         }

<span class="nc" id="L453">         CertificateElement certElemObject = new CertificateElement(certElement,</span>
                                                this._baseURI);

<span class="nc" id="L456">         return certElemObject.getCertificate();</span>
<span class="nc" id="L457">      } catch (CertificateException ex) {</span>
<span class="nc" id="L458">         return null;</span>
<span class="nc" id="L459">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L460">         return null;</span>
      }
   }

   /**
    * Method getCreationDate
    *
    * @param alias
    * @return
    */
   public Date getCreationDate(String alias) {

      try {
<span class="nc" id="L473">         Element certElem = this.getCertificateEntryElement(alias);</span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">         if (certElem != null) {</span>
<span class="nc" id="L476">            CertificateElement kbt = new CertificateElement(certElem,</span>
                                        this._baseURI);

<span class="nc" id="L479">            return kbt.getDate();</span>
         }

<span class="nc" id="L482">         Element keyElem = this.getKeyEntryElement(alias);</span>

<span class="nc bnc" id="L484" title="All 2 branches missed.">         if (keyElem != null) {</span>
<span class="nc" id="L485">            KeyElement kbt = new KeyElement(keyElem, this._baseURI);</span>

<span class="nc" id="L487">            return kbt.getDate();</span>
         }
<span class="nc" id="L489">      } catch (XMLSecurityException ex) {</span>
         ;
<span class="nc" id="L491">      }</span>

<span class="nc" id="L493">      return null;</span>
   }

   /**
    * Method deleteEntry
    *
    * @param alias
    * @throws KeyStoreException
    */
   public void deleteEntry(String alias) throws KeyStoreException {

<span class="nc" id="L504">      Element element = this.getKeyEntryElement(alias);</span>

<span class="nc bnc" id="L506" title="All 2 branches missed.">      if (element != null) {</span>
<span class="nc" id="L507">         Node parent = element.getParentNode();</span>
<span class="nc" id="L508">         Node following = element.getNextSibling();</span>

<span class="nc bnc" id="L510" title="All 6 branches missed.">         if ((following != null) &amp;&amp; (following.getNodeType() == Node.TEXT_NODE)</span>
                 &amp;&amp; ((Text) following).getData().equals(&quot;\n&quot;)) {
<span class="nc" id="L512">            parent.removeChild(following);</span>
         }

<span class="nc" id="L515">         parent.removeChild(element);</span>
      }

<span class="nc" id="L518">      element = this.getCertificateEntryElement(alias);</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">      if (element != null) {</span>
<span class="nc" id="L521">         Node parent = element.getParentNode();</span>
<span class="nc" id="L522">         Node following = element.getNextSibling();</span>

<span class="nc bnc" id="L524" title="All 6 branches missed.">         if ((following != null) &amp;&amp; (following.getNodeType() == Node.TEXT_NODE)</span>
                 &amp;&amp; ((Text) following).getData().equals(&quot;\n&quot;)) {
<span class="nc" id="L526">            parent.removeChild(following);</span>
         }

<span class="nc" id="L529">         parent.removeChild(element);</span>
      }
<span class="nc" id="L531">   }</span>

   /**
    * Method engineGetCertificateChain
    *
    * @param alias
    * @return
    */
   public Certificate[] getCertificateChain(String alias) {

      try {
<span class="nc" id="L542">         Element keyElement = this.getKeyEntryElement(alias);</span>

<span class="nc bnc" id="L544" title="All 2 branches missed.">         if (keyElement != null) {</span>
<span class="nc" id="L545">            KeyElement ke = new KeyElement(keyElement, this._baseURI);</span>

<span class="nc" id="L547">            return ke.getCertificateChain(alias);</span>
         }
<span class="nc" id="L549">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L550">         ex.printStackTrace();</span>
<span class="nc" id="L551">      }</span>

<span class="nc" id="L553">      return null;</span>
   }

   /**
    * Method setCertificateEntry
    *
    * @param alias
    * @param cert
    * @throws KeyStoreException
    */
   public void setCertificateEntry(String alias, Certificate cert)
           throws KeyStoreException {

      try {
<span class="nc" id="L567">         CertificateElement certificateElement =</span>
            new CertificateElement(this._doc, alias, cert);

<span class="nc" id="L570">         this._constructionElement.appendChild(certificateElement.getElement());</span>
<span class="nc" id="L571">         XMLUtils.addReturnToElement(this);</span>
<span class="nc" id="L572">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L573">         throw new KeyStoreException(ex.getMessage());</span>
<span class="nc" id="L574">      }</span>
<span class="nc" id="L575">   }</span>

   /**
    * Method setKeyEntry
    *
    * @param alias
    * @param key
    * @param chain
    * @throws KeyStoreException
    */
   public void setKeyEntry(String alias, byte[] key, Certificate[] chain)
           throws KeyStoreException {

      try {
<span class="nc" id="L589">         KeyElement keyElement = new KeyElement(this._doc, alias, key, chain);</span>

<span class="nc" id="L591">         this._constructionElement.appendChild(keyElement.getElement());</span>
<span class="nc" id="L592">         XMLUtils.addReturnToElement(this);</span>
<span class="nc" id="L593">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L594">         throw new KeyStoreException(ex.getMessage());</span>
<span class="nc" id="L595">      }</span>
<span class="nc" id="L596">   }</span>

   /**
    * Method setKeyEntry
    *
    * @param alias
    * @param k
    * @param password
    * @param chain
    * @throws KeyStoreException
    */
   public void setKeyEntry(
           String alias, Key k, char[] password, Certificate[] chain)
              throws KeyStoreException {

      try {
<span class="nc" id="L612">         KeyElement keyElement = new KeyElement(this._doc, alias, k, password,</span>
                                                chain);

<span class="nc" id="L615">         this._constructionElement.appendChild(keyElement.getElement());</span>
<span class="nc" id="L616">         XMLUtils.addReturnToElement(this);</span>
<span class="nc" id="L617">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L618">         throw new KeyStoreException(ex.getMessage());</span>
<span class="nc" id="L619">      }</span>
<span class="nc" id="L620">   }</span>

   /**
    * Method getKey
    *
    * @param alias
    * @param password
    * @return
    * @throws NoSuchAlgorithmException
    * @throws UnrecoverableKeyException
    */
   public Key getKey(String alias, char[] password)
           throws NoSuchAlgorithmException, UnrecoverableKeyException {

      try {
<span class="nc" id="L635">         KeyElement keyElement = new KeyElement(this.getKeyEntryElement(alias),</span>
                                                this._baseURI);

<span class="nc" id="L638">         return keyElement.unwrap(password);</span>
<span class="nc" id="L639">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L640">         throw new UnrecoverableKeyException(ex.getMessage());</span>
      }
   }

   /**
    * Class MyEnumeration
    *
    * @author $Author: dohy $
    * @version $Revision: 1.1.1.1 $
    */
   public class MyEnumeration implements Enumeration {

      /** Field _v */
      Vector _v;

      /** Field _i */
      int _i;

      /**
       * Constructor MyEnumeration
       *
       * @param v
       */
<span class="nc" id="L663">      protected MyEnumeration(Vector v) {</span>
<span class="nc" id="L664">         this._v = v;</span>
<span class="nc" id="L665">         this._i = 0;</span>
<span class="nc" id="L666">      }</span>

      /**
       * Method hasMoreElements
       *
       * @return
       */
      public boolean hasMoreElements() {
<span class="nc bnc" id="L674" title="All 2 branches missed.">         return this._i &lt; this._v.size();</span>
      }

      /**
       * Method nextElement
       *
       * @return
       */
      public Object nextElement() {

<span class="nc bnc" id="L684" title="All 2 branches missed.">         if (this.hasMoreElements()) {</span>
<span class="nc" id="L685">            return this._v.elementAt(this._i++);</span>
         } else {
<span class="nc" id="L687">            return null;</span>
         }
      }
   }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>