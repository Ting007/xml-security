<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>C14nHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.c14n.helper</a> &gt; <span class="el_source">C14nHelper.java</span></div><h1>C14nHelper.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.c14n.helper;



import org.w3c.dom.*;
import java.util.Comparator;
import java.util.Arrays;
import org.apache.xml.utils.URI;
import java.net.MalformedURLException;
import org.apache.xml.security.c14n.CanonicalizationException;


/**
 * Temporary swapped static functions from the normalizer Section
 *
 * @author Christian Geuer-Pollmann
 */
<span class="nc" id="L76">public class C14nHelper {</span>

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L79">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category.getInstance(C14nHelper.class.getName());

   /**
    * Method sortAttributes
    *
    * @param namednodemap
    * @return
    */
   public static final Attr[] sortAttributes(NamedNodeMap namednodemap) {

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">      if (namednodemap == null) {</span>
<span class="nc" id="L91">         return new Attr[0];</span>
      }

<span class="fc" id="L94">      Attr aattr[] = new Attr[namednodemap.getLength()];</span>

<span class="fc bfc" id="L96" title="All 2 branches covered.">      for (int j = 0; j &lt; namednodemap.getLength(); j++) {</span>
<span class="fc" id="L97">         aattr[j] = (Attr) namednodemap.item(j);</span>
      }

<span class="fc" id="L100">      java.util.Arrays.sort(aattr, new AttrCompare());</span>

      // java.util.Sort.quicksort(aattr, new AttrCompare());
<span class="fc" id="L103">      return aattr;</span>
   }

   /**
    * Method sortAttributes
    *
    * @param namednodemap
    * @return
    */
   public static final Attr[] sortAttributes(Attr[] namednodemap) {

<span class="nc bnc" id="L114" title="All 2 branches missed.">      if (namednodemap == null) {</span>
<span class="nc" id="L115">         return new Attr[0];</span>
      }

<span class="nc" id="L118">      java.util.Arrays.sort(namednodemap, new AttrCompare());</span>

      // java.util.Sort.quicksort(namednodemap, new AttrCompare());
<span class="nc" id="L121">      return namednodemap;</span>
   }

   /**
    * Normalizes an {@link Attr}ibute value
    *
    * The string value of the node is modified by replacing
    * &lt;UL&gt;
    * &lt;LI&gt;all ampersands (&amp;) with &lt;CODE&gt;&amp;amp;amp;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;all open angle brackets (&lt;) with &lt;CODE&gt;&amp;amp;lt;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;all quotation mark characters with &lt;CODE&gt;&amp;amp;quot;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;and the whitespace characters &lt;CODE&gt;#x9&lt;/CODE&gt;, #xA, and #xD, with character
    * references. The character references are written in uppercase
    * hexadecimal with no leading zeroes (for example, &lt;CODE&gt;#xD&lt;/CODE&gt; is represented
    * by the character reference &lt;CODE&gt;&amp;amp;#xD;&lt;/CODE&gt;)&lt;/LI&gt;
    * &lt;/UL&gt;
    *
    * @param s
    * @return the normalized {@link org.w3c.dom.Attr}ibute value ((({@link String})
    */
   public static final String normalizeAttr(String s) {

<span class="fc" id="L143">      StringBuffer stringbuffer = new StringBuffer();</span>
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">      int i = (s == null)</span>
              ? 0
              : s.length();

<span class="fc bfc" id="L148" title="All 2 branches covered.">      for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L149">         char c = s.charAt(j);</span>

<span class="fc bfc" id="L151" title="All 7 branches covered.">         switch (c) {</span>

         case '&amp;' :
<span class="fc" id="L154">            stringbuffer.append(&quot;&amp;amp;&quot;);</span>
<span class="fc" id="L155">            break;</span>

         case '&lt;' :
<span class="fc" id="L158">            stringbuffer.append(&quot;&amp;lt;&quot;);</span>
<span class="fc" id="L159">            break;</span>

         case '&quot;' :
<span class="fc" id="L162">            stringbuffer.append(&quot;&amp;quot;&quot;);</span>
<span class="fc" id="L163">            break;</span>

         case 0x09 :    // '\t'
<span class="fc" id="L166">            stringbuffer.append(&quot;&amp;#x9;&quot;);</span>
<span class="fc" id="L167">            break;</span>

         case 0x0A :    // '\n'
<span class="fc" id="L170">            stringbuffer.append(&quot;&amp;#xA;&quot;);</span>
<span class="fc" id="L171">            break;</span>

         case 0x0D :    // '\r'
<span class="fc" id="L174">            stringbuffer.append(&quot;&amp;#xD;&quot;);</span>
<span class="fc" id="L175">            break;</span>

         default :
<span class="fc" id="L178">            stringbuffer.append(c);</span>
            break;
         }
      }

<span class="fc" id="L183">      return stringbuffer.toString();</span>
   }

   /**
    * Normalizes a {@link org.w3c.dom.Comment} value
    *
    * @param s
    * @return the normalized {@link org.w3c.dom.Comment} value ((({@link String})
    */
   public static final String normalizeComment(String s) {
<span class="fc" id="L193">      return normalizeProcessingInstruction(s);</span>
   }

   /**
    * Normalizes a {@link org.w3c.dom.ProcessingInstruction} value
    *
    * @param s
    * @return the normalized {@link org.w3c.dom.ProcessingInstruction} value ((({@link String})
    */
   public static final String normalizeProcessingInstruction(String s) {

<span class="fc" id="L204">      StringBuffer stringbuffer = new StringBuffer();</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">      int i = (s == null)</span>
              ? 0
              : s.length();

<span class="fc bfc" id="L209" title="All 2 branches covered.">      for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L210">         char c = s.charAt(j);</span>

<span class="pc bpc" id="L212" title="1 of 2 branches missed.">         switch (c) {</span>

         case 0x0D :
<span class="nc" id="L215">            stringbuffer.append(&quot;&amp;#xD;&quot;);</span>
<span class="nc" id="L216">            break;</span>

         default :
<span class="fc" id="L219">            stringbuffer.append(c);</span>
            break;
         }
      }

<span class="fc" id="L224">      return stringbuffer.toString();</span>
   }

   /**
    * Normalizes a {@link Text} value
    *
    * &lt;p&gt;Text Nodes - the string value, except all ampersands (&amp;amp; are replaced by
    * &amp;amp;amp;, all open angle brackets (&lt;) are replaced by &amp;amp;lt;, all closing
    * angle brackets (&gt;) are replaced by &amp;amp;gt;, and all #xD characters
    * are replaced by &amp;amp;#xD;. (See &lt;A
    * HREF=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315#ProcessingModel&quot;&gt;
    * processing model section in the specification&lt;/A&gt;)&lt;/p&gt;
    *
    * @param s
    * @return the normalized {@link Text} value ((({@link String})
    */
   public static final String normalizeText(String s) {

<span class="fc" id="L242">      StringBuffer stringbuffer = new StringBuffer();</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">      int i = (s == null)</span>
              ? 0
              : s.length();

<span class="fc bfc" id="L247" title="All 2 branches covered.">      for (int j = 0; j &lt; i; j++) {</span>
<span class="fc" id="L248">         char c = s.charAt(j);</span>

<span class="fc bfc" id="L250" title="All 5 branches covered.">         switch (c) {</span>

         case '&amp;' :
<span class="fc" id="L253">            stringbuffer.append(&quot;&amp;amp;&quot;);</span>
<span class="fc" id="L254">            break;</span>

         case '&lt;' :
<span class="fc" id="L257">            stringbuffer.append(&quot;&amp;lt;&quot;);</span>
<span class="fc" id="L258">            break;</span>

         case '&gt;' :
<span class="fc" id="L261">            stringbuffer.append(&quot;&amp;gt;&quot;);</span>
<span class="fc" id="L262">            break;</span>

         case 0xD :
<span class="fc" id="L265">            stringbuffer.append(&quot;&amp;#xD;&quot;);</span>
<span class="fc" id="L266">            break;</span>

         default :
<span class="fc" id="L269">            stringbuffer.append(c);</span>
            break;
         }
      }

<span class="fc" id="L274">      return stringbuffer.toString();</span>
   }

   /**
    * Method namespaceIsRelative
    *
    * @param namespace
    * @return
    */
   public static boolean namespaceIsRelative(Attr namespace) {
<span class="fc bfc" id="L284" title="All 2 branches covered.">      return !namespaceIsAbsolute(namespace);</span>
   }

   /**
    * Method namespaceIsRelative
    *
    * @param namespaceValue
    * @return
    */
   public static boolean namespaceIsRelative(String namespaceValue) {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">      return !namespaceIsAbsolute(namespaceValue);</span>
   }

   /**
    * Method namespaceIsAbsolute
    *
    * @param namespace
    * @return
    */
   public static boolean namespaceIsAbsolute(Attr namespace) {
<span class="fc" id="L304">      return namespaceIsAbsolute(namespace.getValue());</span>
   }

   /**
    * Method namespaceIsAbsolute
    *
    * @param namespaceValue
    * @return
    */
   public static boolean namespaceIsAbsolute(String namespaceValue) {

      // assume empty namespaces are absolute
<span class="fc bfc" id="L316" title="All 2 branches covered.">      if (namespaceValue.length() == 0) {</span>
<span class="fc" id="L317">         return true;</span>
      }

      try {
<span class="fc" id="L321">         URI uri = new URI(namespaceValue);</span>
<span class="fc" id="L322">         String Scheme = uri.getScheme();</span>
<span class="fc" id="L323">         boolean protocolOK = false;</span>

<span class="pc bpc" id="L325" title="1 of 2 branches missed.">         if (Scheme != null) {</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">            protocolOK = uri.getScheme().length() &gt; 0;</span>
<span class="fc" id="L327">            cat.debug(&quot;Scheme = &quot; + Scheme);</span>
<span class="fc bfc" id="L328" title="All 2 branches covered.">            if (Scheme.equals(&quot;urn&quot;)) {</span>
<span class="fc" id="L329">               return true;</span>
            }
         }

<span class="fc" id="L333">         boolean hostOK = false;</span>
<span class="fc" id="L334">         String Host = uri.getHost();</span>

<span class="pc bpc" id="L336" title="1 of 2 branches missed.">         if (Host != null) {</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">            hostOK = uri.getHost().length() &gt; 0;</span>
<span class="fc" id="L338">            cat.debug(&quot;Host = &quot; + Host);</span>
         }

         /*
         cat.debug(&quot;URI \&quot;&quot; + namespaceValue + &quot;\&quot; hat protocol=\&quot;&quot;
                   + uri.getScheme() + &quot;\&quot; and host=\&quot;&quot; + uri.getHost()
                   + &quot;\&quot; and path=\&quot;&quot; + uri.getPath() + &quot;\&quot;&quot;);

         */
<span class="pc bpc" id="L347" title="2 of 4 branches missed.">         return (protocolOK &amp;&amp; hostOK);</span>
<span class="fc" id="L348">      } catch (URI.MalformedURIException ex) {</span>

         /*
         cat.debug(&quot;URI \&quot;&quot; + namespaceValue
                   + &quot;\&quot; hat eine URI.MalformedURIException geworfen&quot;);
         */
<span class="fc" id="L354">         return false;</span>
      }
   }

   /**
    * This method throws an exception if the Attribute value contains
    * a relative URI.
    *
    * @param attr
    * @throws CanonicalizationException
    */
   public static void assertNotRelativeNS(Attr attr)
           throws CanonicalizationException {

<span class="pc bpc" id="L368" title="1 of 2 branches missed.">      if (attr == null) {</span>
<span class="nc" id="L369">         return;</span>
      }

<span class="fc" id="L372">      String nodeAttrName = attr.getNodeName();</span>
<span class="fc" id="L373">      boolean definesDefaultNS = nodeAttrName.equals(&quot;xmlns&quot;);</span>
<span class="fc" id="L374">      boolean definesNonDefaultNS = nodeAttrName.startsWith(&quot;xmlns:&quot;);</span>

<span class="fc bfc" id="L376" title="All 4 branches covered.">      if (definesDefaultNS || definesNonDefaultNS) {</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">         if (namespaceIsRelative(attr)) {</span>
<span class="fc" id="L378">            String parentName = &quot;null&quot;;</span>
<span class="fc" id="L379">            Node parent = (Element) attr.getParentNode();</span>

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">            if (parent != null) {</span>
<span class="nc" id="L382">               parentName = parent.getNodeName();</span>
            }

<span class="fc" id="L385">            String attrValue = attr.getValue();</span>
<span class="fc" id="L386">            Object exArgs[] = { &quot;parentName&quot;, nodeAttrName, attrValue };</span>

<span class="fc" id="L388">            throw new CanonicalizationException(</span>
               &quot;c14n.Canonicalizer.RelativeNamespace&quot;, exArgs);
         }
      }
<span class="fc" id="L392">   }</span>

   static {
<span class="fc" id="L395">      org.apache.xml.security.Init.init();</span>
<span class="fc" id="L396">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>