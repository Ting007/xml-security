<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>C14nHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.c14n.helper</a> &gt; <span class="el_source">C14nHelper.java</span></div><h1>C14nHelper.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.c14n.helper;



import org.w3c.dom.*;
import java.util.Comparator;
import java.util.Arrays;
import org.apache.xml.utils.URI;
import java.net.MalformedURLException;
import org.apache.xml.security.c14n.CanonicalizationException;


/**
 * Temporary swapped static functions from the normalizer Section
 *
 * @author Christian Geuer-Pollmann
 */
public class C14nHelper {

   /**
    * Constructor C14nHelper
    *
    */
<span class="nc" id="L82">   private C14nHelper() {</span>

      // don't allow instantiation
<span class="nc" id="L85">   }</span>

   /**
    * Method sortAttributes
    *
    * @param namednodemap
    * @return
   public static final Attr[] sortAttributes(NamedNodeMap namednodemap) {

      if (namednodemap == null) {
         return new Attr[0];
      }

      Attr aattr[] = new Attr[namednodemap.getLength()];

      for (int j = 0; j &lt; namednodemap.getLength(); j++) {
         aattr[j] = (Attr) namednodemap.item(j);
      }

      java.util.Arrays.sort(aattr, new AttrCompare());

      // java.util.Sort.quicksort(aattr, new AttrCompare());
      return aattr;
   }
    */

   /**
    * Method sortAttributes
    *
    * @param namednodemap
    * @return
   public static final Attr[] sortAttributes(Attr[] namednodemap) {

      if (namednodemap == null) {
         return new Attr[0];
      }

      java.util.Arrays.sort(namednodemap, new AttrCompare());

      // java.util.Sort.quicksort(namednodemap, new AttrCompare());
      return namednodemap;
   }
    */

   /**
    * Method sortAttributes
    *
    * @param namednodemap
    * @return
   public static final Object[] sortAttributes(Object[] namednodemap) {

      for (

      java.util.Arrays.sort(namednodemap, new AttrCompare());

      // java.util.Sort.quicksort(namednodemap, new AttrCompare());
      return namednodemap;
   }
    */

   /**
    * Normalizes an {@link Attr}ibute value
    *
    * The string value of the node is modified by replacing
    * &lt;UL&gt;
    * &lt;LI&gt;all ampersands (&amp;) with &lt;CODE&gt;&amp;amp;amp;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;all open angle brackets (&lt;) with &lt;CODE&gt;&amp;amp;lt;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;all quotation mark characters with &lt;CODE&gt;&amp;amp;quot;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;and the whitespace characters &lt;CODE&gt;#x9&lt;/CODE&gt;, #xA, and #xD, with character
    * references. The character references are written in uppercase
    * hexadecimal with no leading zeroes (for example, &lt;CODE&gt;#xD&lt;/CODE&gt; is represented
    * by the character reference &lt;CODE&gt;&amp;amp;#xD;&lt;/CODE&gt;)&lt;/LI&gt;
    * &lt;/UL&gt;
    *
    * @param s
    * @return the normalized {@link org.w3c.dom.Attr}ibute value ((({@link String})
    */
   public static final String normalizeAttr(String s) {

<span class="nc" id="L164">      StringBuffer stringbuffer = new StringBuffer();</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">      int i = (s == null)</span>
              ? 0
              : s.length();

<span class="nc bnc" id="L169" title="All 2 branches missed.">      for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L170">         char c = s.charAt(j);</span>

<span class="nc bnc" id="L172" title="All 7 branches missed.">         switch (c) {</span>

         case '&amp;' :
<span class="nc" id="L175">            stringbuffer.append(&quot;&amp;amp;&quot;);</span>
<span class="nc" id="L176">            break;</span>

         case '&lt;' :
<span class="nc" id="L179">            stringbuffer.append(&quot;&amp;lt;&quot;);</span>
<span class="nc" id="L180">            break;</span>

         case '&quot;' :
<span class="nc" id="L183">            stringbuffer.append(&quot;&amp;quot;&quot;);</span>
<span class="nc" id="L184">            break;</span>

         case 0x09 :    // '\t'
<span class="nc" id="L187">            stringbuffer.append(&quot;&amp;#x9;&quot;);</span>
<span class="nc" id="L188">            break;</span>

         case 0x0A :    // '\n'
<span class="nc" id="L191">            stringbuffer.append(&quot;&amp;#xA;&quot;);</span>
<span class="nc" id="L192">            break;</span>

         case 0x0D :    // '\r'
<span class="nc" id="L195">            stringbuffer.append(&quot;&amp;#xD;&quot;);</span>
<span class="nc" id="L196">            break;</span>

         default :
<span class="nc" id="L199">            stringbuffer.append(c);</span>
            break;
         }
      }

<span class="nc" id="L204">      return stringbuffer.toString();</span>
   }

   /**
    * Normalizes a {@link org.w3c.dom.Comment} value
    *
    * @param s
    * @return the normalized {@link org.w3c.dom.Comment} value ((({@link String})
    */
   public static final String normalizeComment(String s) {
<span class="nc" id="L214">      return normalizeProcessingInstruction(s);</span>
   }

   /**
    * Normalizes a {@link org.w3c.dom.ProcessingInstruction} value
    *
    * @param s
    * @return the normalized {@link org.w3c.dom.ProcessingInstruction} value ((({@link String})
    */
   public static final String normalizeProcessingInstruction(String s) {

<span class="nc" id="L225">      StringBuffer stringbuffer = new StringBuffer();</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">      int i = (s == null)</span>
              ? 0
              : s.length();

<span class="nc bnc" id="L230" title="All 2 branches missed.">      for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L231">         char c = s.charAt(j);</span>

<span class="nc bnc" id="L233" title="All 2 branches missed.">         switch (c) {</span>

         case 0x0D :
<span class="nc" id="L236">            stringbuffer.append(&quot;&amp;#xD;&quot;);</span>
<span class="nc" id="L237">            break;</span>

         default :
<span class="nc" id="L240">            stringbuffer.append(c);</span>
            break;
         }
      }

<span class="nc" id="L245">      return stringbuffer.toString();</span>
   }

   /**
    * Normalizes a {@link Text} value
    *
    * &lt;p&gt;Text Nodes - the string value, except all ampersands (&amp;amp; are replaced by
    * &amp;amp;amp;, all open angle brackets (&lt;) are replaced by &amp;amp;lt;, all closing
    * angle brackets (&gt;) are replaced by &amp;amp;gt;, and all #xD characters
    * are replaced by &amp;amp;#xD;. (See &lt;A
    * HREF=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315#ProcessingModel&quot;&gt;
    * processing model section in the specification&lt;/A&gt;)&lt;/p&gt;
    *
    * @param s
    * @return the normalized {@link Text} value ((({@link String})
    */
   public static final String normalizeText(String s) {

<span class="nc" id="L263">      StringBuffer stringbuffer = new StringBuffer();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">      int i = (s == null)</span>
              ? 0
              : s.length();

<span class="nc bnc" id="L268" title="All 2 branches missed.">      for (int j = 0; j &lt; i; j++) {</span>
<span class="nc" id="L269">         char c = s.charAt(j);</span>

<span class="nc bnc" id="L271" title="All 5 branches missed.">         switch (c) {</span>

         case '&amp;' :
<span class="nc" id="L274">            stringbuffer.append(&quot;&amp;amp;&quot;);</span>
<span class="nc" id="L275">            break;</span>

         case '&lt;' :
<span class="nc" id="L278">            stringbuffer.append(&quot;&amp;lt;&quot;);</span>
<span class="nc" id="L279">            break;</span>

         case '&gt;' :
<span class="nc" id="L282">            stringbuffer.append(&quot;&amp;gt;&quot;);</span>
<span class="nc" id="L283">            break;</span>

         case 0xD :
<span class="nc" id="L286">            stringbuffer.append(&quot;&amp;#xD;&quot;);</span>
<span class="nc" id="L287">            break;</span>

         default :
<span class="nc" id="L290">            stringbuffer.append(c);</span>
            break;
         }
      }

<span class="nc" id="L295">      return stringbuffer.toString();</span>
   }

   /**
    * Method namespaceIsRelative
    *
    * @param namespace
    * @return
    */
   public static boolean namespaceIsRelative(Attr namespace) {
<span class="nc bnc" id="L305" title="All 2 branches missed.">      return !namespaceIsAbsolute(namespace);</span>
   }

   /**
    * Method namespaceIsRelative
    *
    * @param namespaceValue
    * @return
    */
   public static boolean namespaceIsRelative(String namespaceValue) {
<span class="fc bfc" id="L315" title="All 2 branches covered.">      return !namespaceIsAbsolute(namespaceValue);</span>
   }

   /**
    * Method namespaceIsAbsolute
    *
    * @param namespace
    * @return
    */
   public static boolean namespaceIsAbsolute(Attr namespace) {
<span class="nc" id="L325">      return namespaceIsAbsolute(namespace.getValue());</span>
   }

   /**
    * Method namespaceIsAbsolute
    *
    * @param namespaceValue
    * @return
    */
   public static boolean namespaceIsAbsolute(String namespaceValue) {

      // assume empty namespaces are absolute
<span class="fc bfc" id="L337" title="All 2 branches covered.">      if (namespaceValue.length() == 0) {</span>
<span class="fc" id="L338">         return true;</span>
      }

<span class="fc" id="L341">      boolean foundColon = false;</span>
<span class="fc" id="L342">      int length = namespaceValue.length();</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L345">         char c = namespaceValue.charAt(i);</span>

<span class="fc bfc" id="L347" title="All 2 branches covered.">         if (c == ':') {</span>
<span class="fc" id="L348">            foundColon = true;</span>
<span class="fc bfc" id="L349" title="All 4 branches covered.">         } else if (!foundColon &amp;&amp; (c == '/')) {</span>
<span class="fc" id="L350">            return false;</span>
         }
      }

<span class="fc" id="L354">      return foundColon;</span>

      /*
      try {
         URI uri = new URI(namespaceValue);
         String Scheme = uri.getScheme();
         boolean protocolOK = false;

         if (Scheme != null) {
            protocolOK = uri.getScheme().length() &gt; 0;

            if (Scheme.equals(&quot;urn&quot;)) {
               return true;
            }
         }

         boolean hostOK = false;
         String Host = uri.getHost();

         if (Host != null) {
            hostOK = uri.getHost().length() &gt; 0;
         }

         return (protocolOK &amp;&amp; hostOK);
      } catch (URI.MalformedURIException ex) {
         return false;
      }
      */
   }

   /**
    * This method throws an exception if the Attribute value contains
    * a relative URI.
    *
    * @param attr
    * @throws CanonicalizationException
    */
   public static void assertNotRelativeNS(Attr attr)
           throws CanonicalizationException {

<span class="nc bnc" id="L394" title="All 2 branches missed.">      if (attr == null) {</span>
<span class="nc" id="L395">         return;</span>
      }

<span class="nc" id="L398">      String nodeAttrName = attr.getNodeName();</span>
<span class="nc" id="L399">      boolean definesDefaultNS = nodeAttrName.equals(&quot;xmlns&quot;);</span>
<span class="nc" id="L400">      boolean definesNonDefaultNS = nodeAttrName.startsWith(&quot;xmlns:&quot;);</span>

<span class="nc bnc" id="L402" title="All 4 branches missed.">      if (definesDefaultNS || definesNonDefaultNS) {</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">         if (namespaceIsRelative(attr)) {</span>
<span class="nc" id="L404">            String parentName = attr.getOwnerElement().getTagName();</span>
<span class="nc" id="L405">            String attrValue = attr.getValue();</span>
<span class="nc" id="L406">            Object exArgs[] = { parentName, nodeAttrName, attrValue };</span>

<span class="nc" id="L408">            throw new CanonicalizationException(</span>
               &quot;c14n.Canonicalizer.RelativeNamespace&quot;, exArgs);
         }
      }
<span class="nc" id="L412">   }</span>

   /**
    * This method throws a CanonicalizationException if the supplied Document
    * is not able to be traversed using a TreeWalker.
    *
    * @param document
    * @throws CanonicalizationException
    */
   public static void checkTraversability(Document document)
           throws CanonicalizationException {

<span class="nc bnc" id="L424" title="All 2 branches missed.">      if (!document.isSupported(&quot;Traversal&quot;, &quot;2.0&quot;)) {</span>
<span class="nc" id="L425">         Object exArgs[] = {</span>
            document.getImplementation().getClass().getName() };

<span class="nc" id="L428">         throw new CanonicalizationException(</span>
            &quot;c14n.Canonicalizer.TraversalNotSupported&quot;, exArgs);
      }
<span class="nc" id="L431">   }</span>

   /**
    * This method throws a CanonicalizationException if the supplied Element
    * contains any relative namespaces.
    *
    * @param ctxNode
    * @throws CanonicalizationException
    * @see C14nHelper#assertNotRelativeNS(Attr)
    */
   public static void checkForRelativeNamespace(Element ctxNode)
           throws CanonicalizationException {

<span class="nc bnc" id="L444" title="All 2 branches missed.">      if (ctxNode != null) {</span>
<span class="nc" id="L445">         NamedNodeMap attributes = ctxNode.getAttributes();</span>

<span class="nc bnc" id="L447" title="All 2 branches missed.">         for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="nc" id="L448">            C14nHelper.assertNotRelativeNS((Attr) attributes.item(i));</span>
         }
<span class="nc" id="L450">      } else {</span>
<span class="nc" id="L451">         throw new CanonicalizationException(</span>
            &quot;Called checkForRelativeNamespace() on null&quot;);
      }
<span class="nc" id="L454">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>