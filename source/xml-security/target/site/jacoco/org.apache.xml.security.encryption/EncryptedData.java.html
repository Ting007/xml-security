<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EncryptedData.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.encryption</a> &gt; <span class="el_source">EncryptedData.java</span></div><h1>EncryptedData.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.encryption;



import java.io.*;
import java.security.Key;
import org.apache.xml.security.algorithms.encryption.EncryptionMethod;
import org.apache.xml.security.algorithms.encryption.params
   .EncryptionMethodParams;
import org.apache.xml.security.c14n.*;
import org.apache.xml.security.encryption.type.EncryptedType;
import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.keys.KeyInfo;
import org.apache.xml.security.utils.*;
import org.w3c.dom.*;


/**
 * This class maps to the &lt;CODE&gt;xenc:EncryptedData&lt;/CODE&gt; element.
 *
 * @author $Author: dohy $
 */
public class EncryptedData extends EncryptionElementProxy
        implements EncryptedType {

   /**
    * Constructor EncryptedData
    *
    * @param doc
    * @param encryptionMethod
    * @param keyInfo
    * @param cipherData
    * @param encryptionProperties
    * @param Id
    * @param Type
    * @throws XMLSecurityException
    */
   public EncryptedData(
           Document doc, EncryptionMethod encryptionMethod, KeyInfo keyInfo, CipherData cipherData, EncryptionProperties encryptionProperties, String Id, String Type)
              throws XMLSecurityException {

<span class="nc" id="L100">      super(doc);</span>

<span class="nc" id="L102">      XMLUtils.addReturnToElement(this._constructionElement);</span>

<span class="nc bnc" id="L104" title="All 2 branches missed.">      if (encryptionMethod != null) {</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">         if (!encryptionMethod.getUsableInEncryptedData()) {</span>
<span class="nc" id="L106">            Object exArgs[] = { encryptionMethod.getAlgorithmURI() };</span>

<span class="nc" id="L108">            throw new XMLSecurityException(</span>
               &quot;encryption.algorithmCannotBeUsedForEncryptedData&quot;, exArgs);
         }

<span class="nc" id="L112">         this._constructionElement.appendChild(encryptionMethod.getElement());</span>
<span class="nc" id="L113">         XMLUtils.addReturnToElement(this._constructionElement);</span>

<span class="nc" id="L115">         this._cachedEncryptionMethod = encryptionMethod;</span>
      }

<span class="nc bnc" id="L118" title="All 2 branches missed.">      if (keyInfo != null) {</span>
<span class="nc" id="L119">         this._constructionElement.appendChild(keyInfo.getElement());</span>
<span class="nc" id="L120">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }

<span class="nc bnc" id="L123" title="All 2 branches missed.">      if (cipherData == null) {</span>

         //
         // the CipherData child will be filled by this object, so we only
         // create a place holder
         //
<span class="nc" id="L129">         cipherData = new CipherData(doc);</span>
      }

<span class="nc" id="L132">      this._constructionElement.appendChild(cipherData.getElement());</span>
<span class="nc" id="L133">      XMLUtils.addReturnToElement(this._constructionElement);</span>

<span class="nc bnc" id="L135" title="All 2 branches missed.">      if (encryptionProperties != null) {</span>
<span class="nc" id="L136">         this._constructionElement</span>
            .appendChild(encryptionProperties.getElement());
<span class="nc" id="L138">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }

<span class="nc" id="L141">      this.setId(Id);</span>
<span class="nc" id="L142">      this.setType(Type);</span>
<span class="nc" id="L143">   }</span>

   /**
    * Constructor EncryptedData
    *
    * @param doc
    * @param encryptionMethod
    * @param encryptionMethodParams
    * @param keyInfo
    * @param encryptionProperties
    * @param Id
    * @throws XMLSecurityException
    */
   public EncryptedData(
           Document doc, String encryptionMethod, EncryptionMethodParams encryptionMethodParams, KeyInfo keyInfo, EncryptionProperties encryptionProperties, String Id)
              throws XMLSecurityException {

<span class="nc" id="L160">      this(doc,</span>
           new EncryptionMethod(doc, encryptionMethod, encryptionMethodParams),
           keyInfo, (CipherData) null, encryptionProperties, Id, (String) null);
<span class="nc" id="L163">   }</span>

   /**
    * Constructor EncryptedData
    *
    * @param doc
    * @param encryptionMethod
    * @param encryptionMethodParams
    * @param keyInfo
    * @param cipherData
    * @param encryptionProperties
    * @param Id
    * @param Type
    * @throws XMLSecurityException
    */
   public EncryptedData(
           Document doc, String encryptionMethod,
           EncryptionMethodParams encryptionMethodParams, KeyInfo keyInfo, CipherData cipherData, EncryptionProperties encryptionProperties, String Id, String Type)
              throws XMLSecurityException {

<span class="nc" id="L183">      this(doc,</span>
           new EncryptionMethod(doc, encryptionMethod, encryptionMethodParams),
           keyInfo, cipherData, encryptionProperties, Id, Type);
<span class="nc" id="L186">   }</span>

   /**
    * Constructor EncryptedData
    *
    * @param element
    * @param BaseURI
    * @throws XMLSecurityException
    */
   public EncryptedData(Element element, String BaseURI)
           throws XMLSecurityException {
<span class="nc" id="L197">      super(element, BaseURI);</span>
<span class="nc" id="L198">   }</span>

   /**
    * Method getEncryptionMethod
    *
    * @return
    * @throws XMLSecurityException
    */
   public EncryptionMethod getEncryptionMethod() throws XMLSecurityException {

<span class="nc bnc" id="L208" title="All 2 branches missed.">      if (this._cachedEncryptionMethod == null) {</span>
<span class="nc" id="L209">         Element e =</span>
            XMLUtils.getDirectChild(this._constructionElement,
                                    EncryptionConstants._TAG_ENCRYPTIONMETHOD,
                                    EncryptionConstants.EncryptionSpecNS);

<span class="nc bnc" id="L214" title="All 2 branches missed.">         if (e != null) {</span>
<span class="nc" id="L215">            this._cachedEncryptionMethod = new EncryptionMethod(e,</span>
                    this._baseURI);
         }
      }

<span class="nc" id="L220">      return this._cachedEncryptionMethod;</span>
   }

   /**
    * Method getKeyInfo
    *
    * @return
    * @throws XMLSecurityException
    */
   public KeyInfo getKeyInfo() throws XMLSecurityException {

<span class="nc" id="L231">      Element e = XMLUtils.getDirectChild(this._constructionElement,</span>
                                          Constants._TAG_KEYINFO,
                                          Constants.SignatureSpecNS);

<span class="nc bnc" id="L235" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L236">         return new KeyInfo(e, this._baseURI);</span>
      } else {
<span class="nc" id="L238">         return null;</span>
      }
   }

   /**
    * Method getCipherData
    *
    * @return
    * @throws XMLSecurityException
    */
   public CipherData getCipherData() throws XMLSecurityException {

<span class="nc" id="L250">      Element e = XMLUtils.getDirectChild(this._constructionElement,</span>
                                          EncryptionConstants._TAG_CIPHERDATA,
                                          EncryptionConstants.EncryptionSpecNS);

<span class="nc bnc" id="L254" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L255">         return new CipherData(e, this._baseURI);</span>
      } else {
<span class="nc" id="L257">         return null;</span>
      }
   }

   /**
    * Method getEncryptionProperties
    *
    * @return
    * @throws XMLSecurityException
    */
   public EncryptionProperties getEncryptionProperties()
           throws XMLSecurityException {

<span class="nc" id="L270">      Element e =</span>
         XMLUtils.getDirectChild(this._constructionElement,
                                 EncryptionConstants._TAG_ENCRYPTIONPROPERTIES,
                                 EncryptionConstants.EncryptionSpecNS);

<span class="nc bnc" id="L275" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L276">         return new EncryptionProperties(e, this._baseURI);</span>
      } else {
<span class="nc" id="L278">         return null;</span>
      }
   }

   /**
    * Sets the &lt;code&gt;Id&lt;/code&gt; attribute
    *
    * @param Id ID
    */
   public void setId(String Id) {

<span class="nc bnc" id="L289" title="All 6 branches missed.">      if ((this._state == MODE_CREATE) &amp;&amp; (Id != null) &amp;&amp; (Id.length() != 0)) {</span>
<span class="nc" id="L290">         this._constructionElement.setAttribute(EncryptionConstants._ATT_ID,</span>
                                                Id);
<span class="nc" id="L292">         IdResolver.registerElementById(this._constructionElement, Id);</span>
      }
<span class="nc" id="L294">   }</span>

   /**
    * Returns the &lt;code&gt;Id&lt;/code&gt; attribute
    *
    * @return the &lt;code&gt;Id&lt;/code&gt; attribute
    */
   public String getId() {
<span class="nc" id="L302">      return this._constructionElement</span>
         .getAttribute(EncryptionConstants._ATT_ID);
   }

   /**
    * Method setType
    *
    * @param Type
    */
   public void setType(String Type) {

<span class="nc bnc" id="L313" title="All 4 branches missed.">      if ((this._state == MODE_CREATE) &amp;&amp; (Type != null)) {</span>
<span class="nc" id="L314">         this._constructionElement.setAttribute(EncryptionConstants._ATT_TYPE,</span>
                                                Type);
      }
<span class="nc" id="L317">   }</span>

   /**
    * Method getType
    *
    * @return
    */
   public String getType() {
<span class="nc" id="L325">      return this._constructionElement</span>
         .getAttribute(EncryptionConstants._ATT_TYPE);
   }

   /**
    * Method getTypeIsElement
    *
    * @return
    */
   public boolean getTypeIsElement() {

<span class="nc" id="L336">      String type = this.getType();</span>

<span class="nc bnc" id="L338" title="All 4 branches missed.">      if ((type == null) || (type.length() == 0)) {</span>
<span class="nc" id="L339">         return false;</span>
      }

<span class="nc" id="L342">      return type.equals(EncryptionConstants.TYPE_ELEMENT);</span>
   }

   /**
    * Method getTypeIsContent
    *
    * @return
    */
   public boolean getTypeIsContent() {

<span class="nc" id="L352">      String type = this.getType();</span>

<span class="nc bnc" id="L354" title="All 4 branches missed.">      if ((type == null) || (type.length() == 0)) {</span>
<span class="nc" id="L355">         return false;</span>
      }

<span class="nc" id="L358">      return type.equals(EncryptionConstants.TYPE_CONTENT);</span>
   }

   /**
    * Method getTypeIsMediaType
    *
    * @return
    */
   public boolean getTypeIsMediaType() {

<span class="nc" id="L368">      String type = this.getType();</span>

<span class="nc bnc" id="L370" title="All 4 branches missed.">      if ((type == null) || (type.length() == 0)) {</span>
<span class="nc" id="L371">         return false;</span>
      }

<span class="nc" id="L374">      return type.startsWith(EncryptionConstants.TYPE_MEDIATYPE);</span>
   }

   /**
    * Method getMediaTypeOfType
    *
    * @return
    */
   public String getMediaTypeOfType() {

<span class="nc bnc" id="L384" title="All 2 branches missed.">      if (this.getTypeIsMediaType()) {</span>
<span class="nc" id="L385">         return this.getType()</span>
            .substring(EncryptionConstants.TYPE_MEDIATYPE.length());
      }

<span class="nc" id="L389">      return null;</span>
   }

   /**
    * Method replace
    *
    * @param oldElement
    * @param newContent
    * @return
    */
   public static Element replace(Element oldElement, NodeList newContent) {

      /*
      if (oldElement == null) {
        throw new IllegalArgumentException(&quot;oldElement is null&quot;);
      }
      if (newContent == null) {
        throw new IllegalArgumentException(&quot;newContent is null&quot;);
      }
      */
<span class="nc" id="L409">      Document oldDocument = oldElement.getOwnerDocument();</span>

      {
<span class="nc" id="L412">         HelperNodeList nl2 = new HelperNodeList();</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">         for (int i = 0; i &lt; newContent.getLength(); i++) {</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">            if (oldDocument != newContent.item(i).getOwnerDocument()) {</span>

               // both elements are in different documents so we have to import.
<span class="nc" id="L418">               nl2.appendChild(oldDocument.importNode(newContent.item(i),</span>
                                                      true));
            } else {
<span class="nc" id="L421">               nl2.appendChild(newContent.item(i));</span>
            }
         }

<span class="nc" id="L425">         newContent = nl2;</span>
      }

<span class="nc" id="L428">      Node parent = oldElement.getParentNode();</span>

<span class="nc bnc" id="L430" title="All 2 branches missed.">      if (parent == oldDocument) {</span>

         //
         // we cannot use replaceChild because this throws DOMException
         //
<span class="nc" id="L435">         NodeList topLevelNodes = oldDocument.getChildNodes();</span>

<span class="nc bnc" id="L437" title="All 2 branches missed.">         if (topLevelNodes.getLength() == 1) {</span>
<span class="nc" id="L438">            Node returnValue = oldDocument.removeChild(oldElement);</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">            for (int i = 0; i &lt; newContent.getLength(); i++) {</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">               if (newContent.item(i).getNodeType() != Node.TEXT_NODE) {</span>
<span class="nc" id="L442">                  oldDocument.appendChild(newContent.item(i));</span>
               }
            }

<span class="nc" id="L446">            return (Element) returnValue;</span>
         } else {
<span class="nc" id="L448">            int i = 0;</span>

<span class="nc bnc" id="L450" title="All 2 branches missed.">            searchForRootElem: for (i = 0; i &lt; topLevelNodes.getLength(); i++) {</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">               if (topLevelNodes.item(i) == oldElement) {</span>
<span class="nc" id="L452">                  break searchForRootElem;</span>
               }
            }

<span class="nc bnc" id="L456" title="All 2 branches missed.">            if (i == topLevelNodes.getLength() - 1) {</span>
<span class="nc" id="L457">               Node returnValue = oldDocument.removeChild(oldElement);</span>

<span class="nc bnc" id="L459" title="All 2 branches missed.">               for (int j = 0; j &lt; newContent.getLength(); j++) {</span>
<span class="nc" id="L460">                  oldDocument.appendChild(newContent.item(j));</span>
               }

<span class="nc" id="L463">               return (Element) returnValue;</span>
            } else {
<span class="nc" id="L465">               Node returnValue = oldDocument.removeChild(oldElement);</span>
<span class="nc" id="L466">               Node insertBefore = topLevelNodes.item(i);</span>

<span class="nc bnc" id="L468" title="All 2 branches missed.">               for (int j = 0; j &lt; newContent.getLength(); j++) {</span>
<span class="nc" id="L469">                  oldDocument.insertBefore(newContent.item(j), insertBefore);</span>
               }

<span class="nc" id="L472">               return (Element) returnValue;</span>
            }
         }
      } else {
<span class="nc bnc" id="L476" title="All 2 branches missed.">         for (int j = 0; j &lt; newContent.getLength(); j++) {</span>
<span class="nc" id="L477">            parent.insertBefore(newContent.item(j), oldElement);</span>
         }

<span class="nc" id="L480">         return (Element) parent.removeChild(oldElement);</span>
      }
   }

   /**
    * Replaces an old Element by a new one
    *
    * @param oldElement the old Element which has to be removed from the Document
    * @param newElement the new Element which has to be place in the position of &lt;CODE&gt;oldElement&lt;/CODE&gt;
    * @return the removed element
    */
   public static Element replace(Element oldElement, Element newElement) {

<span class="nc" id="L493">      HelperNodeList newContent = new HelperNodeList();</span>

<span class="nc" id="L495">      newContent.appendChild(newElement);</span>

<span class="nc" id="L497">      return replace(oldElement, newContent);</span>
   }

   /**
    * Method replace
    *
    * @param oldElement
    * @param plaintextBytes
    * @return
    * @throws XMLSecurityException
    */
   public static Element replace(Element oldElement, byte[] plaintextBytes)
           throws XMLSecurityException {

      try {
<span class="nc" id="L512">         javax.xml.parsers.DocumentBuilderFactory dbf =</span>
            javax.xml.parsers.DocumentBuilderFactory.newInstance();

<span class="nc" id="L515">         dbf.setNamespaceAware(true);</span>

<span class="nc" id="L517">         javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L518">         Document doc =</span>
            db.parse(new java.io.ByteArrayInputStream(plaintextBytes));
<span class="nc" id="L520">         HelperNodeList newContent = new HelperNodeList();</span>

<span class="nc bnc" id="L522" title="All 2 branches missed.">         for (int i = 0; i &lt; doc.getChildNodes().getLength(); i++) {</span>
<span class="nc" id="L523">            newContent.appendChild(doc.getChildNodes().item(i));</span>
         }

<span class="nc" id="L526">         return replace(oldElement, newContent);</span>
<span class="nc" id="L527">      } catch (javax.xml.parsers.ParserConfigurationException ex) {</span>
<span class="nc" id="L528">         throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L529">      } catch (java.io.IOException ex) {</span>
<span class="nc" id="L530">         throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L531">      } catch (org.xml.sax.SAXException ex) {</span>
<span class="nc" id="L532">         throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
      }
   }

   /** Field _cachedEncryptionMethod */
<span class="nc" id="L537">   EncryptionMethod _cachedEncryptionMethod = null;</span>

   /**
    * Method createSecretKeyFromBytes
    *
    * @param encodedKey
    * @return
    * @throws XMLSecurityException
    */
   public Key createSecretKeyFromBytes(byte encodedKey[])
           throws XMLSecurityException {
<span class="nc" id="L548">      return this.getEncryptionMethod().createSecretKeyFromBytes(encodedKey);</span>
   }

   /**
    * Method encryptAndReplace
    *
    * @param plaintextElement
    * @param secretKey
    * @throws XMLSecurityException
    */
   public void encryptElementAndReplace(Element plaintextElement, Key secretKey)
           throws XMLSecurityException {

<span class="nc" id="L561">      EncryptionMethod em = this.getEncryptionMethod();</span>
<span class="nc" id="L562">      Canonicalizer c14n =</span>
         Canonicalizer.getInstance(Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS);
<span class="nc" id="L564">      byte plaintext[] = c14n.canonicalize(plaintextElement);</span>
<span class="nc" id="L565">      byte ciphertext[] = em.encrypt(plaintext, secretKey);</span>

<span class="nc" id="L567">      this.getCipherData().setCipherValue(new CipherValue(this._doc,</span>
              ciphertext));
<span class="nc" id="L569">      this.setType(EncryptionConstants.TYPE_ELEMENT);</span>
<span class="nc" id="L570">      EncryptedData.replace(plaintextElement, this._constructionElement);</span>
<span class="nc" id="L571">   }</span>

   /**
    * This method is the old implementation of {@link #encryptContentAndReplace()}.
    *
    * @param parentOfPlaintext the parent of the Nodes which are to be encrypted. All child nodes will be encrypted but not the parent itself.
    * @param contentEncryptionKey the {@link Key} which is used to encrypt the data
    * @throws XMLSecurityException
    */
   private void encryptContentAndReplace_old(
           Node parentOfPlaintext, Key contentEncryptionKey)
              throws XMLSecurityException {

<span class="nc" id="L584">      EncryptionMethod em = this.getEncryptionMethod();</span>
<span class="nc" id="L585">      byte plaintext[] = null;</span>

      try {
<span class="nc" id="L588">         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>

<span class="nc bnc" id="L590" title="All 2 branches missed.">         for (int i = 0; i &lt; parentOfPlaintext.getChildNodes().getLength();</span>
<span class="nc" id="L591">                 i++) {</span>
<span class="nc" id="L592">            Node plaintextItem = parentOfPlaintext.getChildNodes().item(i);</span>

            // we cannot c14nize Comments, and PIs because the c14nizer appends CRs to the String
<span class="nc bnc" id="L595" title="All 2 branches missed.">            if (plaintextItem.getNodeType() == Node.COMMENT_NODE) {</span>
<span class="nc" id="L596">               baos.write((&quot;&lt;!--&quot; + ((Comment) plaintextItem).getData()</span>
                           + &quot;--&gt;&quot;).getBytes());
<span class="nc bnc" id="L598" title="All 2 branches missed.">            } else if (plaintextItem.getNodeType()</span>
                       == Node.PROCESSING_INSTRUCTION_NODE) {
<span class="nc" id="L600">               baos.write((&quot;&lt;?&quot;</span>
                           + ((ProcessingInstruction) plaintextItem).getTarget()
                           + &quot; &quot;
                           + ((ProcessingInstruction) plaintextItem).getData()
                           + &quot;?&gt;&quot;).getBytes());
<span class="nc bnc" id="L605" title="All 2 branches missed.">            } else if (plaintextItem.getNodeType() == Node.TEXT_NODE) {</span>
<span class="nc" id="L606">               baos.write((((Text) plaintextItem).getData()).getBytes());</span>
            } else {

               // we have to create a new Canonicalizer for each Node because it stores state ;-(
<span class="nc" id="L610">               Canonicalizer c14n =</span>
                  Canonicalizer
                     .getInstance(Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS);

<span class="nc" id="L614">               baos.write(c14n.canonicalize(plaintextItem));</span>
            }
         }

<span class="nc" id="L618">         plaintext = baos.toByteArray();</span>
<span class="nc" id="L619">      } catch (Exception ex) {</span>
<span class="nc" id="L620">         throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L621">      }</span>

<span class="nc" id="L623">      byte ciphertext[] = em.encrypt(plaintext, contentEncryptionKey);</span>

<span class="nc" id="L625">      this.getCipherData().setCipherValue(new CipherValue(this._doc,</span>
              ciphertext));
<span class="nc" id="L627">      this.setType(EncryptionConstants.TYPE_CONTENT);</span>

<span class="nc bnc" id="L629" title="All 2 branches missed.">      while (parentOfPlaintext.hasChildNodes()) {</span>
<span class="nc" id="L630">         parentOfPlaintext.removeChild(parentOfPlaintext.getLastChild());</span>
      }

<span class="nc" id="L633">      parentOfPlaintext.appendChild(this._constructionElement);</span>
<span class="nc" id="L634">   }</span>

   /**
    * Encrypts all child {@link Node}s of a given {@link Element}.
    *
    * @param parentOfPlaintext the parent of the Nodes which are to be encrypted. All child nodes will be encrypted but not the parent itself.
    * @param contentEncryptionKey the {@link Key} which is used to encrypt the data
    * @throws XMLSecurityException
    */
   public void encryptContentAndReplace(
           Node parentOfPlaintext, Key contentEncryptionKey)
              throws XMLSecurityException {

<span class="nc" id="L647">      encryptContentAndReplace(parentOfPlaintext.getFirstChild(),</span>
                               parentOfPlaintext.getChildNodes().getLength(),
                               contentEncryptionKey);
<span class="nc" id="L650">   }</span>

   /**
    * Encrypts &lt;B&gt;some&lt;/B&gt; child {@link Node}s of a given {@link Element}.
    *
    * @param firstPlaintextNode the first Node to be encrypted
    * @param length the total number of Nodes to be encrypted (the firstPlaintextNode and (length-1) next siblings)
    * @param contentEncryptionKey the {@link Key} which is used to encrypt the data
    * @throws XMLSecurityException
    */
   public void encryptContentAndReplace(
           Node firstPlaintextNode, int length, Key contentEncryptionKey)
              throws XMLSecurityException {

      try {
<span class="nc" id="L665">         EncryptionMethod em = this.getEncryptionMethod();</span>
<span class="nc" id="L666">         byte plaintext[] = null;</span>
<span class="nc" id="L667">         Node parent = firstPlaintextNode.getParentNode();</span>
<span class="nc" id="L668">         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L669">         Node currentNode = firstPlaintextNode;</span>
<span class="nc" id="L670">         int i = 0;</span>

<span class="nc bnc" id="L672" title="All 2 branches missed.">         while (i &lt; length) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">            if (currentNode == null) {</span>
<span class="nc" id="L674">               throw new IndexOutOfBoundsException(</span>
                  &quot;The index &quot; + length + &quot; is out of bounds: maximum is &quot;
                  + (i - 1));
            }

            // we cannot c14nize Comments, and PIs because the c14nizer appends CRs to the String
<span class="nc bnc" id="L680" title="All 2 branches missed.">            if (currentNode.getNodeType() == Node.COMMENT_NODE) {</span>
<span class="nc" id="L681">               baos.write((&quot;&lt;!--&quot; + ((Comment) currentNode).getData()</span>
                           + &quot;--&gt;&quot;).getBytes());
<span class="nc bnc" id="L683" title="All 2 branches missed.">            } else if (currentNode.getNodeType()</span>
                       == Node.PROCESSING_INSTRUCTION_NODE) {
<span class="nc" id="L685">               baos.write((&quot;&lt;?&quot;</span>
                           + ((ProcessingInstruction) currentNode).getTarget()
                           + &quot; &quot;
                           + ((ProcessingInstruction) currentNode).getData()
                           + &quot;?&gt;&quot;).getBytes());
<span class="nc bnc" id="L690" title="All 2 branches missed.">            } else if (currentNode.getNodeType() == Node.TEXT_NODE) {</span>
<span class="nc" id="L691">               baos.write((((Text) currentNode).getData()).getBytes());</span>
            } else {

               // we have to create a new Canonicalizer for each Node because it stores state ;-(
<span class="nc" id="L695">               Canonicalizer c14n =</span>
                  Canonicalizer
                     .getInstance(Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS);

<span class="nc" id="L699">               baos.write(c14n.canonicalize(currentNode));</span>
            }

<span class="nc" id="L702">            currentNode = currentNode.getNextSibling();</span>
<span class="nc" id="L703">            i = i + 1;</span>
         }

<span class="nc" id="L706">         Node insertBeforeNode = currentNode;</span>

<span class="nc" id="L708">         plaintext = baos.toByteArray();</span>

<span class="nc" id="L710">         byte ciphertext[] = em.encrypt(plaintext, contentEncryptionKey);</span>

<span class="nc" id="L712">         this.getCipherData().setCipherValue(new CipherValue(this._doc,</span>
                 ciphertext));
<span class="nc" id="L714">         this.setType(EncryptionConstants.TYPE_CONTENT);</span>

<span class="nc" id="L716">         int start = 0;</span>

<span class="nc" id="L718">         for (currentNode = parent.getFirstChild();</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">                 currentNode != firstPlaintextNode;</span>
<span class="nc" id="L720">                 currentNode = currentNode.getNextSibling()) {</span>
<span class="nc" id="L721">            start++;</span>
         }

<span class="nc bnc" id="L724" title="All 2 branches missed.">         for (i = 0; i &lt; length; i++) {</span>
<span class="nc" id="L725">            parent.removeChild(parent.getChildNodes().item(start));</span>
         }

<span class="nc" id="L728">         parent.insertBefore(this._constructionElement, insertBeforeNode);</span>
<span class="nc" id="L729">      } catch (XMLSecurityException ex) {</span>
<span class="nc" id="L730">         throw ex;</span>
<span class="nc" id="L731">      } catch (Exception ex) {</span>
<span class="nc" id="L732">         throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L733">      }</span>
<span class="nc" id="L734">   }</span>

   /**
    * Method decryptAndReplace
    *
    * @param contentDecryptionKey
    * @throws XMLSecurityException
    */
   public void decryptAndReplace(Key contentDecryptionKey)
           throws XMLSecurityException {

<span class="nc" id="L745">      EncryptionMethod em = this.getEncryptionMethod();</span>
<span class="nc" id="L746">      byte ciphertext[] = this.getCipherData().getCipherValue().getCipherText();</span>
<span class="nc" id="L747">      byte plaintext[] = em.decrypt(ciphertext, contentDecryptionKey);</span>

      try {
<span class="nc" id="L750">         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
<span class="nc" id="L751">         String container = &quot;container&quot;;</span>

<span class="nc" id="L753">         baos.write((new String(&quot;&lt;&quot; + container + &quot;&gt;&quot;)).getBytes());</span>
<span class="nc" id="L754">         baos.write(plaintext);</span>
<span class="nc" id="L755">         baos.write((new String(&quot;&lt;/&quot; + container + &quot;&gt;&quot;)).getBytes());</span>

<span class="nc" id="L757">         javax.xml.parsers.DocumentBuilderFactory dbf =</span>
            javax.xml.parsers.DocumentBuilderFactory.newInstance();

<span class="nc" id="L760">         dbf.setNamespaceAware(true);</span>

<span class="nc" id="L762">         javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L763">         Document doc2 =</span>
            db.parse(new java.io.ByteArrayInputStream(baos.toByteArray()));
<span class="nc" id="L765">         Element doc2Elem = doc2.getDocumentElement();</span>
<span class="nc" id="L766">         HelperNodeList newContent = new HelperNodeList();</span>

<span class="nc bnc" id="L768" title="All 2 branches missed.">         for (int i = 0; i &lt; doc2Elem.getChildNodes().getLength(); i++) {</span>
<span class="nc" id="L769">            newContent.appendChild(doc2Elem.getChildNodes().item(i));</span>
         }

<span class="nc" id="L772">         replace(this._constructionElement, newContent);</span>
<span class="nc" id="L773">      } catch (javax.xml.parsers.ParserConfigurationException ex) {</span>
<span class="nc" id="L774">         throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L775">      } catch (java.io.IOException ex) {</span>
<span class="nc" id="L776">         throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L777">      } catch (org.xml.sax.SAXException ex) {</span>
<span class="nc" id="L778">         throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L779">      }</span>
<span class="nc" id="L780">   }</span>

   /**
    * Method main
    *
    * @param unused
    * @throws Exception
    */
   public static void main(String unused[]) throws Exception {

<span class="nc" id="L790">      org.apache.xml.security.Init.init();</span>

<span class="nc" id="L792">      javax.xml.parsers.DocumentBuilderFactory dbf =</span>
         javax.xml.parsers.DocumentBuilderFactory.newInstance();

<span class="nc" id="L795">      dbf.setNamespaceAware(true);</span>

<span class="nc" id="L797">      javax.xml.parsers.DocumentBuilder db = dbf.newDocumentBuilder();</span>
<span class="nc" id="L798">      Document doc = db.newDocument();</span>
<span class="nc" id="L799">      Element root = doc.createElement(&quot;root&quot;);</span>
<span class="nc" id="L800">      String realContent = &quot;1 USD           &quot;;</span>
<span class="nc" id="L801">      String desired = &quot;999.999.999 EUR &quot;;</span>
<span class="nc" id="L802">      String estimated = realContent;</span>

      {
<span class="nc" id="L805">         root.appendChild(doc.createTextNode(realContent));</span>

         /*
         root.appendChild(doc.createComment(&quot;afasd&quot;));
         root.appendChild(doc.createProcessingInstruction(&quot;sfd&quot;,
                 &quot;d sdf kjghkds &quot;));
         */
<span class="nc" id="L812">         doc.appendChild(doc.createComment(&quot; 0 &quot;));</span>
<span class="nc" id="L813">         doc.appendChild(doc.createComment(&quot; 1 &quot;));</span>
<span class="nc" id="L814">         doc.appendChild(root);</span>
<span class="nc" id="L815">         doc.appendChild(doc.createComment(&quot; 2 &quot;));</span>
<span class="nc" id="L816">         doc.appendChild(doc.createComment(&quot; 3 &quot;));</span>
<span class="nc" id="L817">         System.out.println(</span>
            &quot;------------------------------------------------------------&quot;);
<span class="nc" id="L819">         XMLUtils.outputDOMc14nWithComments(doc, System.out);</span>
<span class="nc" id="L820">         System.out.println();</span>
      }

      Key cek;

      {
<span class="nc" id="L826">         KeyInfo ki = new KeyInfo(doc);</span>

<span class="nc" id="L828">         ki.add(new org.apache.xml.security.keys.content.KeyName(doc,</span>
                 &quot;Christian Geuer-Pollmann&quot;));

<span class="nc" id="L831">         EncryptedData ed =</span>
            new EncryptedData(doc,
                              EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES128,
                              null, ki, null, &quot;myFirstEncryptedElement&quot;);

<span class="nc" id="L836">         cek = ed.createSecretKeyFromBytes(</span>
            org.apache.xml.security.utils.HexDump.hexStringToByteArray(
               &quot;00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f&quot;));

<span class="nc" id="L840">         ed.encryptContentAndReplace(root, cek);</span>

         // ed.encryptElementAndReplace(root, cek);
         // ed.encryptContentAndReplace(doc, cek);
         // ed.encryptContentAndReplace(doc.getChildNodes().item(2), 10, cek);
<span class="nc" id="L845">         System.out.println(</span>
            &quot;------------------------------------------------------------&quot;);
<span class="nc" id="L847">         XMLUtils.outputDOMc14nWithComments(doc, System.out);</span>
<span class="nc" id="L848">         System.out.println();</span>
      }


      {
<span class="nc" id="L853">         org.apache.xpath.CachedXPathAPI xpath =</span>
            new org.apache.xpath.CachedXPathAPI();
<span class="nc" id="L855">         Element nsctx = doc.createElement(&quot;nsctx&quot;);</span>

<span class="nc" id="L857">         nsctx.setAttribute(&quot;xmlns:xenc&quot;, EncryptionConstants.EncryptionSpecNS);</span>

<span class="nc" id="L859">         Element encryptedDataElem = (Element) xpath.selectSingleNode(doc,</span>
                                        &quot;//xenc:EncryptedData&quot;, nsctx);
<span class="nc" id="L861">         EncryptedData ed2 = new EncryptedData(encryptedDataElem, &quot;memory://&quot;);</span>
/*
         byte[] ciphertext =
            ed2.getCipherData().getCipherValue().getCipherText();

         System.out.println(
            &quot;------------------------------------------------------------&quot;);

         {
            for (int i = 0; i &lt; ed2.getEncryptionMethod().getIvLength(); i++) {
               System.out.print(&quot;XXX&quot;);
            }

            System.out.println();
         }

         System.out.println(HexDump.byteArrayToHexString(ciphertext));

         // byte[] newRandom = PRNG.createBytes(overWriteLength);
         int blockSize = ed2.getEncryptionMethod().getBlockSize();
         int ivSize = ed2.getEncryptionMethod().getIvLength();
         int modifyableBytes = ed2.getEncryptionMethod().getBlockSize()
                               - (ed2.getNonce()
                                  % ed2.getEncryptionMethod().getBlockSize());
         byte estimatedBytes[] = estimated.getBytes(&quot;UTF-8&quot;);
         byte desiredBytes[] = desired.getBytes(&quot;UTF-8&quot;);
         int differenceSize = min(modifyableBytes, estimatedBytes.length,
                                  desiredBytes.length);
         byte difference[] = new byte[differenceSize];

         for (int i = 0; i &lt; difference.length; i++) {
            difference[i] = (byte) (estimatedBytes[i] ^ desiredBytes[i]);
         }

         {
            for (int i = 0; i &lt; ed2.getNonce(); i++) {
               System.out.print(&quot;   &quot;);
            }

            System.out.println(HexDump.byteArrayToHexString(difference));
         }

         for (int i = 0; i &lt; difference.length; i++) {
            ciphertext[ed2.getNonce() + i] ^= difference[i];
         }

         System.out.println(HexDump.byteArrayToHexString(ciphertext));
         ed2.getCipherData().getCipherValue().setCipherText(ciphertext);
         XMLUtils.outputDOMc14nWithComments(doc, System.out);
         System.out.println();
         System.out.println(
            &quot;------------------------------------------------------------&quot;);
*/


<span class="nc" id="L916">         ed2.decryptAndReplace(cek);</span>
<span class="nc" id="L917">         System.out.println(</span>
            &quot;------------------------------------------------------------&quot;);
<span class="nc" id="L919">         XMLUtils.outputDOMc14nWithComments(doc, System.out);</span>
<span class="nc" id="L920">         System.out.println();</span>
<span class="nc" id="L921">         System.out.println(</span>
            &quot;------------------------------------------------------------&quot;);
      }
<span class="nc" id="L924">   }</span>

   /**
    * Method min
    *
    * @param a
    * @param b
    * @param c
    * @return
    */
   public static int min(int a, int b, int c) {
<span class="nc" id="L935">      return min(min(a, b), c);</span>
   }

   /**
    * Method min
    *
    * @param a
    * @param b
    * @return
    */
   public static int min(int a, int b) {

<span class="nc bnc" id="L947" title="All 2 branches missed.">      if (a &lt; b) {</span>
<span class="nc" id="L948">         return a;</span>
      }

<span class="nc" id="L951">      return b;</span>
   }

   public String getBaseLocalName() {
<span class="nc" id="L955">      return EncryptionConstants._TAG_ENCRYPTEDDATA;</span>
   }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>