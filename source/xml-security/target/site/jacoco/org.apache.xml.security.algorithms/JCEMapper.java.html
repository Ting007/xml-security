<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JCEMapper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.algorithms</a> &gt; <span class="el_source">JCEMapper.java</span></div><h1>JCEMapper.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.algorithms;



import java.util.*;
import java.security.*;
import org.w3c.dom.*;
import org.apache.xpath.XPathAPI;
import javax.xml.transform.TransformerException;
import org.apache.xml.security.c14n.helper.XPathContainer;
import org.apache.xml.security.utils.*;


/**
 * This class maps algorithm identifier URIs to JAVA JCE class names.
 *
 * @author $Author: dohy $
 */
<span class="nc" id="L77">public class JCEMapper {</span>

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L80">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category.getInstance(JCEMapper.class.getName());

   /** Field _providerList */
<span class="fc" id="L84">   private static Element _providerList = null;</span>

   /** Field _nscontext */
<span class="fc" id="L87">   private static Element _nscontext = null;</span>

   /**
    * Method init
    *
    * @param mappingElement
    * @throws Exception
    */
   public static void init(Element mappingElement) throws Exception {

<span class="fc" id="L97">      JCEMapper._providerList = mappingElement;</span>

<span class="fc" id="L99">      Document doc = mappingElement.getOwnerDocument();</span>

<span class="fc" id="L101">      JCEMapper._nscontext =</span>
         XMLUtils.createDSctx(doc, &quot;x&quot;,
                              &quot;http://www.xmlsecurity.org/NS/#configuration&quot;);
<span class="fc" id="L104">   }</span>

   /**
    * This method takes a Provider ID and tries to register this provider in the JCE.
    *
    * @param Id
    * @return
    */
   public static boolean addProvider(String Id) {

      try {
<span class="fc bfc" id="L115" title="All 2 branches covered.">         if (Security.getProvider(Id) == null) {</span>
<span class="fc" id="L116">            Element providerElem = (Element) XPathAPI.selectSingleNode(</span>
               JCEMapper._providerList,
               &quot;./x:Providers/x:Provider[@Id='&quot; + Id + &quot;']&quot;,
               JCEMapper._nscontext);
<span class="fc" id="L120">            String providerClass = providerElem.getAttribute(&quot;Class&quot;);</span>
<span class="fc" id="L121">            java.security.Provider prov =</span>
               (java.security.Provider) Class.forName(providerClass)
                  .newInstance();

<span class="pc bpc" id="L125" title="1 of 2 branches missed.">            if (java.security.Security.getProvider(Id) == null) {</span>
<span class="fc" id="L126">               cat.debug(&quot;The provider &quot; + Id</span>
                         + &quot; had to be added to the java.security.Security&quot;);
<span class="fc" id="L128">               java.security.Security.addProvider(prov);</span>

<span class="fc" id="L130">               Provider registeredProvider =</span>
                  java.security.Security.getProvider(Id);

<span class="pc bpc" id="L133" title="1 of 2 branches missed.">               if (registeredProvider != null) {</span>
<span class="fc" id="L134">                  return true;</span>
               }
            }
         }
<span class="nc" id="L138">      } catch (TransformerException ex) {}</span>
<span class="nc" id="L139">      catch (ClassNotFoundException ex) {}</span>
<span class="nc" id="L140">      catch (IllegalAccessException ex) {}</span>
<span class="pc" id="L141">      catch (InstantiationException ex) {}</span>

<span class="fc" id="L143">      return false;</span>
   }

   /**
    * Method getProviderIsAvailable
    *
    * @param providerId
    * @return
    */
   public static boolean getProviderIsInClassPath(String providerId) {

<span class="fc" id="L154">      boolean available = false;</span>

      try {
<span class="fc" id="L157">         Element pro =</span>
            (Element) XPathAPI.selectSingleNode(JCEMapper._providerList,
                                                &quot;./x:Providers/x:Provider[@Id='&quot;
                                                + providerId + &quot;']&quot;,
                                                JCEMapper._nscontext);
<span class="fc" id="L162">         String providerClass = pro.getAttribute(&quot;Class&quot;);</span>
<span class="fc" id="L163">         java.security.Provider prov =</span>
            (java.security.Provider) Class.forName(providerClass).newInstance();

<span class="pc bpc" id="L166" title="1 of 2 branches missed.">         if (prov != null) {</span>
<span class="fc" id="L167">            available = true;</span>
         }
<span class="nc" id="L169">      } catch (TransformerException ex) {</span>
         ;
<span class="nc" id="L171">      } catch (ClassNotFoundException ex) {</span>
         ;
<span class="nc" id="L173">      } catch (IllegalAccessException ex) {</span>
         ;
<span class="nc" id="L175">      } catch (InstantiationException ex) {</span>
         ;
<span class="pc" id="L177">      }</span>

<span class="fc" id="L179">      return available;</span>
   }

   /**
    * Return &lt;CODE&gt;true&lt;/CODE&gt; if the Provider with the given
    * &lt;CODE&gt;providerId&lt;/CODE&gt; is available in {@link java.security.Security}.
    *
    * @param providerId
    * @return &lt;CODE&gt;true&lt;/CODE&gt; if the Provider with the given &lt;CODE&gt;providerId&lt;/CODE&gt; is available in {@link java.security.Security}
    */
   public static boolean getProviderIsRegisteredAtSecurity(String providerId) {

<span class="fc" id="L191">      java.security.Provider prov =</span>
         java.security.Security.getProvider(providerId);

<span class="fc bfc" id="L194" title="All 2 branches covered.">      if (prov != null) {</span>
<span class="fc" id="L195">         return true;</span>
      }

<span class="fc" id="L198">      return false;</span>
   }

   /**
    * Method translateURItoJCEID
    *
    * @param AlgorithmURI
    * @return
    */
   public static ProviderIdClass translateURItoJCEID(String AlgorithmURI) {

<span class="fc" id="L209">      cat.debug(&quot;Request for URI &quot; + AlgorithmURI);</span>

      try {

         /*
         Attr jceName = (Attr) XPathAPI.selectSingleNode(
            JCEMapper._providerList,
            &quot;./x:Algorithms/x:Algorithm[@URI='&quot; + AlgorithmURI
            + &quot;']/x:Provider[1]/@JCEName&quot;, JCEMapper._nscontext);
         */
<span class="fc" id="L219">         NodeList providers = XPathAPI.selectNodeList(JCEMapper._providerList,</span>
                                 &quot;./x:Algorithms/x:Algorithm[@URI='&quot;
                                 + AlgorithmURI + &quot;']/x:ProviderAlgo&quot;,
                                 JCEMapper._nscontext);

<span class="pc bpc" id="L224" title="1 of 2 branches missed.">         for (int i = 0; i &lt; providers.getLength(); i++) {</span>
<span class="fc" id="L225">            Element pro = (Element) providers.item(i);</span>
<span class="fc" id="L226">            String jceName = pro.getAttribute(&quot;JCEName&quot;);</span>
<span class="fc" id="L227">            String providerId = pro.getAttribute(&quot;ProviderId&quot;);</span>

<span class="pc bpc" id="L229" title="1 of 2 branches missed.">            if (JCEMapper.getProviderIsInClassPath(providerId)) {</span>
<span class="fc" id="L230">               JCEMapper.addProvider(providerId);</span>

<span class="fc" id="L232">               ProviderIdClass result = new ProviderIdClass(jceName,</span>
                                           providerId);

<span class="fc" id="L235">               cat.debug(&quot;Found &quot; + result.getAlgorithmID() + &quot; from provider &quot;</span>
                         + result.getProviderId());

<span class="fc" id="L238">               return result;</span>
            }
         }
<span class="nc" id="L241">      } catch (TransformerException ex) {</span>
<span class="nc" id="L242">         cat.debug(&quot;Found nothing: &quot; + ex.getMessage());</span>
<span class="nc" id="L243">      }</span>

<span class="nc" id="L245">      return null;</span>
   }

   /**
    * Method translateURItoJCEID
    *
    * @param AlgorithmURI
    * @param requestedProviderId
    * @return
    */
   public static ProviderIdClass translateURItoJCEID(String AlgorithmURI,
           String requestedProviderId) {

<span class="fc" id="L258">      cat.debug(&quot;Request for URI &quot; + AlgorithmURI + &quot; from provider &quot;</span>
                + requestedProviderId);

<span class="pc bpc" id="L261" title="1 of 2 branches missed.">      if (!JCEMapper.getProviderIsInClassPath(requestedProviderId)) {</span>
<span class="nc" id="L262">         return null;</span>
      }

      try {
<span class="fc" id="L266">         Element pro = (Element) XPathAPI.selectSingleNode(</span>
            JCEMapper._providerList,
            &quot;./x:Algorithms/x:Algorithm[@URI='&quot; + AlgorithmURI
            + &quot;']/x:ProviderAlgo[@ProviderId='&quot; + requestedProviderId + &quot;']&quot;,
            JCEMapper._nscontext);
<span class="fc" id="L271">         String jceName = pro.getAttribute(&quot;JCEName&quot;);</span>

<span class="fc" id="L273">         JCEMapper.addProvider(requestedProviderId);</span>

<span class="fc" id="L275">         ProviderIdClass result = new ProviderIdClass(jceName,</span>
                                     requestedProviderId);

<span class="fc" id="L278">         cat.debug(&quot;Found &quot; + result.getAlgorithmID() + &quot; from provider &quot;</span>
                   + result.getProviderId());

<span class="fc" id="L281">         return result;</span>
<span class="nc" id="L282">      } catch (TransformerException ex) {</span>
<span class="nc" id="L283">         cat.debug(&quot;Found nothing: &quot; + ex.getMessage());</span>
      }

<span class="nc" id="L286">      return null;</span>
   }

   /**
    * Method getAlgorithmClassFromURI
    *
    * @param AlgorithmURI
    * @return
    */
   public static String getAlgorithmClassFromURI(String AlgorithmURI) {

<span class="nc" id="L297">      cat.debug(&quot;Request for URI &quot; + AlgorithmURI);</span>

      try {
<span class="nc" id="L300">         NodeList providers = XPathAPI.selectNodeList(JCEMapper._providerList,</span>
                                 &quot;./x:Algorithms/x:Algorithm[@URI='&quot;
                                 + AlgorithmURI + &quot;']/x:ProviderAlgo&quot;,
                                 JCEMapper._nscontext);

<span class="nc bnc" id="L305" title="All 2 branches missed.">         for (int i = 0; i &lt; providers.getLength(); i++) {</span>
<span class="nc" id="L306">            Element pro = (Element) providers.item(i);</span>
<span class="nc" id="L307">            Attr jceName = pro.getAttributeNode(&quot;JCEName&quot;);</span>

<span class="nc" id="L309">            cat.debug(&quot;Found &quot; + jceName.getNodeValue());</span>
         }

<span class="nc" id="L312">         return ((Element) providers.item(0)).getAttribute(&quot;JCEName&quot;);</span>
<span class="nc" id="L313">      } catch (TransformerException ex) {</span>
<span class="nc" id="L314">         cat.debug(&quot;Found nothing: &quot; + ex.getMessage());</span>

<span class="nc" id="L316">         return &quot;&quot;;</span>
      }
   }

   /**
    * Method getKeyTypeFromURI
    *
    * @param AlgorithmURI
    * @return
    */
   public static int getKeyTypeFromURI(String AlgorithmURI) {

      try {
<span class="fc" id="L329">         Attr algoclassAttr =</span>
            (Attr) XPathAPI.selectSingleNode(JCEMapper._providerList,
                                             &quot;./x:Algorithms/x:Algorithm[@URI='&quot;
                                             + AlgorithmURI
                                             + &quot;']/@AlgorithmClass&quot;, JCEMapper
                                                ._nscontext);

<span class="pc bpc" id="L336" title="1 of 2 branches missed.">         if (algoclassAttr == null) {</span>
<span class="nc" id="L337">            return -1;</span>
         } else {
<span class="fc" id="L339">            String algoclass = algoclassAttr.getNodeValue();</span>

<span class="pc bpc" id="L341" title="1 of 2 branches missed.">            if (algoclass.equals(JCEMapper.KEYTYPE_BLOCK_ENCRYPTION)) {</span>
<span class="fc" id="L342">               return javax.crypto.Cipher.SECRET_KEY;</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            } else if (algoclass.equals(&quot;Mac&quot;)) {</span>
<span class="nc" id="L344">               return javax.crypto.Cipher.SECRET_KEY;</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">            } else if (algoclass.equals(JCEMapper.KEYTYPE_SYMMETRIC_KEY_WRAP)) {</span>
<span class="nc" id="L346">               return javax.crypto.Cipher.SECRET_KEY;</span>
            }
         }
<span class="nc" id="L349">      } catch (TransformerException ex) {</span>
<span class="nc" id="L350">         cat.debug(&quot;Found nothing: &quot; + ex.getMessage());</span>
<span class="nc" id="L351">      }</span>

<span class="nc" id="L353">      return -1;</span>
   }

   /**
    * Returns the keylength in bit for a particular algorithm.
    *
    * @param AlgorithmURI
    * @return
    */
   public static int getKeyLengthFromURI(String AlgorithmURI) {

      try {
<span class="nc" id="L365">         Attr algoclassAttr =</span>
            (Attr) XPathAPI.selectSingleNode(JCEMapper._providerList,
                                             &quot;./x:Algorithms/x:Algorithm[@URI='&quot;
                                             + AlgorithmURI + &quot;']/@KeyLength&quot;,
                                             JCEMapper._nscontext);

<span class="nc bnc" id="L371" title="All 2 branches missed.">         if (algoclassAttr != null) {</span>
<span class="nc" id="L372">            return Integer.parseInt(algoclassAttr.getNodeValue());</span>
         }
<span class="nc" id="L374">      } catch (TransformerException ex) {</span>
<span class="nc" id="L375">         cat.debug(&quot;Found nothing: &quot; + ex.getMessage());</span>
<span class="nc" id="L376">      }</span>

<span class="nc" id="L378">      return 0;</span>
   }

   /**
    * Method getJCEKeyAlgorithmFromURI
    *
    * @param AlgorithmURI
    * @param ProviderId
    * @return
    */
   public static String getJCEKeyAlgorithmFromURI(String AlgorithmURI,
           String ProviderId) {

      try {
<span class="nc" id="L392">         Attr algoclassAttr =</span>
            (Attr) XPathAPI.selectSingleNode(JCEMapper._providerList,
                                             &quot;./x:Algorithms/x:Algorithm[@URI='&quot;
                                             + AlgorithmURI
                                             + &quot;']/x:ProviderAlgo[@ProviderId='&quot;
                                             + ProviderId + &quot;']/@RequiredKey&quot;,
                                             JCEMapper._nscontext);

<span class="nc bnc" id="L400" title="All 2 branches missed.">         if (algoclassAttr != null) {</span>
<span class="nc" id="L401">            return algoclassAttr.getNodeValue();</span>
         }
<span class="nc" id="L403">      } catch (TransformerException ex) {</span>
<span class="nc" id="L404">         cat.debug(&quot;Found nothing: &quot; + ex.getMessage());</span>
<span class="nc" id="L405">      }</span>

<span class="nc" id="L407">      return null;</span>
   }


   public static String getJCEIVAlgorithmFromURI(String AlgorithmURI,
           String ProviderId) {

      try {
<span class="nc" id="L415">         Attr algoclassAttr =</span>
            (Attr) XPathAPI.selectSingleNode(JCEMapper._providerList,
                                             &quot;./x:Algorithms/x:Algorithm[@URI='&quot;
                                             + AlgorithmURI
                                             + &quot;']/x:ProviderAlgo[@ProviderId='&quot;
                                             + ProviderId + &quot;']/@IVJCEName&quot;,
                                             JCEMapper._nscontext);

<span class="nc bnc" id="L423" title="All 2 branches missed.">         if (algoclassAttr != null) {</span>
<span class="nc" id="L424">            return algoclassAttr.getNodeValue();</span>
         }
<span class="nc" id="L426">      } catch (TransformerException ex) {</span>
<span class="nc" id="L427">         cat.debug(&quot;Found nothing: &quot; + ex.getMessage());</span>
<span class="nc" id="L428">      }</span>

<span class="nc" id="L430">      return null;</span>
   }

   /** Field KEYTYPE_SYMMETRIC_KEY_WRAP           */
   public static final String KEYTYPE_SYMMETRIC_KEY_WRAP = &quot;SymmetricKeyWrap&quot;;

   /** Field KEYTYPE_BLOCK_ENCRYPTION           */
   public static final String KEYTYPE_BLOCK_ENCRYPTION = &quot;BlockEncryption&quot;;

   /** Field KEYTYPE_KEY_TRANSPORT           */
   public static final String KEYTYPE_KEY_TRANSPORT = &quot;KeyTransport&quot;;

   /**
    * This takes a {@link Key} and one of the &lt;CODE&gt;JCEMapper.KEYTYPE_XXX&lt;/CODE&gt;
    * Strings and returns the algorithm for which this key is.
    * &lt;BR /&gt;
    * Example: If you enter an AES Key of length 128 bit and the
    * &lt;CODE&gt;JCEMapper.KEYTYPE_SYMMETRIC_KEY_WRAP&lt;/CODE&gt;, the result is
    * &lt;CODE&gt;EncryptionConstants.ALGO_ID_BLOCKCIPHER_AES128&lt;/CODE&gt;.
    *
    *
    * @param key
    * @param type
    * @return
    */
   public static String getURIfromKey(Key key, String type) {

<span class="fc" id="L457">      String JCEalgo = key.getAlgorithm();</span>
<span class="fc" id="L458">      String keyLength = new Integer(key.getEncoded().length * 8).toString();</span>

      try {
<span class="fc" id="L461">         Attr URI = (Attr) XPathAPI.selectSingleNode(</span>
            JCEMapper._providerList,
            &quot;./x:Algorithms/x:Algorithm[@KeyLength='&quot; + keyLength
            + &quot;' and @AlgorithmClass='&quot; + type
            + &quot;']/x:ProviderAlgo[@RequiredKey='&quot; + JCEalgo + &quot;']/../@URI&quot;,
            JCEMapper._nscontext);

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">         if (URI != null) {</span>
<span class="fc" id="L469">            return URI.getNodeValue();</span>
         }
<span class="nc" id="L471">      } catch (TransformerException ex) {</span>
<span class="nc" id="L472">         cat.debug(&quot;Found nothing: &quot; + ex.getMessage());</span>
<span class="nc" id="L473">      }</span>

<span class="nc" id="L475">      return null;</span>
   }

   /*
   public static String getWrapURIfromKey(Key key) {
      return JCEMapper.getURIfromKey(key, JCEMapper.KEYTYPE_SYMMETRIC_KEY_WRAP);
   }

   public static String getCipherURIfromKey(Key key) {
      return JCEMapper.getURIfromKey(key, JCEMapper.KEYTYPE_BLOCK_ENCRYPTION);
   }
   */

   /**
    * Class ProviderIdClass
    *
    * @author $Author: dohy $
    * @version $Revision: 1.1.1.1 $
    */
<span class="nc" id="L494">   public static class ProviderIdClass {</span>

      /** Field _jceid */
      private String _algorithmId;

      /** Field _providerClass */
      private String _providerId;

      /**
       * Constructor ProviderIdClass
       *
       * @param AlgorithmID
       * @param ProviderId
       */
<span class="fc" id="L508">      protected ProviderIdClass(String AlgorithmID, String ProviderId) {</span>
<span class="fc" id="L509">         this._algorithmId = AlgorithmID;</span>
<span class="fc" id="L510">         this._providerId = ProviderId;</span>
<span class="fc" id="L511">      }</span>

      /**
       * Method getJceId
       *
       * @return
       */
      public String getAlgorithmID() {
<span class="fc" id="L519">         return this._algorithmId;</span>
      }

      /**
       * Method getProvider
       *
       * @return
       */
      public String getProviderId() {
<span class="fc" id="L528">         return this._providerId;</span>
      }
   }

   static {
<span class="fc" id="L533">      org.apache.xml.security.Init.init();</span>
<span class="fc" id="L534">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>