<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EncryptionMethod.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.algorithms.encryption</a> &gt; <span class="el_source">EncryptionMethod.java</span></div><h1>EncryptionMethod.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.algorithms.encryption;



import java.io.IOException;
import java.security.*;
import java.security.spec.*;
import java.util.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import javax.xml.transform.TransformerException;
import org.apache.xml.security.algorithms.Algorithm;
import org.apache.xml.security.algorithms.encryption.params
   .EncryptionMethodParams;
import org.apache.xml.security.algorithms.JCEMapper;
import org.apache.xml.security.algorithms.MessageDigestAlgorithm;
import org.apache.xml.security.exceptions.AlgorithmAlreadyRegisteredException;
import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.utils.*;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.*;


/**
 * This is the representation of an &lt;CODE&gt;xenc:EncryptionMethod&lt;/CODE&gt;
 * element. It's additionally the factory for encryption/wrap/transport
 * algorithms.
 *
 * @author $Author: dohy $
 */
public class EncryptionMethod extends Algorithm {

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L92">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category.getInstance(EncryptionMethod.class.getName());

   /** Field _emSpi */
<span class="pc" id="L96">   EncryptionMethodSpi _emSpi = null;</span>

   /** Field _encMethodParams */
<span class="pc" id="L99">   EncryptionMethodParams _encMethodParams = null;</span>

   /**
    * Method getBaseNamespace
    *
    * @return
    */
   public String getBaseNamespace() {
<span class="fc" id="L107">      return EncryptionConstants.EncryptionSpecNS;</span>
   }

   /**
    * Method getBaseLocalName
    *
    * @return
    */
   public String getBaseLocalName() {
<span class="fc" id="L116">      return EncryptionConstants._TAG_ENCRYPTIONMETHOD;</span>
   }

   /**
    * Constructor EncryptionMethod
    *
    * @param doc
    * @param algorithmURI
    * @throws XMLSecurityException
    */
   public EncryptionMethod(Document doc, String algorithmURI)
           throws XMLSecurityException {
<span class="fc" id="L128">      this(doc, algorithmURI, null);</span>
<span class="fc" id="L129">   }</span>

   /**
    * Method getUsableInEncryptedData
    *
    * @return
    */
   public boolean getUsableInEncryptedData() {

<span class="nc" id="L138">      int type = this._emSpi.getImplementedAlgorithmType();</span>

<span class="nc bnc" id="L140" title="All 6 branches missed.">      switch (type) {</span>

      case EncryptionMethodSpi.ALGOTYPE_BLOCK_ENCRYPTION :
<span class="nc" id="L143">         return true;</span>

      case EncryptionMethodSpi.ALGOTYPE_STREAM_ENCRYPTION :
<span class="nc" id="L146">         return true;</span>

      case EncryptionMethodSpi.ALGOTYPE_SYMMETRIC_KEY_WRAP :
<span class="nc" id="L149">         return false;</span>

      case EncryptionMethodSpi.ALGOTYPE_KEY_TRANSPORT :
<span class="nc" id="L152">         return false;</span>

      case EncryptionMethodSpi.ALGOTYPE_KEY_AGREEMENT :
<span class="nc" id="L155">         return false;</span>

      default :
<span class="nc" id="L158">         return false;</span>
      }
   }

   /**
    * Method getUsableInEncryptedKey
    *
    * @return
    */
   public boolean getUsableInEncryptedKey() {

<span class="nc" id="L169">      int type = this._emSpi.getImplementedAlgorithmType();</span>

<span class="nc bnc" id="L171" title="All 6 branches missed.">      switch (type) {</span>

      case EncryptionMethodSpi.ALGOTYPE_BLOCK_ENCRYPTION :
<span class="nc" id="L174">         return false;</span>

      case EncryptionMethodSpi.ALGOTYPE_STREAM_ENCRYPTION :
<span class="nc" id="L177">         return false;</span>

      case EncryptionMethodSpi.ALGOTYPE_SYMMETRIC_KEY_WRAP :
<span class="nc" id="L180">         return true;</span>

      case EncryptionMethodSpi.ALGOTYPE_KEY_TRANSPORT :
<span class="nc" id="L183">         return true;</span>

      case EncryptionMethodSpi.ALGOTYPE_KEY_AGREEMENT :
<span class="nc" id="L186">         return true;</span>

      default :
<span class="nc" id="L189">         return false;</span>
      }
   }

   /**
    * Constructor EncryptionMethod
    *
    * @param doc
    * @param algorithmURI
    * @param params
    * @throws XMLSecurityException
    */
   public EncryptionMethod(
           Document doc, String algorithmURI, EncryptionMethodParams params)
              throws XMLSecurityException {

<span class="fc" id="L205">      super(doc, algorithmURI);</span>

<span class="fc" id="L207">      Vector v = (Vector) this._algorithmHash.get(algorithmURI);</span>

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">      if (v == null) {</span>
<span class="nc" id="L210">         Object exArgs[] = { &quot;Could not find a registered Provider&quot; };</span>

<span class="nc" id="L212">         throw new XMLSecurityException(&quot;empty&quot;);</span>
      }

<span class="pc bpc" id="L215" title="1 of 2 branches missed.">      searchForWorkingClass: for (int i = 0; i &lt; v.size(); i++) {</span>
         try {
<span class="fc" id="L217">            String implementingClass = (String) v.elementAt(i);</span>

<span class="fc" id="L219">            this._emSpi =</span>
               (EncryptionMethodSpi) Class.forName(implementingClass)
                  .newInstance();

<span class="pc bpc" id="L223" title="2 of 4 branches missed.">            if ((this._emSpi != null)</span>
                    &amp;&amp; this._emSpi.getRequiredProviderAvailable()) {
<span class="fc" id="L225">               cat.debug(&quot;Create URI \&quot;&quot; + algorithmURI + &quot;\&quot; class \&quot;&quot;</span>
                         + implementingClass + &quot;\&quot;&quot;);

<span class="fc" id="L228">               break searchForWorkingClass;</span>
            }
<span class="nc" id="L230">         } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L231">            throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L232">         } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L233">            throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L234">         } catch (InstantiationException ex) {</span>
<span class="nc" id="L235">            throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L236">         }</span>
      }

<span class="pc bpc" id="L239" title="1 of 2 branches missed.">      if (this._emSpi == null) {</span>
<span class="nc" id="L240">         Object exArgs[] = { &quot;Could not find a registered Provider&quot; };</span>

<span class="nc" id="L242">         throw new XMLSecurityException(&quot;empty&quot;);</span>
      }

<span class="fc" id="L245">      this._encMethodParams = this._emSpi.engineInit(doc, params);</span>

<span class="pc bpc" id="L247" title="1 of 2 branches missed.">      if (this._encMethodParams != null) {</span>
<span class="nc" id="L248">         this._constructionElement</span>
            .appendChild(this._encMethodParams.createChildNodes(this._doc));
      }
<span class="fc" id="L251">   }</span>

   /**
    * Constructor EncryptionMethod
    *
    * @param element
    * @param BaseURI
    * @throws XMLSecurityException
    */
   public EncryptionMethod(Element element, String BaseURI)
           throws XMLSecurityException {

<span class="nc" id="L263">      super(element, BaseURI);</span>

<span class="nc" id="L265">      String algorithmURI = this.getAlgorithmURI();</span>
<span class="nc" id="L266">      Vector v = (Vector) this._algorithmHash.get(algorithmURI);</span>

<span class="nc bnc" id="L268" title="All 2 branches missed.">      if (v == null) {</span>
<span class="nc" id="L269">         Object exArgs[] = { &quot;Could not find a registered Provider&quot; };</span>

<span class="nc" id="L271">         throw new XMLSecurityException(&quot;empty&quot;);</span>
      }

<span class="nc bnc" id="L274" title="All 2 branches missed.">      searchForWorkingClass: for (int i = 0; i &lt; v.size(); i++) {</span>
         try {
<span class="nc" id="L276">            String implementingClass = (String) v.elementAt(i);</span>

<span class="nc" id="L278">            this._emSpi =</span>
               (EncryptionMethodSpi) Class.forName(implementingClass)
                  .newInstance();

<span class="nc bnc" id="L282" title="All 4 branches missed.">            if ((this._emSpi != null)</span>
                    &amp;&amp; this._emSpi.getRequiredProviderAvailable()) {
<span class="nc" id="L284">               cat.debug(&quot;Create URI \&quot;&quot; + algorithmURI + &quot;\&quot; class \&quot;&quot;</span>
                         + implementingClass + &quot;\&quot;&quot;);

<span class="nc" id="L287">               break searchForWorkingClass;</span>
            }
<span class="nc" id="L289">         } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L290">            throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L291">         } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L292">            throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L293">         } catch (InstantiationException ex) {</span>
<span class="nc" id="L294">            throw new XMLSecurityException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L295">         }</span>
      }

<span class="nc bnc" id="L298" title="All 2 branches missed.">      if (this._emSpi == null) {</span>
<span class="nc" id="L299">         Object exArgs[] = { &quot;Could not find a registered Provider&quot; };</span>

<span class="nc" id="L301">         throw new XMLSecurityException(&quot;empty&quot;);</span>
      }

<span class="nc" id="L304">      this._encMethodParams = this._emSpi.engineInit(this._constructionElement);</span>
<span class="nc" id="L305">   }</span>

   /**
    * Method wrap
    *
    * @param contentKey
    * @param wrapKey
    * @return
    * @throws XMLSecurityException
    */
   public byte[] wrap(Key contentKey, Key wrapKey) throws XMLSecurityException {
<span class="nc" id="L316">      return this._emSpi.engineWrap(contentKey, wrapKey);</span>
   }

   /**
    * Method wrap
    *
    * @param contentKey
    * @param wrapKey
    * @param IV
    * @return
    * @throws XMLSecurityException
    */
   public byte[] wrap(Key contentKey, Key wrapKey, byte[] IV)
           throws XMLSecurityException {
<span class="fc" id="L330">      return this._emSpi.engineWrap(contentKey, wrapKey, IV);</span>
   }

   /**
    * Method unwrap
    *
    * @param wrappedKey
    * @param wrapKey
    * @param wrappedKeyAlgoURI
    * @return
    * @throws XMLSecurityException
    */
   public Key unwrap(byte[] wrappedKey, Key wrapKey, String wrappedKeyAlgoURI)
           throws XMLSecurityException {
<span class="fc" id="L344">      return this._emSpi.engineUnwrap(wrappedKey, wrapKey, wrappedKeyAlgoURI);</span>
   }

   /**
    * Method encrypt
    *
    * @param plaintextBytes
    * @param contentKey
    * @return
    * @throws XMLSecurityException
    */
   public byte[] encrypt(byte[] plaintextBytes, Key contentKey)
           throws XMLSecurityException {
<span class="nc" id="L357">      return this._emSpi.engineEncrypt(plaintextBytes, contentKey);</span>
   }

   /**
    * Method encrypt
    *
    * @param plaintextBytes
    * @param contentKey
    * @param IV
    * @return
    * @throws XMLSecurityException
    */
   public byte[] encrypt(byte[] plaintextBytes, Key contentKey, byte[] IV)
           throws XMLSecurityException {
<span class="fc" id="L371">      return this._emSpi.engineEncrypt(plaintextBytes, contentKey, IV);</span>
   }

   /**
    * Method decrypt
    *
    * @param ciphertextBytes
    * @param contentKey
    * @return
    * @throws XMLSecurityException
    */
   public byte[] decrypt(byte[] ciphertextBytes, Key contentKey)
           throws XMLSecurityException {
<span class="fc" id="L384">      return this._emSpi.engineDecrypt(ciphertextBytes, contentKey);</span>
   }

   /**
    * Method getParams
    *
    * @return
    */
   public EncryptionMethodParams getParams() {
<span class="nc" id="L393">      return this._encMethodParams;</span>
   }

   /**
    * Method getIvLength
    *
    * @return
    */
   public int getIvLength() {
<span class="nc" id="L402">      return this._emSpi.engineGetIvLength();</span>
   }

   /**
    * Method getBlockSize
    *
    * @return
    */
   public int getBlockSize() {
<span class="fc" id="L411">      return this._emSpi.engineGetBlockSize();</span>
   }

   /**
    * Method createSecretKeyFromBytes
    *
    * @param encodedKey
    * @return
    * @throws XMLSecurityException
    */
   public Key createSecretKeyFromBytes(byte encodedKey[])
           throws XMLSecurityException {

<span class="nc" id="L424">      String JceAlgo =</span>
         JCEMapper
            .getJCEKeyAlgorithmFromURI(this._emSpi
               .getImplementedAlgorithmURI(), this._emSpi
               .getRequiredProviderName());

<span class="nc" id="L430">      return new SecretKeySpec(encodedKey, JceAlgo);</span>
   }

   /** Field _alreadyInitialized */
<span class="fc" id="L434">   static boolean _alreadyInitialized = false;</span>

   /** All available algorithm classes are registered here */
<span class="fc" id="L437">   static HashMap _algorithmHash = null;</span>

   /**
    * Method providerInit
    *
    */
   public static void providerInit() {

<span class="pc bpc" id="L445" title="1 of 2 branches missed.">      if (EncryptionMethod.cat == null) {</span>
<span class="nc" id="L446">         EncryptionMethod.cat =</span>
            org.apache.log4j.Category
               .getInstance(EncryptionMethod.class.getName());
      }

<span class="fc" id="L451">      cat.debug(&quot;Init() called&quot;);</span>

<span class="pc bpc" id="L453" title="1 of 2 branches missed.">      if (!EncryptionMethod._alreadyInitialized) {</span>
<span class="fc" id="L454">         EncryptionMethod._algorithmHash = new HashMap(10);</span>
<span class="fc" id="L455">         EncryptionMethod._alreadyInitialized = true;</span>
      }
<span class="fc" id="L457">   }</span>

   /**
    * Method register
    *
    * @param algorithmURI
    * @param implementingClass
    * @return
    */
   public static boolean register(String algorithmURI,
                                  String implementingClass) {

<span class="fc" id="L469">      Vector v = (Vector) EncryptionMethod._algorithmHash.get(algorithmURI);</span>

<span class="pc bpc" id="L471" title="1 of 2 branches missed.">      if (v == null) {</span>
<span class="fc" id="L472">         v = new Vector();</span>

<span class="fc" id="L474">         EncryptionMethod._algorithmHash.put(algorithmURI, v);</span>
      }

      try {
<span class="fc" id="L478">         Class c = Class.forName(implementingClass);</span>

         // System.out.println(c.getSuperclass().getSuperclass().getName());
<span class="pc bpc" id="L481" title="1 of 2 branches missed.">         if (c != null) {</span>
<span class="fc" id="L482">            EncryptionMethodSpi emSpi = (EncryptionMethodSpi) c.newInstance();</span>

<span class="pc bpc" id="L484" title="1 of 2 branches missed.">            if (emSpi.getRequiredProviderAvailable()) {</span>
<span class="fc" id="L485">               v.add(implementingClass);</span>

<span class="fc" id="L487">               return true;</span>
            } else {
<span class="nc" id="L489">               cat.debug(&quot;Try to register class &quot; + implementingClass</span>
                         + &quot; but Provider &quot; + emSpi.getRequiredProviderName()
                         + &quot; not available&quot;);
            }
<span class="nc" id="L493">         } else {</span>
<span class="nc" id="L494">            cat.debug(&quot;Try to register class &quot; + implementingClass</span>
                      + &quot; but Class not available&quot;);
         }
<span class="nc" id="L497">      } catch (ClassNotFoundException ex) {</span>
<span class="nc" id="L498">         cat.debug(&quot;Try to register class &quot; + implementingClass</span>
                   + &quot; but Class not found: &quot;, ex);
<span class="nc" id="L500">      } catch (IllegalAccessException ex) {</span>
<span class="nc" id="L501">         cat.debug(&quot;Try to register class &quot; + implementingClass</span>
                   + &quot; but Class not found: &quot;, ex);
<span class="nc" id="L503">      } catch (InstantiationException ex) {</span>
<span class="nc" id="L504">         cat.debug(&quot;Try to register class &quot; + implementingClass</span>
                   + &quot; but Class not found: &quot;, ex);
<span class="nc" id="L506">      }</span>

<span class="nc" id="L508">      return false;</span>
   }

   //J-
   public String encryptB64(byte[] plaintextBytes, Key contentKey, byte[] IV) throws XMLSecurityException {
<span class="nc" id="L513">       byte ciphertextBytes[] = this.encrypt(plaintextBytes, contentKey, IV);</span>
<span class="nc" id="L514">       return Base64.encode(ciphertextBytes);</span>
   }
   public String encryptB64(byte[] plaintextBytes, Key contentKey) throws XMLSecurityException {
<span class="nc" id="L517">       byte ciphertextBytes[] = this.encrypt(plaintextBytes, contentKey);</span>
<span class="nc" id="L518">       return Base64.encode(ciphertextBytes);</span>
   }
   public byte[] decryptB64(String ciphertext, Key contentKey) throws XMLSecurityException {
<span class="nc" id="L521">       byte ciphertextBytes[] = Base64.decode(ciphertext);</span>
<span class="nc" id="L522">       return this.decrypt(ciphertextBytes, contentKey);</span>
   }
   public String wrapB64(Key contentKey, Key wrapKey) throws XMLSecurityException {
<span class="nc" id="L525">       byte wrappedKeyBytes[] = this.wrap(contentKey, wrapKey);</span>
<span class="nc" id="L526">       return Base64.encode(wrappedKeyBytes);</span>
   }
   public String wrapB64(Key contentKey, Key wrapKey, byte[] IV) throws XMLSecurityException {
<span class="nc" id="L529">       byte wrappedKeyBytes[] = this.wrap(contentKey, wrapKey, IV);</span>
<span class="nc" id="L530">       return Base64.encode(wrappedKeyBytes);</span>
   }
   public Key unwrapB64(String wrappedKey, Key wrapKey, String wrappedKeyAlgoURI) throws XMLSecurityException {
<span class="nc" id="L533">       byte wrappedKeyBytes[] = Base64.decode(wrappedKey);</span>
<span class="nc" id="L534">       return this.unwrap(wrappedKeyBytes, wrapKey, wrappedKeyAlgoURI);</span>
   }

   //J+
   static {
<span class="fc" id="L539">      org.apache.xml.security.Init.init();</span>
<span class="fc" id="L540">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>