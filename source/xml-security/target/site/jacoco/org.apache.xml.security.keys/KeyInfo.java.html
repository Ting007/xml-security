<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>KeyInfo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.keys</a> &gt; <span class="el_source">KeyInfo.java</span></div><h1>KeyInfo.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.keys;



import java.lang.reflect.*;
import java.security.*;
import java.security.cert.*;
import java.security.spec.*;
import java.util.*;
import javax.crypto.SecretKey;
import javax.xml.transform.TransformerException;
import org.apache.xpath.XPathAPI;
import org.w3c.dom.*;
import org.apache.xml.security.c14n.*;
import org.apache.xml.security.transforms.params.XPathContainer;
import org.apache.xml.security.exceptions.XMLSecurityException;
import org.apache.xml.security.keys.content.*;
import org.apache.xml.security.keys.content.keyvalues.*;
import org.apache.xml.security.keys.keyresolver.*;
import org.apache.xml.security.keys.storage.*;
import org.apache.xml.security.utils.*;
import org.apache.xml.security.transforms.*;
import org.apache.xml.security.Init;


/**
 * This class stand for KeyInfo Element that may contain keys, names,
 * certificates and other public key management information,
 * such as in-band key distribution or key agreement data.
 * &lt;BR /&gt;
 * KeyInfo Element has two basic functions:
 * One is KeyResolve for getting the public key in signature validation processing.
 * the other one is toElement for getting the element in signature generation processing.
 * &lt;BR /&gt;
 * The &lt;CODE&gt;lengthXXX()&lt;/CODE&gt; methods provide access to the internal Key
 * objects:
 * &lt;UL&gt;
 * &lt;LI&gt;If the &lt;CODE&gt;KeyInfo&lt;/CODE&gt; was constructed from an Element
 * (Signature verification), the &lt;CODE&gt;lengthXXX()&lt;/CODE&gt; methods searches
 * for child elements of &lt;CODE&gt;ds:KeyInfo&lt;/CODE&gt; for known types. &lt;/LI&gt;
 * &lt;LI&gt;If the &lt;CODE&gt;KeyInfo&lt;/CODE&gt; was constructed from scratch (during
 * Signature generation), the &lt;CODE&gt;lengthXXX()&lt;/CODE&gt; methods return the number
 * of &lt;CODE&gt;XXX&lt;/CODE&gt; objects already passed to the KeyInfo&lt;/LI&gt;
 * &lt;/UL&gt;
 * &lt;BR /&gt;
 * The &lt;CODE&gt;addXXX()&lt;/CODE&gt; methods are used for adding Objects of the
 * appropriate type to the &lt;CODE&gt;KeyInfo&lt;/CODE&gt;. This is used during signature
 * generation.
 * &lt;BR /&gt;
 * The &lt;CODE&gt;itemXXX(int i)&lt;/CODE&gt; methods return the i'th object of the
 * corresponding type.
 * &lt;BR /&gt;
 * The &lt;CODE&gt;containsXXX()&lt;/CODE&gt; methods return &lt;I&gt;whether&lt;/I&gt; the KeyInfo
 * contains the corresponding type.
 *
 * @author $Author: dohy $
 */
public class KeyInfo extends SignatureElementProxy {

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L119">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category.getInstance(KeyInfo.class.getName());

   /** Field _dsns */
<span class="pc" id="L123">   Element _dsns = null;</span>

   /**
    * Constructor KeyInfo
    * @param doc
    */
   public KeyInfo(Document doc) {

<span class="nc" id="L131">      super(doc);</span>

<span class="nc" id="L133">      XMLUtils.addReturnToElement(this._constructionElement);</span>

<span class="nc" id="L135">      this._dsns = XMLUtils.createDSctx(this._doc, &quot;ds&quot;,</span>
                                        Constants.SignatureSpecNS);
<span class="nc" id="L137">   }</span>

   /**
    * Constructor KeyInfo
    *
    * @param element
    * @param BaseURI
    * @throws XMLSecurityException
    */
   public KeyInfo(Element element, String BaseURI) throws XMLSecurityException {

<span class="fc" id="L148">      super(element, BaseURI);</span>

<span class="fc" id="L150">      this._dsns = XMLUtils.createDSctx(this._doc, &quot;ds&quot;,</span>
                                        Constants.SignatureSpecNS);
<span class="fc" id="L152">   }</span>

   /**
    * Sets the &lt;code&gt;Id&lt;/code&gt; attribute
    *
    * @param Id ID
    */
   public void setId(String Id) {

<span class="nc bnc" id="L161" title="All 4 branches missed.">      if ((this._state == MODE_SIGN) &amp;&amp; (Id != null)) {</span>
<span class="nc" id="L162">         this._constructionElement.setAttributeNS(null, Constants._ATT_ID, Id);</span>
<span class="nc" id="L163">         IdResolver.registerElementById(this._constructionElement, Id);</span>
      }
<span class="nc" id="L165">   }</span>

   /**
    * Returns the &lt;code&gt;Id&lt;/code&gt; attribute
    *
    * @return the &lt;code&gt;Id&lt;/code&gt; attribute
    */
   public String getId() {
<span class="nc" id="L173">      return this._constructionElement.getAttributeNS(null, Constants._ATT_ID);</span>
   }

   /**
    * Method addKeyName
    *
    * @param keynameString
    */
   public void addKeyName(String keynameString) {
<span class="nc" id="L182">      this.add(new KeyName(this._doc, keynameString));</span>
<span class="nc" id="L183">   }</span>

   /**
    * Method add
    *
    * @param keyname
    */
   public void add(KeyName keyname) {

<span class="nc bnc" id="L192" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L193">         this._constructionElement.appendChild(keyname.getElement());</span>
<span class="nc" id="L194">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L196">   }</span>

   /**
    * Method addKeyValue
    *
    * @param pk
    */
   public void addKeyValue(PublicKey pk) {
<span class="nc" id="L204">      this.add(new KeyValue(this._doc, pk));</span>
<span class="nc" id="L205">   }</span>

   /**
    * Method addKeyValue
    *
    * @param unknownKeyValueElement
    */
   public void addKeyValue(Element unknownKeyValueElement) {
<span class="nc" id="L213">      this.add(new KeyValue(this._doc, unknownKeyValueElement));</span>
<span class="nc" id="L214">   }</span>

   /**
    * Method add
    *
    * @param dsakeyvalue
    */
   public void add(DSAKeyValue dsakeyvalue) {
<span class="nc" id="L222">      this.add(new KeyValue(this._doc, dsakeyvalue));</span>
<span class="nc" id="L223">   }</span>

   /**
    * Method add
    *
    * @param rsakeyvalue
    */
   public void add(RSAKeyValue rsakeyvalue) {
<span class="nc" id="L231">      this.add(new KeyValue(this._doc, rsakeyvalue));</span>
<span class="nc" id="L232">   }</span>

   /**
    * Method add
    *
    * @param pk
    */
   public void add(PublicKey pk) {
<span class="nc" id="L240">      this.add(new KeyValue(this._doc, pk));</span>
<span class="nc" id="L241">   }</span>

   /**
    * Method add
    *
    * @param keyvalue
    */
   public void add(KeyValue keyvalue) {

<span class="nc bnc" id="L250" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L251">         this._constructionElement.appendChild(keyvalue.getElement());</span>
<span class="nc" id="L252">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L254">   }</span>

   /**
    * Method addMgmtData
    *
    * @param mgmtdata
    */
   public void addMgmtData(String mgmtdata) {
<span class="nc" id="L262">      this.add(new MgmtData(this._doc, mgmtdata));</span>
<span class="nc" id="L263">   }</span>

   /**
    * Method add
    *
    * @param mgmtdata
    */
   public void add(MgmtData mgmtdata) {

<span class="nc bnc" id="L272" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L273">         this._constructionElement.appendChild(mgmtdata.getElement());</span>
<span class="nc" id="L274">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L276">   }</span>

   /**
    * Method addPGPData
    *
    * @param pgpdata
    */
   public void add(PGPData pgpdata) {

<span class="nc bnc" id="L285" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L286">         this._constructionElement.appendChild(pgpdata.getElement());</span>
<span class="nc" id="L287">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L289">   }</span>

   /**
    * Method addRetrievalMethod
    *
    * @param URI
    * @param transforms
    * @param Type
    */
   public void addRetrievalMethod(String URI, Transforms transforms,
                                  String Type) {
<span class="nc" id="L300">      this.add(new RetrievalMethod(this._doc, URI, transforms, Type));</span>
<span class="nc" id="L301">   }</span>

   /**
    * Method add
    *
    * @param retrievalmethod
    */
   public void add(RetrievalMethod retrievalmethod) {

<span class="nc bnc" id="L310" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L311">         this._constructionElement.appendChild(retrievalmethod.getElement());</span>
<span class="nc" id="L312">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L314">   }</span>

   /**
    * Method add
    *
    * @param spkidata
    */
   public void add(SPKIData spkidata) {

<span class="nc bnc" id="L323" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L324">         this._constructionElement.appendChild(spkidata.getElement());</span>
<span class="nc" id="L325">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L327">   }</span>

   /**
    * Method addX509Data
    *
    * @param x509data
    * @throws XMLSecurityException
    */
   public void add(X509Data x509data) throws XMLSecurityException {

<span class="nc bnc" id="L337" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L338">         this._constructionElement.appendChild(x509data.getElement());</span>
<span class="nc" id="L339">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L341">   }</span>

   /**
    * Method addUnknownElement
    *
    * @param element
    */
   public void addUnknownElement(Element element) {

<span class="nc bnc" id="L350" title="All 2 branches missed.">      if (this._state == MODE_SIGN) {</span>
<span class="nc" id="L351">         this._constructionElement.appendChild(element);</span>
<span class="nc" id="L352">         XMLUtils.addReturnToElement(this._constructionElement);</span>
      }
<span class="nc" id="L354">   }</span>

   /**
    * Method lengthKeyName
    *
    * @return
    */
   public int lengthKeyName() {
<span class="nc" id="L362">      return this.length(Constants.SignatureSpecNS, Constants._TAG_KEYNAME);</span>
   }

   /**
    * Method lengthKeyValue
    *
    * @return
    */
   public int lengthKeyValue() {
<span class="nc" id="L371">      return this.length(Constants.SignatureSpecNS, Constants._TAG_KEYVALUE);</span>
   }

   /**
    * Method lengthMgmtData
    *
    * @return
    */
   public int lengthMgmtData() {
<span class="nc" id="L380">      return this.length(Constants.SignatureSpecNS, Constants._TAG_MGMTDATA);</span>
   }

   /**
    * Method lengthPGPData
    *
    * @return
    */
   public int lengthPGPData() {
<span class="nc" id="L389">      return this.length(Constants.SignatureSpecNS, Constants._TAG_PGPDATA);</span>
   }

   /**
    * Method lengthRetrievalMethod
    *
    * @return
    */
   public int lengthRetrievalMethod() {
<span class="nc" id="L398">      return this.length(Constants.SignatureSpecNS,</span>
                         Constants._TAG_RETRIEVALMETHOD);
   }

   /**
    * Method lengthSPKIData
    *
    * @return
    */
   public int lengthSPKIData() {
<span class="nc" id="L408">      return this.length(Constants.SignatureSpecNS, Constants._TAG_SPKIDATA);</span>
   }

   /**
    * Method lengthX509Data
    *
    * @return
    */
   public int lengthX509Data() {
<span class="nc" id="L417">      return this.length(Constants.SignatureSpecNS, Constants._TAG_X509DATA);</span>
   }

   /**
    * Method lengthUnknownElement
    *
    * @return
    */
   public int lengthUnknownElement() {

<span class="nc" id="L427">      int res = 0;</span>
<span class="nc" id="L428">      NodeList nl = this._constructionElement.getChildNodes();</span>

<span class="nc bnc" id="L430" title="All 2 branches missed.">      for (int i = 0; i &lt; nl.getLength(); i++) {</span>
<span class="nc" id="L431">         Node current = nl.item(i);</span>

         /**
          * @todo using this method, we don't see unknown Elements
          *  from Signature NS; revisit
          */
<span class="nc bnc" id="L437" title="All 4 branches missed.">         if ((current.getNodeType() == Node.ELEMENT_NODE)</span>
                 &amp;&amp; current.getNamespaceURI()
                    .equals(Constants.SignatureSpecNS)) {
<span class="nc" id="L440">            res++;</span>
         }
      }

<span class="nc" id="L444">      return res;</span>
   }

   /**
    * Method itemKeyName
    *
    * @param i
    * @return
    * @throws XMLSecurityException
    */
   public KeyName itemKeyName(int i) throws XMLSecurityException {

<span class="nc" id="L456">      Element e = this.getChildElementLocalName(i, Constants.SignatureSpecNS,</span>
                                                Constants._TAG_KEYNAME);

<span class="nc bnc" id="L459" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L460">         return new KeyName(e, this._baseURI);</span>
      } else {
<span class="nc" id="L462">         return null;</span>
      }
   }

   /**
    * Method itemKeyValue
    *
    * @param i
    * @return
    * @throws XMLSecurityException
    */
   public KeyValue itemKeyValue(int i) throws XMLSecurityException {

<span class="nc" id="L475">      Element e = this.getChildElementLocalName(i, Constants.SignatureSpecNS,</span>
                                                Constants._TAG_KEYVALUE);

<span class="nc bnc" id="L478" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L479">         return new KeyValue(e, this._baseURI);</span>
      } else {
<span class="nc" id="L481">         return null;</span>
      }
   }

   /**
    * Method itemMgmtData
    *
    * @param i
    * @return
    * @throws XMLSecurityException
    */
   public MgmtData itemMgmtData(int i) throws XMLSecurityException {

<span class="nc" id="L494">      Element e = this.getChildElementLocalName(i, Constants.SignatureSpecNS,</span>
                                                Constants._TAG_MGMTDATA);

<span class="nc bnc" id="L497" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L498">         return new MgmtData(e, this._baseURI);</span>
      } else {
<span class="nc" id="L500">         return null;</span>
      }
   }

   /**
    * Method itemPGPData
    *
    * @param i
    * @return
    * @throws XMLSecurityException
    */
   public PGPData itemPGPData(int i) throws XMLSecurityException {

<span class="nc" id="L513">      Element e = this.getChildElementLocalName(i, Constants.SignatureSpecNS,</span>
                                                Constants._TAG_PGPDATA);

<span class="nc bnc" id="L516" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L517">         return new PGPData(e, this._baseURI);</span>
      } else {
<span class="nc" id="L519">         return null;</span>
      }
   }

   /**
    * Method itemRetrievalMethod
    *
    * @param i
    * @return
    * @throws XMLSecurityException
    */
   public RetrievalMethod itemRetrievalMethod(int i)
           throws XMLSecurityException {

<span class="nc" id="L533">      Element e = this.getChildElementLocalName(i, Constants.SignatureSpecNS,</span>
                                                Constants._TAG_RETRIEVALMETHOD);

<span class="nc bnc" id="L536" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L537">         return new RetrievalMethod(e, this._baseURI);</span>
      } else {
<span class="nc" id="L539">         return null;</span>
      }
   }

   /**
    * Method itemSPKIData
    *
    * @param i
    * @return
    * @throws XMLSecurityException
    */
   public SPKIData itemSPKIData(int i) throws XMLSecurityException {

<span class="nc" id="L552">      Element e = this.getChildElementLocalName(i, Constants.SignatureSpecNS,</span>
                                                Constants._TAG_SPKIDATA);

<span class="nc bnc" id="L555" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L556">         return new SPKIData(e, this._baseURI);</span>
      } else {
<span class="nc" id="L558">         return null;</span>
      }
   }

   /**
    * Method itemX509Data
    *
    * @param i
    * @return
    * @throws XMLSecurityException
    */
   public X509Data itemX509Data(int i) throws XMLSecurityException {

<span class="nc" id="L571">      Element e = this.getChildElementLocalName(i, Constants.SignatureSpecNS,</span>
                                                Constants._TAG_X509DATA);

<span class="nc bnc" id="L574" title="All 2 branches missed.">      if (e != null) {</span>
<span class="nc" id="L575">         return new X509Data(e, this._baseURI);</span>
      } else {
<span class="nc" id="L577">         return null;</span>
      }
   }

   /**
    * Method itemUnknownElement
    *
    * @param i
    * @return
    */
   public Element itemUnknownElement(int i) {

<span class="nc" id="L589">      NodeList nl = this._constructionElement.getChildNodes();</span>
<span class="nc" id="L590">      int res = 0;</span>

<span class="nc bnc" id="L592" title="All 2 branches missed.">      for (int j = 0; j &lt; nl.getLength(); j++) {</span>
<span class="nc" id="L593">         Node current = nl.item(j);</span>

         /**
          * @todo using this method, we don't see unknown Elements
          *  from Signature NS; revisit
          */
<span class="nc bnc" id="L599" title="All 4 branches missed.">         if ((current.getNodeType() == Node.ELEMENT_NODE)</span>
                 &amp;&amp; current.getNamespaceURI()
                    .equals(Constants.SignatureSpecNS)) {
<span class="nc" id="L602">            res++;</span>

<span class="nc bnc" id="L604" title="All 2 branches missed.">            if (res == i) {</span>
<span class="nc" id="L605">               return (Element) current;</span>
            }
         }
      }

<span class="nc" id="L610">      return null;</span>
   }

   /**
    * Method isEmpty
    *
    * @return
    */
   public boolean isEmpty() {
<span class="nc bnc" id="L619" title="All 2 branches missed.">      return this._constructionElement.getChildNodes().getLength() == 0;</span>
   }

   /**
    * Method containsKeyName
    *
    * @return
    */
   public boolean containsKeyName() {
<span class="nc bnc" id="L628" title="All 2 branches missed.">      return this.lengthKeyName() &gt; 0;</span>
   }

   /**
    * Method containsKeyValue
    *
    * @return
    */
   public boolean containsKeyValue() {
<span class="nc bnc" id="L637" title="All 2 branches missed.">      return this.lengthKeyValue() &gt; 0;</span>
   }

   /**
    * Method containsMgmtData
    *
    * @return
    */
   public boolean containsMgmtData() {
<span class="nc bnc" id="L646" title="All 2 branches missed.">      return this.lengthMgmtData() &gt; 0;</span>
   }

   /**
    * Method containsPGPData
    *
    * @return
    */
   public boolean containsPGPData() {
<span class="nc bnc" id="L655" title="All 2 branches missed.">      return this.lengthPGPData() &gt; 0;</span>
   }

   /**
    * Method containsRetrievalMethod
    *
    * @return
    */
   public boolean containsRetrievalMethod() {
<span class="nc bnc" id="L664" title="All 2 branches missed.">      return this.lengthRetrievalMethod() &gt; 0;</span>
   }

   /**
    * Method containsSPKIData
    *
    * @return
    */
   public boolean containsSPKIData() {
<span class="nc bnc" id="L673" title="All 2 branches missed.">      return this.lengthSPKIData() &gt; 0;</span>
   }

   /**
    * Method containsUnknownElement
    *
    * @return
    */
   public boolean containsUnknownElement() {
<span class="nc bnc" id="L682" title="All 2 branches missed.">      return this.lengthUnknownElement() &gt; 0;</span>
   }

   /**
    * Method containsX509Data
    *
    * @return
    */
   public boolean containsX509Data() {
<span class="nc bnc" id="L691" title="All 2 branches missed.">      return this.lengthX509Data() &gt; 0;</span>
   }

   /**
    * This method returns a secret (symmetric) key. This is for XML Encryption.
    *
    */
   public SecretKey getSecretKey() throws KeyResolverException {
<span class="nc" id="L699">      return null;</span>
   }

   /**
    * This method returns the public key.
    *
    * @return
    * @throws KeyResolverException
    */
   public PublicKey getPublicKey() throws KeyResolverException {

<span class="fc" id="L710">      PublicKey pk = this.getPublicKeyFromInternalResolvers();</span>

<span class="pc bpc" id="L712" title="1 of 2 branches missed.">      if (pk != null) {</span>
<span class="nc" id="L713">         cat.debug(&quot;I could find a key using the per-KeyInfo key resolvers&quot;);</span>

<span class="nc" id="L715">         return pk;</span>
      } else {
<span class="fc" id="L717">         cat.debug(&quot;I couldn't find a key using the per-KeyInfo key resolvers&quot;);</span>
      }

<span class="fc" id="L720">      pk = this.getPublicKeyFromStaticResolvers();</span>

<span class="pc bpc" id="L722" title="1 of 2 branches missed.">      if (pk != null) {</span>
<span class="fc" id="L723">         cat.debug(&quot;I could find a key using the system-wide key resolvers&quot;);</span>

<span class="fc" id="L725">         return pk;</span>
      } else {
<span class="nc" id="L727">         cat.debug(&quot;I couldn't find a key using the system-wide key resolvers&quot;);</span>
      }

<span class="nc" id="L730">      return null;</span>
   }

   /**
    * Searches the library wide keyresolvers for public keys
    *
    * @return
    * @throws KeyResolverException
    */
   PublicKey getPublicKeyFromStaticResolvers() throws KeyResolverException {

<span class="pc bpc" id="L741" title="1 of 2 branches missed.">      for (int i = 0; i &lt; KeyResolver.length(); i++) {</span>
<span class="fc" id="L742">         KeyResolver keyResolver = KeyResolver.item(i);</span>

<span class="fc" id="L744">         for (int j = 0;</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">                 j &lt; this._constructionElement.getChildNodes().getLength();</span>
<span class="fc" id="L746">                 j++) {</span>
<span class="fc" id="L747">            Node currentChild =</span>
               this._constructionElement.getChildNodes().item(j);

<span class="fc bfc" id="L750" title="All 2 branches covered.">            if (currentChild.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">               if (this._storageResolvers.size() == 0) {</span>

                  // if we do not have storage resolvers, we verify with null
<span class="fc" id="L754">                  StorageResolver storage = null;</span>

<span class="fc bfc" id="L756" title="All 2 branches covered.">                  if (keyResolver.canResolve((Element) currentChild,</span>
                                             this.getBaseURI(), storage)) {
<span class="fc" id="L758">                     PublicKey pk =</span>
                        keyResolver.resolvePublicKey((Element) currentChild,
                                                     this.getBaseURI(),
                                                     storage);

<span class="pc bpc" id="L763" title="1 of 2 branches missed.">                     if (pk != null) {</span>
<span class="fc" id="L764">                        return pk;</span>
                     }
                  }
<span class="fc" id="L767">               } else {</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">                  for (int k = 0; k &lt; this._storageResolvers.size(); k++) {</span>
<span class="nc" id="L769">                     StorageResolver storage =</span>
                        (StorageResolver) this._storageResolvers.elementAt(k);

<span class="nc bnc" id="L772" title="All 2 branches missed.">                     if (keyResolver.canResolve((Element) currentChild,</span>
                                                this.getBaseURI(), storage)) {
<span class="nc" id="L774">                        PublicKey pk =</span>
                           keyResolver.resolvePublicKey((Element) currentChild,
                                                        this.getBaseURI(),
                                                        storage);

<span class="nc bnc" id="L779" title="All 2 branches missed.">                        if (pk != null) {</span>
<span class="nc" id="L780">                           return pk;</span>
                        }
                     }
                  }
               }
            }
         }
      }

<span class="nc" id="L789">      return null;</span>
   }

   /**
    * Searches the per-KeyInfo keyresolvers for public keys
    *
    * @return
    * @throws KeyResolverException
    */
   PublicKey getPublicKeyFromInternalResolvers() throws KeyResolverException {

<span class="pc bpc" id="L800" title="1 of 2 branches missed.">      for (int i = 0; i &lt; this.lengthInternalKeyResolver(); i++) {</span>
<span class="nc" id="L801">         KeyResolverSpi keyResolver = this.itemInternalKeyResolver(i);</span>

<span class="nc" id="L803">         cat.debug(&quot;Try &quot; + keyResolver.getClass().getName());</span>

<span class="nc" id="L805">         for (int j = 0;</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">                 j &lt; this._constructionElement.getChildNodes().getLength();</span>
<span class="nc" id="L807">                 j++) {</span>
<span class="nc" id="L808">            Node currentChild =</span>
               this._constructionElement.getChildNodes().item(j);

<span class="nc bnc" id="L811" title="All 2 branches missed.">            if (currentChild.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">               if (this._storageResolvers.size() == 0) {</span>

                  // if we do not have storage resolvers, we verify with null
<span class="nc" id="L815">                  StorageResolver storage = null;</span>

<span class="nc bnc" id="L817" title="All 2 branches missed.">                  if (keyResolver.engineCanResolve((Element) currentChild,</span>
                                                   this.getBaseURI(),
                                                   storage)) {
<span class="nc" id="L820">                     PublicKey pk =</span>
                        keyResolver
                           .engineResolvePublicKey((Element) currentChild, this
                              .getBaseURI(), storage);

<span class="nc bnc" id="L825" title="All 2 branches missed.">                     if (pk != null) {</span>
<span class="nc" id="L826">                        return pk;</span>
                     }
                  }
<span class="nc" id="L829">               } else {</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">                  for (int k = 0; k &lt; this._storageResolvers.size(); k++) {</span>
<span class="nc" id="L831">                     StorageResolver storage =</span>
                        (StorageResolver) this._storageResolvers.elementAt(k);

<span class="nc bnc" id="L834" title="All 2 branches missed.">                     if (keyResolver.engineCanResolve((Element) currentChild,</span>
                                                      this.getBaseURI(),
                                                      storage)) {
<span class="nc" id="L837">                        PublicKey pk = keyResolver</span>
                           .engineResolvePublicKey((Element) currentChild, this
                              .getBaseURI(), storage);

<span class="nc bnc" id="L841" title="All 2 branches missed.">                        if (pk != null) {</span>
<span class="nc" id="L842">                           return pk;</span>
                        }
                     }
                  }
               }
            }
         }
      }

<span class="fc" id="L851">      return null;</span>
   }

   /**
    * Method getX509Certificate
    *
    * @return
    * @throws KeyResolverException
    */
   public X509Certificate getX509Certificate() throws KeyResolverException {

      // First search using the individual resolvers from the user
<span class="fc" id="L863">      X509Certificate cert = this.getX509CertificateFromInternalResolvers();</span>

<span class="pc bpc" id="L865" title="1 of 2 branches missed.">      if (cert != null) {</span>
<span class="nc" id="L866">         cat.debug(</span>
            &quot;I could find a X509Certificate using the per-KeyInfo key resolvers&quot;);

<span class="nc" id="L869">         return cert;</span>
      } else {
<span class="fc" id="L871">         cat.debug(</span>
            &quot;I couldn't find a X509Certificate using the per-KeyInfo key resolvers&quot;);
      }

      // Then use the system-wide Resolvers
<span class="fc" id="L876">      cert = this.getX509CertificateFromStaticResolvers();</span>

<span class="fc bfc" id="L878" title="All 2 branches covered.">      if (cert != null) {</span>
<span class="fc" id="L879">         cat.debug(</span>
            &quot;I could find a X509Certificate using the system-wide key resolvers&quot;);

<span class="fc" id="L882">         return cert;</span>
      } else {
<span class="fc" id="L884">         cat.debug(</span>
            &quot;I couldn't find a X509Certificate using the system-wide key resolvers&quot;);
      }

<span class="fc" id="L888">      return null;</span>
   }

   /**
    * This method uses each System-wide {@link KeyResolver} to search the
    * child elements. Each combination of {@link KeyResolver} and child element
    * is checked against all {@link StorageResolver}s.
    *
    * @return
    * @throws KeyResolverException
    */
   X509Certificate getX509CertificateFromStaticResolvers()
           throws KeyResolverException {

<span class="fc" id="L902">      cat.debug(&quot;Start getX509CertificateFromStaticResolvers() with &quot;</span>
                + KeyResolver.length() + &quot; resolvers&quot;);

<span class="fc bfc" id="L905" title="All 2 branches covered.">      for (int i = 0; i &lt; KeyResolver.length(); i++) {</span>
<span class="fc" id="L906">         KeyResolver keyResolver = KeyResolver.item(i);</span>

<span class="fc" id="L908">         for (int j = 0;</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">                 j &lt; this._constructionElement.getChildNodes().getLength();</span>
<span class="fc" id="L910">                 j++) {</span>
<span class="fc" id="L911">            Node currentChild =</span>
               this._constructionElement.getChildNodes().item(j);

<span class="fc bfc" id="L914" title="All 2 branches covered.">            if (currentChild.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">               if (this._storageResolvers.size() == 0) {</span>

                  // if we do not have storage resolvers, we verify with null
<span class="fc" id="L918">                  StorageResolver storage = null;</span>

<span class="fc bfc" id="L920" title="All 2 branches covered.">                  if (keyResolver.canResolve((Element) currentChild,</span>
                                             this.getBaseURI(), storage)) {
<span class="fc" id="L922">                     X509Certificate cert =</span>
                        keyResolver
                           .resolveX509Certificate((Element) currentChild, this
                              .getBaseURI(), storage);

<span class="fc bfc" id="L927" title="All 2 branches covered.">                     if (cert != null) {</span>
<span class="fc" id="L928">                        return cert;</span>
                     }
                  }
<span class="fc" id="L931">               } else {</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">                  for (int k = 0; k &lt; this._storageResolvers.size(); k++) {</span>
<span class="nc" id="L933">                     StorageResolver storage =</span>
                        (StorageResolver) this._storageResolvers.elementAt(k);

<span class="nc bnc" id="L936" title="All 2 branches missed.">                     if (keyResolver.canResolve((Element) currentChild,</span>
                                                this.getBaseURI(), storage)) {
<span class="nc" id="L938">                        X509Certificate cert = keyResolver</span>
                           .resolveX509Certificate((Element) currentChild, this
                              .getBaseURI(), storage);

<span class="nc bnc" id="L942" title="All 2 branches missed.">                        if (cert != null) {</span>
<span class="nc" id="L943">                           return cert;</span>
                        }
                     }
                  }
               }
            }
         }
      }

<span class="fc" id="L952">      return null;</span>
   }

   /**
    * Method getX509CertificateFromInternalResolvers
    *
    * @return
    * @throws KeyResolverException
    */
   X509Certificate getX509CertificateFromInternalResolvers()
           throws KeyResolverException {

<span class="fc" id="L964">      cat.debug(&quot;Start getX509CertificateFromInternalResolvers() with &quot;</span>
                + this.lengthInternalKeyResolver() + &quot; resolvers&quot;);

<span class="pc bpc" id="L967" title="1 of 2 branches missed.">      for (int i = 0; i &lt; this.lengthInternalKeyResolver(); i++) {</span>
<span class="nc" id="L968">         KeyResolverSpi keyResolver = this.itemInternalKeyResolver(i);</span>

<span class="nc" id="L970">         cat.debug(&quot;Try &quot; + keyResolver.getClass().getName());</span>

<span class="nc" id="L972">         for (int j = 0;</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">                 j &lt; this._constructionElement.getChildNodes().getLength();</span>
<span class="nc" id="L974">                 j++) {</span>
<span class="nc" id="L975">            Node currentChild =</span>
               this._constructionElement.getChildNodes().item(j);

<span class="nc bnc" id="L978" title="All 2 branches missed.">            if (currentChild.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">               if (this._storageResolvers.size() == 0) {</span>

                  // if we do not have storage resolvers, we verify with null
<span class="nc" id="L982">                  StorageResolver storage = null;</span>

<span class="nc bnc" id="L984" title="All 2 branches missed.">                  if (keyResolver.engineCanResolve((Element) currentChild,</span>
                                                   this.getBaseURI(),
                                                   storage)) {
<span class="nc" id="L987">                     X509Certificate cert =</span>
                        keyResolver.engineResolveX509Certificate(
                           (Element) currentChild, this.getBaseURI(), storage);

<span class="nc bnc" id="L991" title="All 2 branches missed.">                     if (cert != null) {</span>
<span class="nc" id="L992">                        return cert;</span>
                     }
                  }
<span class="nc" id="L995">               } else {</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">                  for (int k = 0; k &lt; this._storageResolvers.size(); k++) {</span>
<span class="nc" id="L997">                     StorageResolver storage =</span>
                        (StorageResolver) this._storageResolvers.elementAt(k);

<span class="nc bnc" id="L1000" title="All 2 branches missed.">                     if (keyResolver.engineCanResolve((Element) currentChild,</span>
                                                      this.getBaseURI(),
                                                      storage)) {
<span class="nc" id="L1003">                        X509Certificate cert =</span>
                           keyResolver.engineResolveX509Certificate(
                              (Element) currentChild, this.getBaseURI(),
                              storage);

<span class="nc bnc" id="L1008" title="All 2 branches missed.">                        if (cert != null) {</span>
<span class="nc" id="L1009">                           return cert;</span>
                        }
                     }
                  }
               }
            }
         }
      }

<span class="fc" id="L1018">      return null;</span>
   }

   /**
    * Stores the individual (per-KeyInfo) {@link KeyResolver}s
    */
<span class="pc" id="L1024">   Vector _internalKeyResolvers = new Vector();</span>

   /**
    * This method is used to add a custom {@link KeyResolverSpi} to a KeyInfo
    * object.
    *
    * @param realKeyResolver
    */
   public void registerInternalKeyResolver(KeyResolverSpi realKeyResolver) {
<span class="nc" id="L1033">      this._internalKeyResolvers.add(realKeyResolver);</span>
<span class="nc" id="L1034">   }</span>

   /**
    * Method lengthInternalKeyResolver
    *
    * @return
    */
   int lengthInternalKeyResolver() {
<span class="fc" id="L1042">      return this._internalKeyResolvers.size();</span>
   }

   /**
    * Method itemInternalKeyResolver
    *
    * @param i
    * @return
    */
   KeyResolverSpi itemInternalKeyResolver(int i) {
<span class="nc" id="L1052">      return (KeyResolverSpi) this._internalKeyResolvers.elementAt(i);</span>
   }

   /** Field _storageResolvers */
<span class="pc" id="L1056">   Vector _storageResolvers = new Vector();</span>

   /**
    * Method addStorageResolver
    *
    * @param storageResolver
    */
   public void addStorageResolver(StorageResolver storageResolver) {

<span class="nc bnc" id="L1065" title="All 2 branches missed.">      if (storageResolver != null) {</span>
<span class="nc" id="L1066">         this._storageResolvers.add(storageResolver);</span>
      }
<span class="nc" id="L1068">   }</span>

   /**
    * Method getStorageResolvers
    *
    * @return
    */
   Vector getStorageResolvers() {
<span class="nc" id="L1076">      return this._storageResolvers;</span>
   }

   //J-
<span class="fc" id="L1080">   static boolean _alreadyInitialized = false;</span>
   public static void init() {

<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">      if (!KeyInfo._alreadyInitialized) {</span>
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">         if (KeyInfo.cat == null) {</span>

            /**
             * @todo why the hell does the static initialization from the
             *  start not work ?
             */
<span class="nc" id="L1090">            KeyInfo.cat =</span>
               org.apache.log4j.Category.getInstance(KeyInfo.class.getName());

<span class="nc" id="L1093">            cat.error(&quot;Had to assign cat in the init() function&quot;);</span>
         }

         // KeyInfo._contentHandlerHash = new HashMap(10);
<span class="fc" id="L1097">         KeyInfo._alreadyInitialized = true;</span>
      }
<span class="fc" id="L1099">   }</span>

   public static void registerKeyInfoContentHandler(
           String namespace, String localname, String implementingClass)
              throws ContentHandlerAlreadyRegisteredException {
<span class="nc" id="L1104">      Init.registerKeyInfoContentHandler(namespace, localname,</span>
                                         implementingClass);
<span class="nc" id="L1106">   }</span>

   public String getBaseLocalName() {
<span class="fc" id="L1109">      return Constants._TAG_KEYINFO;</span>
   }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>