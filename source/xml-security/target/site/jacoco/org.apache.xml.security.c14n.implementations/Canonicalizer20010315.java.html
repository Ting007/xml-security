<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Canonicalizer20010315.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.c14n.implementations</a> &gt; <span class="el_source">Canonicalizer20010315.java</span></div><h1>Canonicalizer20010315.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.c14n.implementations;



import java.io.*;
import java.util.Enumeration;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;
import java.util.HashSet;
import java.util.Iterator;
import javax.xml.parsers.*;
import javax.xml.transform.TransformerException;
import org.apache.xml.utils.PrefixResolverDefault;
import org.apache.xpath.NodeSet;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathAPI;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xpath.objects.XObject;
import org.w3c.dom.*;
import org.w3c.dom.traversal.*;
import org.xml.sax.*;
import org.apache.xml.security.c14n.CanonicalizationException;
import org.apache.xml.security.c14n.Canonicalizer;
import org.apache.xml.security.c14n.CanonicalizerSpi;
import org.apache.xml.security.c14n.helper.AttrCompare;
import org.apache.xml.security.c14n.helper.NamespaceSearcher;
import org.apache.xml.security.c14n.helper.C14nHelper;
import org.apache.xml.security.c14n.helper.C14nNodeFilter;
import org.apache.xml.security.utils.HelperNodeList;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.utils.XMLUtils;


/**
 * This class implements the &lt;A
 * HREF=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315&quot;&gt;Canonical XML
 * Version 1.0&lt;/A&gt; specification.
 * &lt;BR&gt;
 * The calling hierarchie is relativly easy:
 *
 * &lt;OL&gt;
 * &lt;LI&gt;&lt;code&gt;c14nFiles&lt;/code&gt; is called with the filenames of the input and
 * output file, the includeComments boolean and the XPath string&lt;/LI&gt;
 * &lt;LI&gt;&lt;code&gt;c14nFiles&lt;/code&gt; calls &lt;code&gt;canonicalize&lt;/code&gt; with the root
 * node and the NodeList with the selected &lt;code&gt;Node&lt;/code&gt;s&lt;/LI&gt;
 * &lt;LI&gt;&lt;code&gt;canonicalize&lt;/code&gt; calls &lt;code&gt;process&lt;/code&gt;&lt;/LI&gt;
 * &lt;LI&gt;&lt;code&gt;process&lt;/code&gt; recursively calls itself and uses the
 * &lt;code&gt;normalizeXXX&lt;/code&gt; functions for normalizing the different
 * NodeTypes&lt;/LI&gt;
 * &lt;/OL&gt;
 *
 * @author Christian Geuer-Pollmann
 * @since  REC-xml-c14n-20010315 .
 */
<span class="fc" id="L115">public abstract class Canonicalizer20010315 extends CanonicalizerSpi {</span>

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L118">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category
         .getInstance(Canonicalizer20010315.class.getName());

   /** Field processingPos */
<span class="fc" id="L123">   private short processingPos = CanonicalizerSpi.BEFORE_DOCUMENT_ELEM;</span>

   /** Field hmVisibleNodes */
<span class="fc" id="L126">   public Map hmVisibleNodes = null;</span>

   /**
    * During c14n of a document with only a document subset visible,
    * Attributes for namespace declarations are created in 'visible' Elements.
    * This means that after c14n, the infoset of the document is modified because
    * this process added namespace attrs. If this is a problem, the added
    * attributes have to be removed from the DOM after c14n.
    */
<span class="fc" id="L135">   private Vector _attrsToBeRemovedAfterC14n = new Vector();</span>

   /** Field _removeNSattrsAfterC14n */
<span class="fc" id="L138">   private boolean _removeNSattrsAfterC14n = true;</span>

   /**
    * Method engineVisible
    *
    * @param node
    * @return
    */
   public boolean engineVisible(Node node) {

<span class="pc bpc" id="L148" title="1 of 2 branches missed.">      if (this.hmVisibleNodes == null) {</span>
<span class="nc" id="L149">         return false;</span>
      }

<span class="fc" id="L152">      return this.hmVisibleNodes.containsKey(node);</span>
   }

   /**
    * Method engineMakeVisible
    *
    * @param node
    */
   public void engineMakeVisible(Node node) {

<span class="pc bpc" id="L162" title="1 of 2 branches missed.">      if (this.hmVisibleNodes == null) {</span>
<span class="nc" id="L163">         this.hmVisibleNodes = (Map) new HashMap();</span>
      }

<span class="fc bfc" id="L166" title="All 2 branches covered.">      if (node.getNodeType() == Node.ATTRIBUTE_NODE) {</span>
<span class="fc" id="L167">         Attr a = (Attr) node;</span>
<span class="fc" id="L168">         Element ownerElement = a.getOwnerElement();</span>

<span class="pc bpc" id="L170" title="1 of 2 branches missed.">         if (ownerElement == null) {</span>
<span class="nc" id="L171">            cat.warn(&quot;makeVisible(&quot; + a + &quot;) in NULL !?! Element&quot;);</span>
         } else {
<span class="fc" id="L173">            cat.debug(&quot;makeVisible(&quot; + a + &quot;) in Element &quot;</span>
                      + ownerElement.getTagName());
         }
<span class="fc" id="L176">      } else {</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">         cat.debug(&quot;makeVisible(&quot; + ((node.getNamespaceURI() != null)</span>
                                     ? &quot;{&quot; + node.getNamespaceURI() + &quot;} &quot;
                                     : &quot;&quot;) + node.getNodeName() + &quot;)&quot;);
      }

<span class="fc" id="L182">      this.hmVisibleNodes.put(node, Boolean.TRUE);</span>
<span class="fc" id="L183">   }</span>

   /**
    * Method engineMakeInVisible
    *
    * @param node
    */
   public void engineMakeInVisible(Node node) {

<span class="pc bpc" id="L192" title="1 of 2 branches missed.">      if (this.hmVisibleNodes != null) {</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">         if (node.getNodeType() == Node.ATTRIBUTE_NODE) {</span>
<span class="fc" id="L194">            Attr a = (Attr) node;</span>

<span class="fc" id="L196">            cat.debug(&quot;makeInVisible(&quot; + a + &quot;) in Element &quot;</span>
                      + a.getOwnerElement().getTagName());
<span class="fc" id="L198">         } else {</span>
<span class="nc" id="L199">            cat.debug(&quot;makeInVisible(&quot; + node + &quot;)&quot;);</span>
         }

<span class="pc bpc" id="L202" title="1 of 2 branches missed.">         if (!engineVisible(node)) {</span>
<span class="nc" id="L203">            cat.fatal(&quot;Try to hide &quot; + node + &quot; but already is not visible&quot;);</span>
         }

<span class="fc" id="L206">         this.hmVisibleNodes.remove(node);</span>
      }
<span class="fc" id="L208">   }</span>

   /**
    * Method engineSetXPathNodeSet
    *
    * @param nodeList
    */
   public void engineSetXPathNodeSet(NodeList nodeList) {

<span class="fc" id="L217">      cat.debug(&quot;Canonicalizer20010315.engineSetXPathNodeSet(&quot;</span>
                + nodeList.getLength() + &quot; nodes)&quot;);

<span class="fc" id="L220">      this.hmVisibleNodes = (Map) new HashMap();</span>

<span class="fc bfc" id="L222" title="All 2 branches covered.">      for (int i = 0; i &lt; nodeList.getLength(); i++) {</span>
<span class="fc" id="L223">         engineMakeVisible(nodeList.item(i));</span>
      }
<span class="fc" id="L225">   }</span>

   /**
    * Method engineCanonicalize
    *
    * @param selectedNodes
    * @return
    * @throws CanonicalizationException
    */
   public byte[] engineCanonicalize(NodeList selectedNodes)
           throws CanonicalizationException {

<span class="fc" id="L237">      this.engineSetXPathNodeSet(selectedNodes);</span>

<span class="pc bpc" id="L239" title="1 of 2 branches missed.">      if (selectedNodes.getLength() == 0) {</span>
<span class="nc" id="L240">         return new byte[0];</span>
      }

<span class="fc" id="L243">      Document document = XMLUtils.getOwnerDocument(selectedNodes.item(0));</span>

<span class="fc" id="L245">      return this.engineDoCanonicalization(document);</span>
   }

   /**
    * Method engineCanonicalize
    *
    * @param node
    * @return
    * @throws CanonicalizationException
    */
   public byte[] engineCanonicalize(Node node)
           throws CanonicalizationException {

      /**
       * If the node set has not been set by anyone else before, we apply
       * our own XPath to it.
       */
<span class="fc bfc" id="L262" title="All 2 branches covered.">      if (this.hmVisibleNodes == null) {</span>
         try {
            //J-
            /*
            if ((this.engineGetXPathString().equals(Canonicalizer.XPATH_C14N_WITH_COMMENTS) ||
                 this.engineGetXPathString().equals(Canonicalizer.XPATH_C14N_WITH_COMMENTS_SINGLE_NODE) ||
                 this.engineGetXPathString().equals(Canonicalizer.XPATH_C14N_OMIT_COMMENTS) ||
                 this.engineGetXPathString().equals(Canonicalizer.XPATH_C14N_OMIT_COMMENTS_SINGLE_NODE))) {
               //J+
               // we do a c14n without strange features, so why use the XPath compliant version
               CanonicalizerSpi c14nizer = null;

               if (this.engineGetXPathString()
                       .equals(Canonicalizer
                       .XPATH_C14N_OMIT_COMMENTS_SINGLE_NODE) || this
                          .engineGetXPathString()
                          .equals(Canonicalizer.XPATH_C14N_OMIT_COMMENTS)) {
                  c14nizer =
                     new Canonicalizer20010315WithoutXPathSupportOmitComments();
               } else {
                  c14nizer =
                     new Canonicalizer20010315WithoutXPathSupportWithComments();
               }

               if (c14nizer == null) {
                  return null;
               }

               return c14nizer.engineCanonicalize(node);
            } else {
            */
<span class="fc" id="L293">            NodeList selected = null;</span>

<span class="fc bfc" id="L295" title="All 2 branches covered.">            if (this.engineGetXPath() instanceof Element) {</span>
<span class="fc" id="L296">               selected = XPathAPI.selectNodeList(node,</span>
                                                  this.engineGetXPathString(),
                                                  (Node) this.engineGetXPath());
            } else {
<span class="fc" id="L300">               selected = XPathAPI.selectNodeList(node,</span>
                                                  this.engineGetXPathString());
            }

<span class="fc" id="L304">            cat.debug(&quot;xpath is&quot; + this.engineGetXPathString());</span>
<span class="fc" id="L305">            this.engineSetXPathNodeSet(selected);</span>

            // }
<span class="nc" id="L308">         } catch (TransformerException e) {</span>
<span class="nc" id="L309">            Object exArgs[] = { &quot;TransformerException: &quot; + e.getMessage() };</span>

<span class="nc" id="L311">            throw new CanonicalizationException(&quot;generic.EmptyMessage&quot;, exArgs,</span>
                                                e);
<span class="fc" id="L313">         }</span>
      }

<span class="fc" id="L316">      return this.engineDoCanonicalization(node);</span>
   }

   /**
    * Method engineDoCanonicalization
    *
    * @param node
    * @return
    * @throws CanonicalizationException
    */
   private byte[] engineDoCanonicalization(Node node)
           throws CanonicalizationException {

<span class="fc" id="L329">      Document document = XMLUtils.getOwnerDocument(node);</span>

<span class="fc" id="L331">      this.checkTraversability(document);</span>

<span class="fc" id="L333">      DocumentTraversal dt = ((DocumentTraversal) document);</span>
<span class="fc" id="L334">      Node rootNode = (Node) node;</span>
<span class="fc" id="L335">      NodeFilter nodefilter =</span>
         new C14nNodeFilter(this.engineGetIncludeComments());
<span class="fc" id="L337">      TreeWalker treewalker = dt.createTreeWalker(rootNode,</span>
                                                  NodeFilter.SHOW_ALL,
                                                  nodefilter, true);
<span class="fc" id="L340">      ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream();</span>
<span class="fc" id="L341">      PrintWriter printwriter = null;</span>

      try {
<span class="fc" id="L344">         printwriter =</span>
            new PrintWriter(new OutputStreamWriter(bytearrayoutputstream,
                                                   Canonicalizer.ENCODING));
<span class="nc" id="L347">      } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L348">         throw new CanonicalizationException(&quot;generic.EmptyMessage&quot;, ex);</span>
<span class="fc" id="L349">      }</span>

<span class="fc" id="L351">      process(treewalker, printwriter, this.engineGetIncludeComments());</span>
<span class="fc" id="L352">      printwriter.flush();</span>

<span class="pc bpc" id="L354" title="1 of 2 branches missed.">      if (this.engineGetRemoveNSAttrs()) {</span>
<span class="fc" id="L355">         this.removeNSAttrs();</span>
      }

<span class="fc" id="L358">      return bytearrayoutputstream.toByteArray();</span>
   }

   /**
    * Method process
    *
    * @param treewalker
    * @param printwriter
    * @param includeComments
    * @throws CanonicalizationException
    */
   private void process(
           TreeWalker treewalker, PrintWriter printwriter, boolean includeComments)
              throws CanonicalizationException {

<span class="fc" id="L373">      Node currentNode = treewalker.getCurrentNode();</span>

<span class="pc bpc" id="L375" title="3 of 9 branches missed.">      switch (currentNode.getNodeType()) {</span>

      case Node.ENTITY_REFERENCE_NODE :
<span class="nc bnc" id="L378" title="All 2 branches missed.">         for (Node node1 = treewalker.firstChild(); node1 != null;</span>
<span class="nc" id="L379">                 node1 = treewalker.nextSibling()) {</span>
<span class="nc" id="L380">            process(treewalker, printwriter, includeComments);</span>
         }

<span class="nc" id="L383">         treewalker.setCurrentNode(currentNode);</span>
<span class="nc" id="L384">         break;</span>

      case Node.ENTITY_NODE :
<span class="nc" id="L387">         cat.warn(&quot;Node.ENTITY_NODE called&quot;);</span>
<span class="nc" id="L388">         break;</span>

      case Node.ATTRIBUTE_NODE : {
<span class="nc" id="L391">         Object[] exArgs = {</span>
            XMLUtils.getNodeTypeString(currentNode.getNodeType()),
            currentNode.getNodeName() };

<span class="nc" id="L395">         throw new CanonicalizationException(</span>
            &quot;c14n.Canonicalizer20010315.IllegalNode&quot;, exArgs);
      }
      case Node.TEXT_NODE :
      case Node.CDATA_SECTION_NODE :
<span class="fc bfc" id="L400" title="All 2 branches covered.">         if (engineVisible(currentNode)) {</span>
<span class="fc" id="L401">            printwriter</span>
               .print(C14nHelper.normalizeText(currentNode.getNodeValue()));

<span class="fc" id="L404">            Node nextSibling = currentNode.getNextSibling();</span>

            /**
             * see http://nagoya.apache.org/bugzilla/show_bug.cgi?id=6329
             */
            while ((nextSibling != null)
<span class="pc bpc" id="L410" title="2 of 6 branches missed.">                   &amp;&amp; ((nextSibling.getNodeType() == Node.TEXT_NODE)</span>
                       || (nextSibling.getNodeType()
                           == Node.CDATA_SECTION_NODE))) {
<span class="nc" id="L413">               printwriter</span>
                  .print(C14nHelper.normalizeText(nextSibling.getNodeValue()));

<span class="nc" id="L416">               nextSibling = nextSibling.getNextSibling();</span>
            }
<span class="fc" id="L418">         } else {</span>
<span class="fc" id="L419">            cat.error(currentNode + &quot; not visible&quot;);</span>
         }
<span class="fc" id="L421">         break;</span>

      case Node.COMMENT_NODE :

         /*
          * Comment Nodes- Nothing if generating canonical XML without comments.
          * For canonical XML with comments, generate the opening comment
          * symbol (&lt;!--), the string value of the node, and the closing
          * comment symbol (--&gt;). Also, a trailing #xA is rendered after the
          * closing comment symbol for comment children of the root node with
          * a lesser document order than the document element, and a leading
          * #xA is rendered before the opening comment symbol of comment
          * children of the root node with a greater document order than the
          * document element. (Comment children of the root node represent
          * comments outside of the top-level document element and outside
          * of the document type declaration).
          */
<span class="fc bfc" id="L438" title="All 2 branches covered.">         if ( /* includeComments &amp;&amp; */engineVisible(currentNode)) {</span>
<span class="fc bfc" id="L439" title="All 2 branches covered.">            if (processingPos == CanonicalizerSpi.AFTER_DOCUMENT_ELEM) {</span>
<span class="fc" id="L440">               printwriter.print(&quot;\n&quot;);</span>
            }

            /** do we need have to normalize Comments ? */
<span class="fc" id="L444">            printwriter.print(&quot;&lt;!--&quot;);</span>
<span class="fc" id="L445">            printwriter</span>
               .print(C14nHelper.normalizeComment(currentNode.getNodeValue()));
<span class="fc" id="L447">            printwriter.print(&quot;--&gt;&quot;);</span>

<span class="fc bfc" id="L449" title="All 2 branches covered.">            if (processingPos == CanonicalizerSpi.BEFORE_DOCUMENT_ELEM) {</span>
<span class="fc" id="L450">               printwriter.print(&quot;\n&quot;);</span>
            }
         }
         break;

      case Node.PROCESSING_INSTRUCTION_NODE :

         /*
          * Processing Instruction (PI) Nodes- The opening PI symbol (&lt;?),
          * the PI target name of the node, a leading space and the string
          * value if it is not empty, and the closing PI symbol (?&gt;). If the
          * string value is empty, then the leading space is not added.
          * Also, a trailing #xA is rendered after the closing PI symbol for PI
          * children of the root node with a lesser document order than the
          * document element, and a leading #xA is rendered before the opening
          * PI symbol of PI children of the root node with a greater document
          * order than the document element.
          *
          */
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">         if (engineVisible(currentNode)) {</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">            if (processingPos == CanonicalizerSpi.AFTER_DOCUMENT_ELEM) {</span>
<span class="fc" id="L471">               printwriter.print(&quot;\n&quot;);</span>
            }

<span class="fc" id="L474">            printwriter.print(&quot;&lt;?&quot;);</span>
<span class="fc" id="L475">            printwriter.print(currentNode.getNodeName());</span>

<span class="fc" id="L477">            String s = currentNode.getNodeValue();</span>

<span class="pc bpc" id="L479" title="1 of 4 branches missed.">            if ((s != null) &amp;&amp; (s.length() &gt; 0)) {</span>
<span class="fc" id="L480">               printwriter.print(&quot; &quot;);</span>

               /** @todo do we need PI normalization ? */
<span class="fc" id="L483">               printwriter.print(C14nHelper.normalizeProcessingInstruction(s));</span>
            }

<span class="fc" id="L486">            printwriter.print(&quot;?&gt;&quot;);</span>

<span class="fc bfc" id="L488" title="All 2 branches covered.">            if (processingPos == CanonicalizerSpi.BEFORE_DOCUMENT_ELEM) {</span>
<span class="fc" id="L489">               printwriter.print(&quot;\n&quot;);</span>
            }
<span class="fc" id="L491">         }</span>
         break;

      case Node.ELEMENT_NODE :

         // If we enter an Element, we are inside the Document Element
<span class="fc" id="L497">         processingPos = CanonicalizerSpi.INSIDE_DOCUMENT_ELEM;</span>

         /* We check relative Namespaces in _all_ nodes;
          *
          * Implementations MUST report an operation failure on documents containing
          * relative namespace URIs. (This reads to me that the _complete_ document
          * must not contain relative namespaces, even if we only canonicalize a
          * subtree that does not contain relative namespace URIs).
          */
<span class="fc" id="L506">         checkForRelativeNamespace(currentNode);</span>

<span class="fc bfc" id="L508" title="All 2 branches covered.">         if (engineVisible(currentNode)) {</span>
<span class="fc" id="L509">            cat.debug(currentNode.getNodeName() + &quot; included&quot;);</span>
<span class="fc" id="L510">            printwriter.print('&lt;');</span>
<span class="fc" id="L511">            printwriter.print(currentNode.getNodeName());</span>

            {    // make all namespaces visible !!!
<span class="fc" id="L514">               NamedNodeMap namednodemap = currentNode.getAttributes();</span>
<span class="fc" id="L515">               Attr aattr[] = C14nHelper.sortAttributes(namednodemap);</span>

<span class="fc bfc" id="L517" title="All 2 branches covered.">               for (int i = 0; i &lt; aattr.length; i++) {</span>
<span class="fc" id="L518">                  Attr attr = aattr[i];</span>

<span class="fc bfc" id="L520" title="All 4 branches covered.">                  if (attr.getNodeName().startsWith(&quot;xmlns:&quot;)</span>
                          || attr.getNodeName().equals(&quot;xmlns&quot;)) {
<span class="fc" id="L522">                     this.engineMakeVisible(attr);</span>
                  }
               }
            }

<span class="fc" id="L527">            processXmlAttributes(currentNode);</span>
<span class="fc" id="L528">            processNamespaces(currentNode);</span>

<span class="fc" id="L530">            NamedNodeMap namednodemap = currentNode.getAttributes();</span>
<span class="fc" id="L531">            Attr aattr[] = C14nHelper.sortAttributes(namednodemap);</span>

<span class="fc bfc" id="L533" title="All 2 branches covered.">            processingAttrs: for (int i = 0; i &lt; aattr.length; i++) {</span>
<span class="fc" id="L534">               Attr attr = aattr[i];</span>

               // To finish processing L, simply process every namespace node
               // in L, except omit namespace node with local name xml, which
               // defines the xml prefix, if its string value is
               // &quot;http://www.w3.org/XML/1998/namespace&quot;.
<span class="pc bpc" id="L540" title="3 of 4 branches missed.">               if (attr.getNodeName().equals(&quot;xmlns:xml&quot;) &amp;&amp;</span>

               // attr.getLocalName().equals(&quot;xml&quot;) &amp;&amp;
               attr.getNodeValue()
                       .equals(&quot;http://www.w3.org/XML/1998/namespace&quot;)) {
<span class="nc" id="L545">                  continue processingAttrs;</span>
               }

<span class="fc bfc" id="L548" title="All 2 branches covered.">               if (engineVisible((Node) attr)) {</span>
<span class="fc" id="L549">                  printwriter.print(' ');</span>
<span class="fc" id="L550">                  printwriter.print(attr.getNodeName());</span>
<span class="fc" id="L551">                  printwriter.print(&quot;=\&quot;&quot;);</span>
<span class="fc" id="L552">                  printwriter</span>
                     .print(C14nHelper.normalizeAttr(attr.getNodeValue()));
<span class="fc" id="L554">                  printwriter.print('&quot;');</span>
               } else {
<span class="fc" id="L556">                  cat.debug(&quot;Suppressed Attr: &quot; + attr + &quot; from Element &quot;</span>
                            + attr.getOwnerElement().getTagName());
               }
            }

<span class="fc" id="L561">            printwriter.print(&quot;&gt;&quot;);</span>
<span class="fc" id="L562">         } else {</span>
<span class="fc" id="L563">            cat.debug(currentNode.getNodeName() + &quot; excluded !!!&quot;);</span>
         }

<span class="fc bfc" id="L566" title="All 2 branches covered.">         for (Node node1 = treewalker.firstChild(); node1 != null;</span>
<span class="fc" id="L567">                 node1 = treewalker.nextSibling()) {</span>
<span class="fc" id="L568">            process(treewalker, printwriter, includeComments);</span>
         }

<span class="fc" id="L571">         treewalker.setCurrentNode(currentNode);</span>

<span class="fc bfc" id="L573" title="All 2 branches covered.">         if (engineVisible(currentNode)) {</span>
<span class="fc" id="L574">            printwriter.print(&quot;&lt;/&quot;);</span>
<span class="fc" id="L575">            printwriter.print(currentNode.getNodeName());</span>
<span class="fc" id="L576">            printwriter.print('&gt;');</span>
         }

         // If we leave the Document Element, we are outside the Document Element
<span class="fc bfc" id="L580" title="All 2 branches covered.">         if (currentNode</span>
                 == currentNode.getOwnerDocument().getDocumentElement()) {
<span class="fc" id="L582">            processingPos = CanonicalizerSpi.AFTER_DOCUMENT_ELEM;</span>
         }
         break;

      case Node.DOCUMENT_NODE :

         /*
          * Root Node- The root node is the parent of the top-level document
          * element. The result of processing each of its child nodes that
          * is in the node-set in document order. The root node does not
          * generate a byte order mark, XML declaration, nor anything from
          * within the document type declaration.
          *
          */
<span class="fc bfc" id="L596" title="All 2 branches covered.">         for (Node node1 = treewalker.firstChild(); node1 != null;</span>
<span class="fc" id="L597">                 node1 = treewalker.nextSibling()) {</span>
<span class="fc" id="L598">            process(treewalker, printwriter, includeComments);</span>
         }

<span class="fc" id="L601">         treewalker.setCurrentNode(currentNode);</span>
<span class="fc" id="L602">         break;</span>

      default :
<span class="pc bpc" id="L605" title="1 of 2 branches missed.">         for (Node node1 = treewalker.firstChild(); node1 != null;</span>
<span class="nc" id="L606">                 node1 = treewalker.nextSibling()) {</span>
<span class="nc" id="L607">            process(treewalker, printwriter, includeComments);</span>
         }

<span class="fc" id="L610">         treewalker.setCurrentNode(currentNode);</span>
         break;
      }
<span class="fc" id="L613">   }</span>

   /**
    * Method collectUsedXmlAttributes
    *
    * @param ctxNode
    * @return
    */
   private static HashSet collectUsedXmlAttributes(Node ctxNode) {

<span class="fc" id="L623">      HashSet attrs = new HashSet();</span>

<span class="pc bpc" id="L625" title="2 of 4 branches missed.">      if ((ctxNode != null) &amp;&amp; (ctxNode.getNodeType() == Node.ELEMENT_NODE)) {</span>
<span class="fc" id="L626">         Node parent = ctxNode;</span>

         searchParents: while ((parent = parent.getParentNode()) != null
<span class="pc bpc" id="L629" title="1 of 4 branches missed.">                               &amp;&amp; (parent.getNodeType() == Node.ELEMENT_NODE)) {</span>
<span class="fc" id="L630">            NamedNodeMap attributes = parent.getAttributes();</span>

<span class="fc bfc" id="L632" title="All 2 branches covered.">            for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="fc" id="L633">               Attr attr = (Attr) attributes.item(i);</span>

<span class="fc bfc" id="L635" title="All 2 branches covered.">               if (attr.getName().startsWith(&quot;xml:&quot;)) {</span>
<span class="fc" id="L636">                  attrs.add(new String(attr.getName()));</span>
               }
            }
<span class="fc" id="L639">         }</span>
      }

<span class="fc" id="L642">      return attrs;</span>
   }

   /**
    * Method processXmlAttributes
    *
    * @param ctxNode
    */
   private void processXmlAttributes(Node ctxNode) {

<span class="pc bpc" id="L652" title="1 of 2 branches missed.">      if (!engineVisible(ctxNode)) {</span>
<span class="nc" id="L653">         return;</span>
      }

<span class="fc" id="L656">      HashSet usedXMLAttributes = collectUsedXmlAttributes(ctxNode);</span>

      // Attr attributes[] = new Attr[usedXMLAttributes.size()];
      // cat.debug(&quot;attributes[&quot; + usedXMLAttributes.size() + &quot;]&quot;);
<span class="fc" id="L660">      Iterator iterator = usedXMLAttributes.iterator();</span>

      // int i = 0;
<span class="fc bfc" id="L663" title="All 2 branches covered.">      while (iterator.hasNext()) {</span>
<span class="fc" id="L664">         String currentXMLAttribute = (String) iterator.next();</span>
<span class="fc" id="L665">         String newAttrValue = null;</span>
<span class="fc" id="L666">         boolean deleteOriginalAttribute = false;</span>

         {
<span class="fc" id="L669">            Object result[] = processXmlAttributesAlgo(ctxNode,</span>
                                                       currentXMLAttribute);

<span class="fc" id="L672">            newAttrValue = (String) result[0];</span>
<span class="fc" id="L673">            deleteOriginalAttribute = ((Boolean) result[1]).booleanValue();</span>
         }

<span class="fc bfc" id="L676" title="All 2 branches covered.">         if (newAttrValue == null) {</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">            if (deleteOriginalAttribute) {</span>
<span class="fc" id="L678">               engineMakeInVisible(((Element) ctxNode)</span>
                  .getAttributeNode(currentXMLAttribute));
<span class="fc" id="L680">               ((Element) ctxNode).getAttributes()</span>
                  .removeNamedItem(currentXMLAttribute);
            }
         } else {
<span class="fc" id="L684">            ((Element) ctxNode).setAttribute(currentXMLAttribute, newAttrValue);</span>
<span class="fc" id="L685">            engineMakeVisible(((Element) ctxNode)</span>
               .getAttributeNode(currentXMLAttribute));
         }
<span class="fc" id="L688">      }</span>
<span class="fc" id="L689">   }</span>

   /**
    * Namespace Nodes- A namespace node N is ignored if the nearest
    * ancestor element of the node's parent element that is in the
    * node-set has a namespace node in the node-set with the same local
    * name and value as N. Otherwise, process the namespace node N in
    * the same way as an attribute node, except assign the local name
    * xmlns to the default namespace node if it exists (in XPath, the
    * default namespace node has an empty URI and local name).
    *
    * &lt;PRE LANG=&quot;DE&quot;&gt;
    * case 1 - definiert selbst einen nicht-leeren default NS - muss evtl. gel�scht werden
    * case 2 - definiert selbst einen       leeren default NS - muss evtl. gel�scht werden
    * case 3 - definiert selbst einen nicht-leeren         NS - muss evtl. gel�scht werden
    * case 4 - definiert selbst einen       leeren         NS - muss evtl. gel�scht werden
    * case 5 - in einem invisible wird ein nicht-leerer default NS definiert - muss evtl. hinzugef�gt werden
    * case 6 - in einem invisible wird ein       leerer default NS definiert - muss evtl. hinzugef�gt werden
    * case 7 - in einem invisible wird ein nicht-leerer         NS definiert - muss evtl. hinzugef�gt werden
    * case 8 - in einem invisible wird ein       leerer         NS definiert - muss evtl. hinzugef�gt werden
    * &lt;/PRE&gt;
    *
    * &lt;PRE LANG=&quot;EN&quot;&gt;
    * case 1 - defines itself a non-empty default NS - must eventually be deleted
    * case 2 - defines itself an    empty default NS - must eventually be deleted
    * case 3 - defines itself a non-empty         NS - must eventually be deleted
    * case 4 - defines itself an    empty         NS - must eventually be deleted
    * case 5 - an invivible elem defines a non-empty default NS - must eventually be added
    * case 6 - an invivible elem defines an    empty default NS - must eventually be added
    * case 7 - an invivible elem defines a non-empty         NS - must eventually be added
    * case 8 - an invivible elem defines an    empty         NS - must eventually be added
    * &lt;/PRE&gt;
    *
    * @param ctxNode
    * @throws CanonicalizationException
    */
   private void processNamespaces(Node ctxNode)
           throws CanonicalizationException {

<span class="pc bpc" id="L728" title="1 of 2 branches missed.">      if (!engineVisible(ctxNode)) {</span>
<span class="nc" id="L729">         return;</span>
      }

<span class="pc bpc" id="L732" title="1 of 2 branches missed.">      if (ctxNode.getNodeType() != Node.ELEMENT_NODE) {</span>
<span class="nc" id="L733">         cat.fatal(&quot;removeExtraNamespaces with &quot;</span>
                   + XMLUtils.getNodeTypeString(ctxNode.getNodeType())
                   + &quot; called. Has to get an ELEMENT&quot;);

<span class="nc" id="L737">         return;</span>
      }

<span class="fc" id="L740">      NamedNodeMap ctxAttributes = ctxNode.getAttributes();</span>
<span class="fc" id="L741">      NamespaceSearcher nss = new NamespaceSearcher(ctxNode,</span>
                                 this.hmVisibleNodes);

      /*
       * case 1 - definiert selbst einen nicht-leeren default NS - muss evtl. gel�scht werden
       * case 2 - definiert selbst einen       leeren default NS - muss evtl. gel�scht werden
       * case 3 - definiert selbst einen nicht-leeren         NS - muss evtl. gel�scht werden
       * case 4 - definiert selbst einen       leeren         NS - muss evtl. gel�scht werden
       * case 5 - in einem invisible wird ein nicht-leerer default NS definiert - muss evtl. hinzugef�gt werden
       * case 6 - in einem invisible wird ein       leerer default NS definiert - muss evtl. hinzugef�gt werden
       * case 7 - in einem invisible wird ein nicht-leerer         NS definiert - muss evtl. hinzugef�gt werden
       * case 8 - in einem invisible wird ein       leerer         NS definiert - muss evtl. hinzugef�gt werden
       */

      // loop through all Attributes and check whether we have to delete some
<span class="fc bfc" id="L756" title="All 2 branches covered.">      nextNodeAttribute: for (int i = 0; i &lt; ctxAttributes.getLength(); i++) {</span>
<span class="fc" id="L757">         Attr nodeAttr = (Attr) ctxAttributes.item(i);</span>
<span class="fc" id="L758">         String nodeAttrName = nodeAttr.getNodeName();</span>
<span class="fc" id="L759">         String nodeAttrValue = nodeAttr.getValue();</span>
<span class="fc" id="L760">         boolean definesDefaultNS = nodeAttrName.equals(&quot;xmlns&quot;);</span>
<span class="fc" id="L761">         boolean definesArbitraryNS = nodeAttrName.startsWith(&quot;xmlns:&quot;);</span>

<span class="fc bfc" id="L763" title="All 2 branches covered.">         if (definesDefaultNS) {</span>
<span class="fc bfc" id="L764" title="All 2 branches covered.">            boolean attrValueEmpty = (nodeAttrValue.length() == 0);</span>

<span class="fc bfc" id="L766" title="All 2 branches covered.">            if (!attrValueEmpty) {</span>
<span class="fc" id="L767">               cat.debug(&quot;case 1&quot;);</span>

               /* case 1
                * definiert selbst einen nicht-leeren default NS - muss evtl. gel�scht werden
                * Suche in allen sichtbaren ancestors nach default NS.
                * L�schung kommt nur in Frage, falls �berhaupt visible ancestors existieren
                * Falls der erste Treffer identisch ist, muss der default NS gel�scht werden
                * Falls der erste Treffer ungleich ist, Suche abbrechen.
                * Falls kein Treffer gefunden wird, tue nichts
                */
<span class="fc" id="L777">               Attr a = nss.findFirstVisibleDefaultNSAttr();</span>

<span class="fc bfc" id="L779" title="All 2 branches covered.">               if (a != null) {</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">                  if (nodeAttrValue.equals(a.getValue())) {</span>
<span class="nc" id="L781">                     cat.debug(&quot;Here I call it&quot;);</span>
<span class="nc" id="L782">                     engineMakeInVisible(nodeAttr);</span>
                  } else {
                     continue nextNodeAttribute;
                  }
               } else {
<span class="fc" id="L787">                  cat.debug(&quot;Didn't find a visibleNS for &quot; + nodeAttr);</span>
               }
<span class="fc" id="L789">            } else {</span>
<span class="fc" id="L790">               cat.debug(&quot;case 2&quot;);</span>

               /* case 2
                * definiert selbst einen leeren default NS - muss evtl. gel�scht werden
                * Suche in allen sichtbaren ancestors nach default NS.
                * Falls der erste Treffer nicht-leer ist, Suche abbrechen.
                * Falls der erste Treffer leer ist, muss der default NS gel�scht werden
                * Falls kein Treffer gefunden wird, muss der default NS gel�scht werden
                */
<span class="fc" id="L799">               Attr a = nss.findFirstVisibleDefaultNSAttr();</span>

<span class="fc bfc" id="L801" title="All 2 branches covered.">               if (a != null) {</span>
<span class="fc bfc" id="L802" title="All 2 branches covered.">                  if (a.getValue().length() != 0) {</span>
<span class="fc" id="L803">                     continue nextNodeAttribute;</span>
                  } else {
<span class="fc" id="L805">                     engineMakeInVisible(nodeAttr);</span>
                  }
               } else {
<span class="fc" id="L808">                  engineMakeInVisible(nodeAttr);</span>
               }
            }
<span class="fc bfc" id="L811" title="All 2 branches covered.">         } else if (definesArbitraryNS) {</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">            boolean attrValueEmpty = (nodeAttrValue.length() == 0);</span>

<span class="pc bpc" id="L814" title="1 of 2 branches missed.">            if (!attrValueEmpty) {</span>
<span class="fc" id="L815">               cat.debug(&quot;case 3&quot;);</span>

               /* case 3
                * definiert selbst einen NS - muss evtl. gel�scht werden
                * Suche in allen sichtbaren ancestors nach dem gleichen NS.
                * Falls der erste Treffer identisch ist, muss der NS gel�scht werden
                * Falls der erste Treffer ungleich ist, Suche abbrechen.
                * Falls kein Treffer gefunden wird, tue nichts
                */
<span class="fc" id="L824">               Map ns = nss.findVisibleNonDefaultNSAttrs();</span>
<span class="fc" id="L825">               Attr a = (Attr) ns.get(nodeAttrName);</span>

<span class="fc bfc" id="L827" title="All 2 branches covered.">               if (a != null) {</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">                  if (nodeAttrValue.equals(a.getValue())) {</span>
<span class="fc" id="L829">                     engineMakeInVisible(nodeAttr);</span>
                  } else {
                     continue nextNodeAttribute;
                  }
               }
<span class="fc" id="L834">            } else {</span>
<span class="nc" id="L835">               cat.debug(&quot;case 4&quot;);</span>

               /* case 4
                * definiert selbst einen leeren NS - muss evtl. gel�scht werden
                */

               /** @todo check what we have to do here */
            }
         }
      }

      // loop through all ancestors and check whether we have to add some NS defs
<span class="fc bfc" id="L847" title="All 2 branches covered.">      if (nss.invisibleAncestorsContainDefaultNS()) {</span>
<span class="fc" id="L848">         Attr invisDefNS = nss.findFirstInvisibleDefaultNSAttr();</span>

<span class="fc" id="L850">         cat.debug(&quot;nss.findFirstInvisibleDefaultNSAttr() == &quot; + invisDefNS);</span>

<span class="pc bpc" id="L852" title="1 of 4 branches missed.">         if ((invisDefNS != null) &amp;&amp; (invisDefNS.getValue().length() != 0)) {</span>
<span class="fc" id="L853">            cat.debug(&quot;case 5&quot;);</span>

            /* case 5
             * in einem invisible zwischen ihm und dem n�chsten visible wird ein nicht-leerer default NS definiert - muss evtl. hinzugef�gt werden
             * Suche alle visible ancestors �ber dem invisible definierenden nach default NS ab.
             * Falls der erste Treffer identisch ist, tue nichts
             * Falls der erste Treffer ungleich ist, f�ge die invisble default NS def. in den Knoten ein
             * Falls kein Treffer gefunden wird, f�ge die invisble default NS def. in den Knoten ein
             */
<span class="fc" id="L862">            Attr visDefNS = nss.findFirstVisibleDefaultNSAttr();</span>

<span class="pc bpc" id="L864" title="1 of 2 branches missed.">            if (visDefNS != null) {</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">               if (invisDefNS.getValue().equals(visDefNS.getValue())) {</span>
                  ;
               } else {
<span class="nc" id="L868">                  Document doc = ctxNode.getOwnerDocument();</span>
<span class="nc" id="L869">                  Attr newAttr =</span>
                     doc.createAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;);

<span class="nc" id="L872">                  newAttr.setNodeValue(invisDefNS.getValue());</span>
<span class="nc" id="L873">                  ((Element) ctxNode).setAttributeNode(newAttr);</span>
<span class="nc" id="L874">                  engineMakeVisible(newAttr);</span>
<span class="nc" id="L875">                  this._attrsToBeRemovedAfterC14n.add(newAttr);</span>
<span class="nc" id="L876">               }</span>
            } else {
<span class="fc bfc" id="L878" title="All 2 branches covered.">               if (((Element) ctxNode).getAttributeNode(&quot;xmlns&quot;) == null) {</span>
<span class="fc" id="L879">                  Document doc = ctxNode.getOwnerDocument();</span>
<span class="fc" id="L880">                  Attr newAttr =</span>
                     doc.createAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;);

<span class="fc" id="L883">                  newAttr.setValue(invisDefNS.getValue());</span>
<span class="fc" id="L884">                  ((Element) ctxNode).setAttributeNode(newAttr);</span>
<span class="fc" id="L885">                  engineMakeVisible(newAttr);</span>
<span class="fc" id="L886">                  this._attrsToBeRemovedAfterC14n.add(newAttr);</span>
               }
            }
<span class="fc" id="L889">         } else {</span>
<span class="fc" id="L890">            cat.debug(&quot;case 6&quot;);</span>

            /* case 6
             * in einem invisible zwischen ihm und dem n�chsten visible wird ein leerer default NS definiert - muss evtl. hinzugef�gt werden
             * Suche alle visible ancestors �ber dem invisible definierenden nach default NS ab.
             * Falls keine visible ancestors existieren, tue nichts
             * Falls der erste Treffer auch leer ist, tue nichts
             * Falls der erste Treffer nicht leer ist, f�ge die invisble default NS def. in den Knoten ein
             * Falls kein Treffer gefunden wird, ftue nichts
             */
<span class="fc" id="L900">            Attr visDefNS = nss.findFirstVisibleDefaultNSAttr();</span>

<span class="pc bpc" id="L902" title="1 of 2 branches missed.">            if (visDefNS != null) {</span>
<span class="pc bpc" id="L903" title="1 of 2 branches missed.">               if (invisDefNS.getValue().equals(visDefNS.getValue())) {</span>
                  ;
               } else {
<span class="fc" id="L906">                  Document doc = ctxNode.getOwnerDocument();</span>
<span class="fc" id="L907">                  Attr newAttr =</span>
                     doc.createAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;);

<span class="fc" id="L910">                  newAttr.setValue(invisDefNS.getValue());</span>
<span class="fc" id="L911">                  ((Element) ctxNode).setAttributeNode(newAttr);</span>
<span class="fc" id="L912">                  engineMakeVisible(newAttr);</span>
<span class="fc" id="L913">                  this._attrsToBeRemovedAfterC14n.add(newAttr);</span>
               }
            } else {
               ;
            }
         }
      }

<span class="fc bfc" id="L921" title="All 2 branches covered.">      if (nss.invisibleAncestorsContainNonDefaultNS()) {</span>
<span class="fc" id="L922">         Map invisNS = nss.findInvisibleNonDefaultNSAttrs();</span>
<span class="fc" id="L923">         Iterator invisIterator = invisNS.keySet().iterator();</span>

<span class="fc bfc" id="L925" title="All 2 branches covered.">         while (invisIterator.hasNext()) {</span>
<span class="fc" id="L926">            String invisAttrName = (String) invisIterator.next();</span>
<span class="fc" id="L927">            Attr invisAttr = (Attr) invisNS.get(invisAttrName);</span>

<span class="fc" id="L929">            cat.debug(&quot;7 &quot; + invisAttrName + &quot;='&quot; + invisAttr.getValue() + &quot;'&quot;);</span>

<span class="pc bpc" id="L931" title="1 of 2 branches missed.">            if (invisAttr.getValue().length() != 0) {</span>
<span class="fc" id="L932">               cat.debug(&quot;case 7&quot;);</span>

               /* case 7
                * in einem invisible zwischen ihm und dem n�chsten visible wird ein nicht-leerer NS definiert - muss evtl. hinzugef�gt werden
                * Suche alle visible ancestors �ber dem invisible definierenden nach dem NS ab.
                * Falls der erste Treffer identisch ist, tue nichts
                * Falls der erste Treffer ungleich ist, f�ge die invisble NS def. in den Knoten ein
                * Falls kein Treffer gefunden wird, f�ge die invisble NS def. in den Knoten ein
                */
<span class="fc" id="L941">               Map visNS = nss.findVisibleNonDefaultNSAttrs();</span>
<span class="fc" id="L942">               Attr visAttr = (Attr) visNS.get(invisAttrName);</span>

<span class="pc bpc" id="L944" title="1 of 2 branches missed.">               if (visAttr != null) {</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                  if (invisAttr.getValue().equals(visAttr.getValue())) {</span>
                     ;
                  } else {
<span class="nc" id="L948">                     Document doc = ctxNode.getOwnerDocument();</span>
<span class="nc" id="L949">                     Attr newAttr =</span>
                        doc.createAttributeNS(Constants.NamespaceSpecNS,
                                              invisAttrName);

<span class="nc" id="L953">                     newAttr.setValue(invisAttr.getValue());</span>
<span class="nc" id="L954">                     ((Element) ctxNode).setAttributeNode(newAttr);</span>
<span class="nc" id="L955">                     engineMakeVisible(newAttr);</span>
<span class="nc" id="L956">                     this._attrsToBeRemovedAfterC14n.add(newAttr);</span>
<span class="nc" id="L957">                  }</span>
               } else {
<span class="fc" id="L959">                  Document doc = ctxNode.getOwnerDocument();</span>
<span class="fc" id="L960">                  Attr newAttr =</span>
                     doc.createAttributeNS(Constants.NamespaceSpecNS,
                                           invisAttrName);

<span class="fc" id="L964">                  newAttr.setValue(invisAttr.getValue());</span>
<span class="fc" id="L965">                  ((Element) ctxNode).setAttributeNode(newAttr);</span>
<span class="fc" id="L966">                  engineMakeVisible(newAttr);</span>
<span class="fc" id="L967">                  this._attrsToBeRemovedAfterC14n.add(newAttr);</span>
               }
<span class="fc" id="L969">            } else {</span>
<span class="nc" id="L970">               cat.debug(&quot;case 8&quot;);</span>

               /* case 8
                * in einem invisible zwischen ihm und dem n�chsten visible wird ein leerer NS definiert - muss evtl. hinzugef�gt werden
                */

               /** @todo check what we have to do here */
            }
<span class="fc" id="L978">         }</span>
      }
<span class="fc" id="L980">   }</span>

   /**
    * Method algo
    *
    * @param ctxNode
    * @param attributeName
    * @return
    */
   private Object[] processXmlAttributesAlgo(Node ctxNode,
                                             String attributeName) {

      // cat.debug(((Element) ctxNode).getTagName() + &quot; (&quot; + id(ctxNode) + &quot;) hat \&quot;&quot; + ((Element) ctxNode).getAttribute(attributeName) + &quot;\&quot;&quot;);
<span class="fc" id="L993">      Object result[] = new Object[2];</span>
<span class="fc" id="L994">      boolean deleteOriginalAttribute = false;</span>
<span class="fc" id="L995">      String ctxAttrValue = null;</span>

<span class="pc bpc" id="L997" title="1 of 4 branches missed.">      if (((Element) ctxNode).getAttribute(attributeName) == null</span>
              || ((Element) ctxNode).getAttribute(attributeName).length()
                 == 0) {
<span class="fc" id="L1000">         Vector parents = XMLUtils.getAncestorElements(ctxNode);</span>

<span class="fc" id="L1002">         ctxAttrValue = null;</span>

         // bottom up
<span class="pc bpc" id="L1005" title="1 of 2 branches missed.">         parent: for (int i = 0; i &lt; parents.size(); i++) {</span>
<span class="fc" id="L1006">            Element currentParent = (Element) parents.elementAt(i);</span>

<span class="fc bfc" id="L1008" title="All 4 branches covered.">            if (!engineVisible(currentParent) &amp;&amp; (ctxAttrValue == null)) {</span>
<span class="fc" id="L1009">               ctxAttrValue = currentParent.getAttribute(attributeName);</span>

               // cat.debug(&quot;set to &quot; + ctxAttrValue);
<span class="pc bpc" id="L1012" title="1 of 4 branches missed.">            } else if (engineVisible(currentParent) &amp;&amp; (ctxAttrValue != null)) {</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">               if (ctxAttrValue</span>
                       .equals(currentParent.getAttribute(attributeName))) {
<span class="fc" id="L1015">                  ctxAttrValue = null;</span>

                  // cat.debug(&quot;set to &quot; + ctxAttrValue);
               }

               break parent;
            }
         }
<span class="fc" id="L1023">      } else {</span>
<span class="fc" id="L1024">         Vector parents = XMLUtils.getAncestorElements(ctxNode);</span>

<span class="fc" id="L1026">         ctxAttrValue = ((Element) ctxNode).getAttribute(attributeName);</span>

<span class="pc bpc" id="L1028" title="1 of 2 branches missed.">         parent: for (int i = 0; i &lt; parents.size(); i++) {</span>
<span class="fc" id="L1029">            Element currentParent = (Element) parents.elementAt(i);</span>

<span class="pc bpc" id="L1031" title="2 of 6 branches missed.">            if (engineVisible(currentParent)</span>
                    &amp;&amp; (currentParent.getAttribute(attributeName) != null)
                    &amp;&amp; (ctxAttrValue != null)) {
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">               if (ctxAttrValue</span>
                       .equals(currentParent.getAttribute(attributeName))) {
<span class="fc" id="L1036">                  ctxAttrValue = null;</span>
<span class="fc" id="L1037">                  deleteOriginalAttribute = true;</span>

<span class="fc" id="L1039">                  cat.debug(&quot;set to &quot; + ctxAttrValue);</span>
               }

               break parent;
            }
         }
      }

<span class="fc" id="L1047">      result[0] = ctxAttrValue;</span>
<span class="fc" id="L1048">      result[1] = new Boolean(deleteOriginalAttribute);</span>

<span class="fc" id="L1050">      return result;</span>
   }

   /**
    * This method uses the {@link Document#isSupported} method to check whether
    * the &lt;CODE&gt;Traversal&lt;/CODE&gt; feature is available.
    *
    * @param document
    * @throws CanonicalizationException
    */
   private void checkTraversability(Document document)
           throws CanonicalizationException {

<span class="pc bpc" id="L1063" title="1 of 2 branches missed.">      if (!document.isSupported(&quot;Traversal&quot;, &quot;2.0&quot;)) {</span>
<span class="nc" id="L1064">         cat.fatal(&quot;This DOM Document does not support Traversal&quot;);</span>

<span class="nc" id="L1066">         Object exArgs[] = {</span>
            document.getImplementation().getClass().getName() };

<span class="nc" id="L1069">         throw new CanonicalizationException(</span>
            &quot;c14n.Canonicalizer.TraversalNotSupported&quot;, exArgs);
      }
<span class="fc" id="L1072">   }</span>

   /**
    * Method checkForRelativeNamespace
    *
    * @param ctxNode
    * @throws CanonicalizationException
    */
   protected static void checkForRelativeNamespace(Node ctxNode)
           throws CanonicalizationException {

<span class="pc bpc" id="L1083" title="2 of 4 branches missed.">      if ((ctxNode != null) &amp;&amp; (ctxNode.getNodeType() == Node.ELEMENT_NODE)) {</span>
<span class="fc" id="L1084">         NamedNodeMap attributes = ctxNode.getAttributes();</span>

<span class="fc" id="L1086">         cat.debug(&quot;checkForRelativeNamespace(&quot; + ctxNode + &quot;)&quot;);</span>

<span class="fc bfc" id="L1088" title="All 2 branches covered.">         for (int i = 0; i &lt; attributes.getLength(); i++) {</span>
<span class="fc" id="L1089">            cat.debug(&quot;checkForRelativeNamespace &quot; + (Attr) attributes.item(i));</span>
<span class="fc" id="L1090">            C14nHelper.assertNotRelativeNS((Attr) attributes.item(i));</span>
         }
<span class="fc" id="L1092">      } else {</span>
<span class="nc" id="L1093">         cat.error(&quot;Called checkForRelativeNamespace() on a &quot; + ctxNode);</span>
      }
<span class="fc" id="L1095">   }</span>

   /**
    * Method engineSetRemoveNSAttrs
    *
    * @param remove
    */
   public void engineSetRemoveNSAttrs(boolean remove) {
<span class="nc" id="L1103">      this._removeNSattrsAfterC14n = remove;</span>
<span class="nc" id="L1104">   }</span>

   /**
    * Method engineGetRemoveNSAttrs
    *
    * @return
    */
   public boolean engineGetRemoveNSAttrs() {
<span class="fc" id="L1112">      return this._removeNSattrsAfterC14n;</span>
   }

   /**
    * Iterates over all Attributes which have been added during c14n and
    * removes them.
    */
   private void removeNSAttrs() {

<span class="fc bfc" id="L1121" title="All 2 branches covered.">      for (int i = 0; i &lt; this._attrsToBeRemovedAfterC14n.size(); i++) {</span>
<span class="fc" id="L1122">         Attr currentNSdecl =</span>
            (Attr) this._attrsToBeRemovedAfterC14n.elementAt(i);
<span class="fc" id="L1124">         Element ownerElem = currentNSdecl.getOwnerElement();</span>

<span class="fc" id="L1126">         ownerElem.removeAttributeNode(currentNSdecl);</span>
      }

<span class="fc" id="L1129">      this._attrsToBeRemovedAfterC14n.clear();</span>
<span class="fc" id="L1130">   }</span>

   static {
<span class="fc" id="L1133">      org.apache.xml.security.Init.init();</span>
<span class="fc" id="L1134">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>