<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Canonicalizer20010315.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.c14n.implementations</a> &gt; <span class="el_source">Canonicalizer20010315.java</span></div><h1>Canonicalizer20010315.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.c14n.implementations;



import java.io.*;
import java.util.*;
import javax.xml.parsers.*;
import javax.xml.transform.TransformerException;
import org.apache.xpath.CachedXPathAPI;
import org.w3c.dom.*;
import org.xml.sax.*;
import org.apache.xml.security.c14n.*;
import org.apache.xml.security.c14n.helper.*;
import org.apache.xml.security.utils.*;


/**
 * Class Canonicalizer20010315
 *
 * @author $Author: dohy $
 * @version $Revision: 1.1.1.1 $
 */
public abstract class Canonicalizer20010315 extends CanonicalizerSpi {
   //J-
<span class="fc" id="L83">   boolean _includeComments = false;</span>

<span class="fc" id="L85">   Set _xpathNodeSet = null;</span>

<span class="fc" id="L87">   Document _doc = null;</span>
<span class="fc" id="L88">   Element _documentElement = null;</span>
<span class="fc" id="L89">   Node _rootNodeOfC14n = null;</span>

<span class="fc" id="L91">   Writer _writer = null;</span>
   //J+

   /**
    * Constructor Canonicalizer20010315
    *
    * @param includeComments
    */
<span class="fc" id="L99">   public Canonicalizer20010315(boolean includeComments) {</span>
<span class="fc" id="L100">      this._includeComments = includeComments;</span>
<span class="fc" id="L101">   }</span>

   /**
    * Method engineCanonicalizeSubTree
    *
    * @param rootNode
    * @return
    * @throws CanonicalizationException
    */
   public byte[] engineCanonicalizeSubTree(Node rootNode)
           throws CanonicalizationException {

<span class="fc" id="L113">      this._rootNodeOfC14n = rootNode;</span>
<span class="fc" id="L114">      this._doc = XMLUtils.getOwnerDocument(this._rootNodeOfC14n);</span>
<span class="fc" id="L115">      this._documentElement = this._doc.getDocumentElement();</span>

      try {
<span class="fc" id="L118">         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>

<span class="fc" id="L120">         this._writer = new OutputStreamWriter(baos, Canonicalizer.ENCODING);</span>

         Map inscopeNamespaces;

<span class="fc bfc" id="L124" title="All 2 branches covered.">         if (rootNode.getNodeType() == Node.ELEMENT_NODE) {</span>
<span class="fc" id="L125">            inscopeNamespaces = this.getinscopeNamespaces((Element) rootNode);</span>
         } else {
<span class="fc" id="L127">            inscopeNamespaces = new HashMap();</span>
         }

<span class="fc" id="L130">         Map alreadyVisible = new HashMap();</span>

<span class="fc" id="L132">         this.canonicalizeSubTree(rootNode, inscopeNamespaces, alreadyVisible);</span>
<span class="fc" id="L133">         this._writer.close();</span>

<span class="fc" id="L135">         return baos.toByteArray();</span>
<span class="nc" id="L136">      } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L137">         throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L138">      } catch (IOException ex) {</span>
<span class="nc" id="L139">         throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
      } finally {

         // mark contents for garbage collector
<span class="fc" id="L143">         this._rootNodeOfC14n = null;</span>
<span class="fc" id="L144">         this._doc = null;</span>
<span class="fc" id="L145">         this._documentElement = null;</span>
<span class="fc" id="L146">         this._writer = null;</span>
      }
   }

   /**
    * Method canonicalizeSubTree
    *
    * @param currentNode
    * @param inscopeNamespaces
    * @param alreadyVisible
    * @throws CanonicalizationException
    * @throws IOException
    */
   void canonicalizeSubTree(
           Node currentNode, Map inscopeNamespaces, Map alreadyVisible)
              throws CanonicalizationException, IOException {

<span class="fc" id="L163">      int currentNodeType = currentNode.getNodeType();</span>

<span class="pc bpc" id="L165" title="1 of 7 branches missed.">      switch (currentNodeType) {</span>

      case Node.DOCUMENT_TYPE_NODE :
      default :
<span class="fc" id="L169">         break;</span>

      case Node.ENTITY_NODE :
      case Node.NOTATION_NODE :
      case Node.DOCUMENT_FRAGMENT_NODE :
      case Node.ATTRIBUTE_NODE :

         // illegal node type during traversal
<span class="nc" id="L177">         throw new CanonicalizationException(&quot;empty&quot;);</span>
      case Node.DOCUMENT_NODE :
<span class="fc" id="L179">         for (Node currentChild = currentNode.getFirstChild();</span>
<span class="fc bfc" id="L180" title="All 2 branches covered.">                 currentChild != null;</span>
<span class="fc" id="L181">                 currentChild = currentChild.getNextSibling()) {</span>
<span class="fc" id="L182">            canonicalizeSubTree(currentChild, inscopeNamespaces,</span>
                                alreadyVisible);
         }
<span class="fc" id="L185">         break;</span>

      case Node.COMMENT_NODE :
<span class="fc bfc" id="L188" title="All 2 branches covered.">         if (this._includeComments) {</span>
<span class="fc" id="L189">            int position = getPositionRelativeToDocumentElement(currentNode);</span>

<span class="fc bfc" id="L191" title="All 2 branches covered.">            if (position == NODE_AFTER_DOCUMENT_ELEMENT) {</span>
<span class="fc" id="L192">               this._writer.write(&quot;\n&quot;);</span>
            }

<span class="fc" id="L195">            outputCommentToWriter((Comment) currentNode);</span>

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">            if (position == NODE_BEFORE_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L198">               this._writer.write(&quot;\n&quot;);</span>
            }
<span class="fc" id="L200">         }</span>
         break;

      case Node.PROCESSING_INSTRUCTION_NODE :
<span class="fc" id="L204">         int position = getPositionRelativeToDocumentElement(currentNode);</span>

<span class="fc bfc" id="L206" title="All 2 branches covered.">         if (position == NODE_AFTER_DOCUMENT_ELEMENT) {</span>
<span class="fc" id="L207">            this._writer.write(&quot;\n&quot;);</span>
         }

<span class="fc" id="L210">         outputPItoWriter((ProcessingInstruction) currentNode);</span>

<span class="fc bfc" id="L212" title="All 2 branches covered.">         if (position == NODE_BEFORE_DOCUMENT_ELEMENT) {</span>
<span class="fc" id="L213">            this._writer.write(&quot;\n&quot;);</span>
         }
         break;

      case Node.TEXT_NODE :
      case Node.CDATA_SECTION_NODE :
<span class="fc" id="L219">         outputTextToWriter(currentNode.getNodeValue());</span>
<span class="fc" id="L220">         break;</span>

      case Node.ELEMENT_NODE :
<span class="fc" id="L223">         Element currentElement = (Element) currentNode;</span>

<span class="fc" id="L225">         this._writer.write(&quot;&lt;&quot;);</span>
<span class="fc" id="L226">         this._writer.write(currentElement.getTagName());</span>

<span class="fc" id="L228">         List attrs =</span>
            updateinscopeNamespacesAndReturnVisibleAttrs(currentElement,
               inscopeNamespaces, alreadyVisible);

         // we output all Attrs which are available
<span class="fc bfc" id="L233" title="All 2 branches covered.">         for (int i = 0; i &lt; attrs.size(); i++) {</span>
<span class="fc" id="L234">            outputAttrToWriter(((Attr) attrs.get(i)).getNodeName(),</span>
                               ((Attr) attrs.get(i)).getNodeValue());
         }

<span class="fc" id="L238">         this._writer.write(&quot;&gt;&quot;);</span>

         // traversal
<span class="fc" id="L241">         for (Node currentChild = currentNode.getFirstChild();</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">                 currentChild != null;</span>
<span class="fc" id="L243">                 currentChild = currentChild.getNextSibling()) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">            if (currentChild.getNodeType() == Node.ELEMENT_NODE) {</span>

               /*
                * We must 'clone' the inscopeXMLAttrs to allow the descendants
                * to mess around in their own map
                */
<span class="fc" id="L250">               canonicalizeSubTree(currentChild,</span>
                                   new HashMap(inscopeNamespaces),
                                   new HashMap(alreadyVisible));
            } else {
<span class="fc" id="L254">               canonicalizeSubTree(currentChild, inscopeNamespaces,</span>
                                   alreadyVisible);
            }
         }

<span class="fc" id="L259">         this._writer.write(&quot;&lt;/&quot;);</span>
<span class="fc" id="L260">         this._writer.write(currentElement.getTagName());</span>
<span class="fc" id="L261">         this._writer.write(&quot;&gt;&quot;);</span>
         break;
      }
<span class="fc" id="L264">   }</span>

   /**
    * This method updates the inscopeXMLAttrs based on the currentElement and
    * returns the Attr[]s to be outputted.
    *
    * @param inscopeXMLAttrs is changed by this method !!!
    * @param currentElement
    * @param alreadyVisible
    * @return the Attr[]s to be outputted
    * @throws CanonicalizationException
    */
   List updateinscopeNamespacesAndReturnVisibleAttrs(
           Element currentElement, Map inscopeXMLAttrs, Map alreadyVisible)
              throws CanonicalizationException {

<span class="fc" id="L280">      Vector ns = new Vector();</span>
<span class="fc" id="L281">      Vector at = new Vector();</span>
<span class="fc" id="L282">      NamedNodeMap attributes = currentElement.getAttributes();</span>
<span class="fc" id="L283">      int attributesLength = attributes.getLength();</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">      for (int i = 0; i &lt; attributesLength; i++) {</span>
<span class="fc" id="L286">         Attr currentAttr = (Attr) attributes.item(i);</span>
<span class="fc" id="L287">         String name = currentAttr.getNodeName();</span>
<span class="fc" id="L288">         String value = currentAttr.getValue();</span>

<span class="fc bfc" id="L290" title="All 4 branches covered.">         if (name.equals(&quot;xmlns&quot;) &amp;&amp; value.equals(&quot;&quot;)) {</span>

            // undeclare default namespace
<span class="fc" id="L293">            inscopeXMLAttrs.remove(&quot;xmlns&quot;);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">         } else if (name.startsWith(&quot;xmlns&quot;)) {</span>

            // update inscope namespaces
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            if (!value.equals(&quot;&quot;)) {</span>
<span class="fc" id="L298">               inscopeXMLAttrs.put(name, value);</span>
            }
<span class="fc bfc" id="L300" title="All 2 branches covered.">         } else if (name.startsWith(&quot;xml:&quot;)) {</span>

            // output xml:blah features
<span class="fc" id="L303">            inscopeXMLAttrs.put(name, value);</span>
         } else {

            // output regular attributes
<span class="fc" id="L307">            at.add(currentAttr);</span>
         }
      }

      {

         // check whether default namespace must be deleted
<span class="fc bfc" id="L314" title="All 4 branches covered.">         if (alreadyVisible.containsKey(&quot;xmlns&quot;)</span>
                 &amp;&amp;!inscopeXMLAttrs.containsKey(&quot;xmlns&quot;)) {

            // undeclare default namespace
<span class="fc" id="L318">            alreadyVisible.remove(&quot;xmlns&quot;);</span>

<span class="fc" id="L320">            Attr a = this._doc.createAttributeNS(Constants.NamespaceSpecNS,</span>
                                                 &quot;xmlns&quot;);

<span class="fc" id="L323">            a.setValue(&quot;&quot;);</span>
<span class="fc" id="L324">            ns.add(a);</span>
         }
      }

<span class="fc bfc" id="L328" title="All 2 branches covered.">      boolean isOrphanNode = currentElement == this._rootNodeOfC14n;</span>
<span class="fc" id="L329">      Iterator it = inscopeXMLAttrs.keySet().iterator();</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">      while (it.hasNext()) {</span>
<span class="fc" id="L332">         String name = (String) it.next();</span>
<span class="fc" id="L333">         String inscopeValue = (String) inscopeXMLAttrs.get(name);</span>

<span class="pc bpc" id="L335" title="2 of 8 branches missed.">         if (name.startsWith(&quot;xml:&quot;)</span>
                 &amp;&amp; (isOrphanNode
                     ||!(alreadyVisible.containsKey(name)
                         &amp;&amp; alreadyVisible.get(name).equals(inscopeValue)))) {
<span class="fc" id="L339">            alreadyVisible.put(name, inscopeValue);</span>

<span class="fc" id="L341">            Attr a =</span>
               this._doc.createAttributeNS(Constants.XML_LANG_SPACE_SpecNS,
                                           name);

<span class="fc" id="L345">            a.setValue(inscopeValue);</span>
<span class="fc" id="L346">            at.add(a);</span>
<span class="pc bpc" id="L347" title="1 of 6 branches missed.">         } else if (!alreadyVisible.containsKey(name)</span>
                    || (alreadyVisible.containsKey(name)
                        &amp;&amp;!alreadyVisible.get(name).equals(inscopeValue))) {
<span class="fc bfc" id="L350" title="All 2 branches covered.">            if (C14nHelper.namespaceIsRelative(inscopeValue)) {</span>
<span class="fc" id="L351">               Object exArgs[] = { currentElement.getTagName(), name,</span>
                                   inscopeValue };

<span class="fc" id="L354">               throw new CanonicalizationException(</span>
                  &quot;c14n.Canonicalizer.RelativeNamespace&quot;, exArgs);
            }

<span class="fc" id="L358">            alreadyVisible.put(name, inscopeValue);</span>

<span class="fc" id="L360">            Attr a = this._doc.createAttributeNS(Constants.NamespaceSpecNS,</span>
                                                 name);

<span class="fc" id="L363">            a.setValue(inscopeValue);</span>
<span class="fc" id="L364">            ns.add(a);</span>
         }
<span class="fc" id="L366">      }</span>

<span class="fc" id="L368">      Collections.sort(ns,</span>
                       new org.apache.xml.security.c14n.helper.NSAttrCompare());
<span class="fc" id="L370">      Collections.sort(at,</span>
                       new org.apache.xml.security.c14n.helper
                          .NonNSAttrCompare());
<span class="fc" id="L373">      ns.addAll(at);</span>

<span class="fc" id="L375">      return ns;</span>
   }

   /**
    * Collects all relevant xml:* and xmlns:* attributes from all ancestor
    * Elements from rootNode and creates a Map containg the attribute
    * names/values.
    *
    * @param apexElement
    * @return
    */
   public static Map getinscopeNamespaces(Element apexElement) {

<span class="fc" id="L388">      Map result = new HashMap();</span>

<span class="fc" id="L390">      for (Node parent = apexElement.getParentNode();</span>
<span class="pc bpc" id="L391" title="1 of 4 branches missed.">              ((parent != null) &amp;&amp; (parent.getNodeType() == Node.ELEMENT_NODE));</span>
<span class="fc" id="L392">              parent = parent.getParentNode()) {</span>
<span class="fc" id="L393">         NamedNodeMap attributes = parent.getAttributes();</span>
<span class="fc" id="L394">         int nrOfAttrs = attributes.getLength();</span>

<span class="fc bfc" id="L396" title="All 2 branches covered.">         for (int i = 0; i &lt; nrOfAttrs; i++) {</span>
<span class="fc" id="L397">            Attr currentAttr = (Attr) attributes.item(i);</span>
<span class="fc" id="L398">            String name = currentAttr.getNodeName();</span>
<span class="fc" id="L399">            String value = currentAttr.getValue();</span>

<span class="pc bpc" id="L401" title="1 of 4 branches missed.">            if (name.equals(&quot;xmlns&quot;) &amp;&amp; value.equals(&quot;&quot;)) {</span>
               ;    // result.remove(name);
<span class="pc bpc" id="L403" title="1 of 6 branches missed.">            } else if (name.startsWith(&quot;xml:&quot;)</span>
                       || (name.startsWith(&quot;xmlns&quot;) &amp;&amp;!value.equals(&quot;&quot;))) {
<span class="fc bfc" id="L405" title="All 2 branches covered.">               if (!result.containsKey(name)) {</span>
<span class="fc" id="L406">                  result.put(name, value);</span>
               }
            }
         }
      }

<span class="fc" id="L412">      return result;</span>
   }

   //J-
   private static final int NODE_BEFORE_DOCUMENT_ELEMENT = -1;
   private static final int NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT = 0;
   private static final int NODE_AFTER_DOCUMENT_ELEMENT = 1;
   //J+

   /**
    * Checks whether a Comment or ProcessingInstruction is before or after the
    * document element. This is needed for prepending or appending &quot;\n&quot;s.
    *
    * @param currentNode comment or pi to check
    * @return NODE_BEFORE_DOCUMENT_ELEMENT, NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT or NODE_AFTER_DOCUMENT_ELEMENT
    * @see NODE_BEFORE_DOCUMENT_ELEMENT
    * @see NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT
    * @see NODE_AFTER_DOCUMENT_ELEMENT
    */
   static int getPositionRelativeToDocumentElement(Node currentNode) {

<span class="pc bpc" id="L433" title="1 of 2 branches missed.">      if (currentNode == null) {</span>
<span class="nc" id="L434">         return NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
      }

<span class="fc" id="L437">      Document doc = currentNode.getOwnerDocument();</span>

<span class="fc bfc" id="L439" title="All 2 branches covered.">      if (currentNode.getParentNode() != doc) {</span>
<span class="fc" id="L440">         return NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
      }

<span class="fc" id="L443">      Element documentElement = doc.getDocumentElement();</span>

<span class="pc bpc" id="L445" title="1 of 2 branches missed.">      if (documentElement == null) {</span>
<span class="nc" id="L446">         return NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
      }

<span class="pc bpc" id="L449" title="1 of 2 branches missed.">      if (documentElement == currentNode) {</span>
<span class="nc" id="L450">         return NODE_NOT_BEFORE_OR_AFTER_DOCUMENT_ELEMENT;</span>
      }

<span class="fc bfc" id="L453" title="All 2 branches covered.">      for (Node x = currentNode; x != null; x = x.getNextSibling()) {</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">         if (x == documentElement) {</span>
<span class="fc" id="L455">            return NODE_BEFORE_DOCUMENT_ELEMENT;</span>
         }
      }

<span class="fc" id="L459">      return NODE_AFTER_DOCUMENT_ELEMENT;</span>
   }

   /**
    * Method engineCanonicalizeXPathNodeSet
    *
    * @param xpathNodeSet
    * @return
    * @throws CanonicalizationException
    */
   public byte[] engineCanonicalizeXPathNodeSet(Set xpathNodeSet)
           throws CanonicalizationException {

<span class="fc" id="L472">      this._xpathNodeSet = xpathNodeSet;</span>

<span class="pc bpc" id="L474" title="1 of 2 branches missed.">      if (this._xpathNodeSet.size() == 0) {</span>
<span class="nc" id="L475">         return new byte[0];</span>
      }

<span class="pc bpc" id="L478" title="1 of 2 branches missed.">      if (this._doc == null) {</span>
<span class="fc" id="L479">         Node n = (Node) this._xpathNodeSet.iterator().next();</span>

<span class="fc" id="L481">         this._doc = XMLUtils.getOwnerDocument(n);</span>
<span class="fc" id="L482">         this._documentElement = this._doc.getDocumentElement();</span>
      }

      try {
<span class="fc" id="L486">         ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>

<span class="fc" id="L488">         this._writer = new OutputStreamWriter(baos, Canonicalizer.ENCODING);</span>

<span class="fc" id="L490">         this.canonicalizeXPathNodeSet(this._doc, true,</span>
                                       new C14nCtx());
<span class="fc" id="L492">         this._writer.close();</span>

<span class="fc" id="L494">         return baos.toByteArray();</span>
<span class="nc" id="L495">      } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L496">         throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
<span class="nc" id="L497">      } catch (IOException ex) {</span>
<span class="nc" id="L498">         throw new CanonicalizationException(&quot;empty&quot;, ex);</span>
      } finally {
<span class="pc" id="L500">         this._xpathNodeSet = null;</span>
<span class="pc" id="L501">         this._rootNodeOfC14n = null;</span>
<span class="pc" id="L502">         this._doc = null;</span>
<span class="pc" id="L503">         this._documentElement = null;</span>
<span class="pc" id="L504">         this._writer = null;</span>
      }
   }

   /**
    * Method canonicalizeXPathNodeSet
    *
    * @param currentNode
    * @param parentIsVisible
    * @param ctx
    * @throws CanonicalizationException
    * @throws IOException
    */
   void canonicalizeXPathNodeSet(
           Node currentNode, boolean parentIsVisible, C14nCtx ctx)
              throws CanonicalizationException, IOException {

<span class="fc" id="L521">      int currentNodeType = currentNode.getNodeType();</span>
<span class="fc" id="L522">      boolean currentNodeIsVisible = this._xpathNodeSet.contains(currentNode);</span>

<span class="pc bpc" id="L524" title="2 of 7 branches missed.">      switch (currentNodeType) {</span>

      case Node.DOCUMENT_TYPE_NODE :
      default :
<span class="fc" id="L528">         break;</span>

      case Node.ENTITY_NODE :
      case Node.NOTATION_NODE :
      case Node.DOCUMENT_FRAGMENT_NODE :
      case Node.ATTRIBUTE_NODE :
<span class="nc" id="L534">         throw new CanonicalizationException(&quot;empty&quot;);</span>
      case Node.DOCUMENT_NODE :
<span class="fc" id="L536">         for (Node currentChild = currentNode.getFirstChild();</span>
<span class="fc bfc" id="L537" title="All 2 branches covered.">                 currentChild != null;</span>
<span class="fc" id="L538">                 currentChild = currentChild.getNextSibling()) {</span>
<span class="fc" id="L539">            canonicalizeXPathNodeSet(currentChild, currentNodeIsVisible, ctx);</span>
         }
<span class="fc" id="L541">         break;</span>

      case Node.COMMENT_NODE :
<span class="fc bfc" id="L544" title="All 4 branches covered.">         if (this._includeComments &amp;&amp; currentNodeIsVisible) {</span>
<span class="fc" id="L545">            int position = getPositionRelativeToDocumentElement(currentNode);</span>

<span class="fc bfc" id="L547" title="All 2 branches covered.">            if (position == NODE_AFTER_DOCUMENT_ELEMENT) {</span>
<span class="fc" id="L548">               this._writer.write(&quot;\n&quot;);</span>
            }

<span class="fc" id="L551">            outputCommentToWriter((Comment) currentNode);</span>

<span class="fc bfc" id="L553" title="All 2 branches covered.">            if (position == NODE_BEFORE_DOCUMENT_ELEMENT) {</span>
<span class="fc" id="L554">               this._writer.write(&quot;\n&quot;);</span>
            }
<span class="fc" id="L556">         }</span>
         break;

      case Node.PROCESSING_INSTRUCTION_NODE :
<span class="nc bnc" id="L560" title="All 2 branches missed.">         if (currentNodeIsVisible) {</span>
<span class="nc" id="L561">            int position = getPositionRelativeToDocumentElement(currentNode);</span>

<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (position == NODE_AFTER_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L564">               this._writer.write(&quot;\n&quot;);</span>
            }

<span class="nc" id="L567">            outputPItoWriter((ProcessingInstruction) currentNode);</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (position == NODE_BEFORE_DOCUMENT_ELEMENT) {</span>
<span class="nc" id="L570">               this._writer.write(&quot;\n&quot;);</span>
            }
<span class="nc" id="L572">         }</span>
         break;

      case Node.TEXT_NODE :
      case Node.CDATA_SECTION_NODE :
<span class="fc bfc" id="L577" title="All 2 branches covered.">         if (currentNodeIsVisible) {</span>
<span class="fc" id="L578">            outputTextToWriter(currentNode.getNodeValue());</span>

<span class="fc" id="L580">            for (Node nextSibling =</span>
                    currentNode
<span class="pc bpc" id="L582" title="2 of 6 branches missed.">                       .getNextSibling(); (nextSibling != null) &amp;&amp; ((nextSibling</span>
                          .getNodeType() == Node.TEXT_NODE) || (nextSibling
                             .getNodeType() == Node
<span class="pc" id="L585">                                .CDATA_SECTION_NODE)); nextSibling =</span>
                                   nextSibling.getNextSibling()) {

               /* The XPath data model allows to select only the first of a
                * sequence of mixed text and CDATA nodes. But we must output
                * them all, so we must search:
                *
                * @see http://nagoya.apache.org/bugzilla/show_bug.cgi?id=6329
                */
<span class="nc" id="L594">               outputTextToWriter(nextSibling.getNodeValue());</span>
            }
         }
         break;

      case Node.ELEMENT_NODE :
<span class="fc" id="L600">         Element currentElement = (Element) currentNode;</span>

<span class="fc bfc" id="L602" title="All 2 branches covered.">         if (currentNodeIsVisible) {</span>
<span class="fc" id="L603">            this._writer.write(&quot;&lt;&quot;);</span>
<span class="fc" id="L604">            this._writer.write(currentElement.getTagName());</span>
         }

         // we output all Attrs which are available
<span class="fc" id="L608">         List attrs = this.getAttrs(currentElement, parentIsVisible, ctx);</span>
<span class="fc" id="L609">         int attrsLength = attrs.size();</span>

<span class="fc bfc" id="L611" title="All 2 branches covered.">         for (int i = 0; i &lt; attrsLength; i++) {</span>
<span class="fc" id="L612">            Attr a = (Attr) attrs.get(i);</span>

<span class="fc" id="L614">            outputAttrToWriter(a.getNodeName(), a.getNodeValue());</span>
         }

<span class="fc bfc" id="L617" title="All 2 branches covered.">         if (currentNodeIsVisible) {</span>
<span class="fc" id="L618">            this._writer.write(&quot;&gt;&quot;);</span>
         }

         // traversal
<span class="fc" id="L622">         for (Node currentChild = currentNode.getFirstChild();</span>
<span class="fc bfc" id="L623" title="All 2 branches covered.">                 currentChild != null;</span>
<span class="fc" id="L624">                 currentChild = currentChild.getNextSibling()) {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (currentChild.getNodeType() == Node.ELEMENT_NODE) {</span>

               /*
                * We must 'clone' the inscopeXMLAttrs to allow the descendants
                * to mess around in their own map
                */
<span class="fc" id="L631">               canonicalizeXPathNodeSet(currentChild, currentNodeIsVisible,</span>
                                        ctx.copy());
            } else {
<span class="fc" id="L634">               canonicalizeXPathNodeSet(currentChild, currentNodeIsVisible,</span>
                                        ctx);
            }
         }

<span class="fc bfc" id="L639" title="All 2 branches covered.">         if (currentNodeIsVisible) {</span>
<span class="fc" id="L640">            this._writer.write(&quot;&lt;/&quot;);</span>
<span class="fc" id="L641">            this._writer.write(currentElement.getTagName());</span>
<span class="fc" id="L642">            this._writer.write(&quot;&gt;&quot;);</span>
         }
         break;
      }
<span class="fc" id="L646">   }</span>

   /**
    * Method getAttrs
    *
    * @param currentElement
    * @param parentIsVisible
    * @param ctx
    * @return
    * @throws CanonicalizationException
    */
   List getAttrs(Element currentElement, boolean parentIsVisible, C14nCtx ctx)
           throws CanonicalizationException {

<span class="fc" id="L660">      boolean currentElementIsInNodeset =</span>
         this._xpathNodeSet.contains(currentElement);
<span class="fc" id="L662">      Vector namespacesInSubset = new Vector();</span>
<span class="fc" id="L663">      Vector attributesInSubset = new Vector();</span>
<span class="fc" id="L664">      Vector xmlAttributesInSubset = new Vector();</span>
<span class="fc" id="L665">      NamedNodeMap attributes = currentElement.getAttributes();</span>
<span class="fc" id="L666">      int attributesLength = attributes.getLength();</span>

<span class="fc bfc" id="L668" title="All 2 branches covered.">      for (int i = 0; i &lt; attributesLength; i++) {</span>
<span class="fc" id="L669">         Attr currentAttr = (Attr) attributes.item(i);</span>
<span class="fc" id="L670">         String URI = currentAttr.getNamespaceURI();</span>

<span class="fc bfc" id="L672" title="All 2 branches covered.">         if (this._xpathNodeSet.contains(currentAttr)) {</span>
<span class="fc bfc" id="L673" title="All 2 branches covered.">            if (URI != null) {</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">               if (Constants.NamespaceSpecNS.equals(URI)) {</span>
<span class="fc" id="L675">                  String value = currentAttr.getValue();</span>

<span class="pc bpc" id="L677" title="1 of 2 branches missed.">                  if (C14nHelper.namespaceIsRelative(value)) {</span>
<span class="nc" id="L678">                     Object exArgs[] = { currentElement.getTagName(),</span>
                                         currentAttr.getNodeName(), value };

<span class="nc" id="L681">                     throw new CanonicalizationException(</span>
                        &quot;c14n.Canonicalizer.RelativeNamespace&quot;, exArgs);
                  }

<span class="fc" id="L685">                  namespacesInSubset.add(currentAttr);</span>
<span class="fc bfc" id="L686" title="All 2 branches covered.">               } else if (Constants.XML_LANG_SPACE_SpecNS.equals(URI)) {</span>
<span class="fc" id="L687">                  xmlAttributesInSubset.add(currentAttr);</span>
<span class="fc" id="L688">                  ctx.a.put(currentAttr.getNodeName(), currentAttr);</span>
               } else {
<span class="fc" id="L690">                  attributesInSubset.add(currentAttr);</span>
               }
            } else {
<span class="fc" id="L693">               attributesInSubset.add(currentAttr);</span>
            }
         } else {
<span class="fc bfc" id="L696" title="All 4 branches covered.">            if (URI != null &amp;&amp; Constants.XML_LANG_SPACE_SpecNS.equals(URI)) {</span>
<span class="fc" id="L697">               ctx.a.put(currentAttr.getNodeName(), currentAttr);</span>
            }
         }
      }

<span class="fc" id="L702">      Collections.sort(namespacesInSubset,</span>
                       new org.apache.xml.security.c14n.helper.NSAttrCompare());

      // update the ctx.a with the xml:* values
<span class="fc bfc" id="L706" title="All 2 branches covered.">      for (int i = 0; i &lt; xmlAttributesInSubset.size(); i++) {</span>
<span class="fc" id="L707">         Attr currentAttr = (Attr) xmlAttributesInSubset.get(i);</span>
<span class="fc" id="L708">         String name = currentAttr.getNodeName();</span>

<span class="fc" id="L710">         ctx.a.put(name, currentAttr);</span>
      }

<span class="fc bfc" id="L713" title="All 4 branches covered.">      if (currentElementIsInNodeset &amp;&amp;!parentIsVisible) {</span>
         // it's an orphan node, so we must include all xml:* attrs all the
         // ancestor axis along
<span class="fc" id="L716">         Iterator it = ctx.a.keySet().iterator();</span>

<span class="fc bfc" id="L718" title="All 2 branches covered.">         while (it.hasNext()) {</span>
<span class="fc" id="L719">            String name = (String) it.next();</span>

<span class="fc" id="L721">            attributesInSubset.add(ctx.a.get(name));</span>
<span class="fc" id="L722">         }</span>
      }
<span class="fc" id="L724">      Collections.sort(attributesInSubset,</span>
                       new org.apache.xml.security.c14n.helper
                          .NonNSAttrCompare());


<span class="fc" id="L729">      Vector nsResult = new Vector();</span>
<span class="fc" id="L730">      Map outputNamespaces = new HashMap();</span>

<span class="fc bfc" id="L732" title="All 2 branches covered.">      if (namespacesInSubset.size() &gt; 0) {</span>
<span class="fc" id="L733">         int firstNonDefaultNS = -1;</span>
<span class="fc" id="L734">         Attr firstNode = (Attr) namespacesInSubset.get(0);</span>

<span class="fc bfc" id="L736" title="All 2 branches covered.">         if (!firstNode.getNodeName().equals(&quot;xmlns&quot;)) {</span>

            // there is no default namespace in L
<span class="fc" id="L739">            firstNonDefaultNS = 0;</span>

            // if the output ancestor defines a default namespace
<span class="pc bpc" id="L742" title="3 of 6 branches missed.">            if (currentElementIsInNodeset &amp;&amp; ctx.n.containsKey(&quot;xmlns&quot;) &amp;&amp;!ctx.n.get(&quot;xmlns&quot;).equals(&quot;&quot;)) {</span>
<span class="nc" id="L743">               Attr xmlns = this._doc.createAttributeNS(Constants.NamespaceSpecNS, &quot;xmlns&quot;);</span>
<span class="nc" id="L744">               xmlns.setValue(&quot;&quot;);</span>
<span class="nc" id="L745">               nsResult.add(xmlns);</span>
<span class="nc" id="L746">            }</span>
<span class="pc bpc" id="L747" title="1 of 4 branches missed.">         } else if (firstNode.getNodeName().equals(&quot;xmlns&quot;)</span>
                    &amp;&amp; firstNode.getValue().equals(&quot;&quot;)) {

            // there is an empty default namespace in L
            // skip
<span class="fc" id="L752">            firstNonDefaultNS = 1;</span>

            // if the output ancestor defines a default namespace
<span class="pc bpc" id="L755" title="2 of 6 branches missed.">            if (currentElementIsInNodeset &amp;&amp; ctx.n.containsKey(&quot;xmlns&quot;) &amp;&amp;!ctx.n.get(&quot;xmlns&quot;).equals(&quot;&quot;)) {</span>
<span class="fc" id="L756">               nsResult.add(firstNode);</span>
            }
         } else {
<span class="fc" id="L759">            firstNonDefaultNS = 0;</span>
         }

         // handle non-empty namespaces
<span class="fc bfc" id="L763" title="All 2 branches covered.">         for (int i = firstNonDefaultNS; i &lt; namespacesInSubset.size(); i++) {</span>
<span class="fc" id="L764">            Attr currentAttr = (Attr) namespacesInSubset.get(i);</span>
<span class="fc" id="L765">            String name = currentAttr.getNodeName();</span>

<span class="fc" id="L767">            outputNamespaces.put(name, currentAttr);</span>

<span class="fc bfc" id="L769" title="All 4 branches covered.">            if (!ctx.n.containsKey(name) || !((Attr) ctx.n.get(name)).getValue().equals(currentAttr.getValue())) {</span>
<span class="fc" id="L770">               nsResult.add(currentAttr);</span>
            }
         }
      }

<span class="fc bfc" id="L775" title="All 2 branches covered.">      if (currentElementIsInNodeset) {</span>

         // if the element E is in the node set, remember the namespaces for the next one
<span class="fc" id="L778">         ctx.n = outputNamespaces;</span>
      }

      // and append them to the result
<span class="fc" id="L782">      nsResult.addAll(attributesInSubset);</span>

<span class="fc" id="L784">      return nsResult;</span>
   }

   /**
    * Normalizes an {@link Attr}ibute value
    *
    * The string value of the node is modified by replacing
    * &lt;UL&gt;
    * &lt;LI&gt;all ampersands (&amp;) with &lt;CODE&gt;&amp;amp;amp;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;all open angle brackets (&lt;) with &lt;CODE&gt;&amp;amp;lt;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;all quotation mark characters with &lt;CODE&gt;&amp;amp;quot;&lt;/CODE&gt;&lt;/LI&gt;
    * &lt;LI&gt;and the whitespace characters &lt;CODE&gt;#x9&lt;/CODE&gt;, #xA, and #xD, with character
    * references. The character references are written in uppercase
    * hexadecimal with no leading zeroes (for example, &lt;CODE&gt;#xD&lt;/CODE&gt; is represented
    * by the character reference &lt;CODE&gt;&amp;amp;#xD;&lt;/CODE&gt;)&lt;/LI&gt;
    * &lt;/UL&gt;
    *
    * @param name
    * @param value
    * @throws IOException
    */
   void outputAttrToWriter(String name, String value) throws IOException {

<span class="fc" id="L807">      this._writer.write(&quot; &quot;);</span>
<span class="fc" id="L808">      this._writer.write(name);</span>
<span class="fc" id="L809">      this._writer.write(&quot;=\&quot;&quot;);</span>

<span class="fc" id="L811">      int length = value.length();</span>

<span class="fc bfc" id="L813" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L814">         char c = value.charAt(i);</span>

<span class="fc bfc" id="L816" title="All 7 branches covered.">         switch (c) {</span>

         case '&amp;' :
<span class="fc" id="L819">            this._writer.write(&quot;&amp;amp;&quot;);</span>
<span class="fc" id="L820">            break;</span>

         case '&lt;' :
<span class="fc" id="L823">            this._writer.write(&quot;&amp;lt;&quot;);</span>
<span class="fc" id="L824">            break;</span>

         case '&quot;' :
<span class="fc" id="L827">            this._writer.write(&quot;&amp;quot;&quot;);</span>
<span class="fc" id="L828">            break;</span>

         case 0x09 :    // '\t'
<span class="fc" id="L831">            this._writer.write(&quot;&amp;#x9;&quot;);</span>
<span class="fc" id="L832">            break;</span>

         case 0x0A :    // '\n'
<span class="fc" id="L835">            this._writer.write(&quot;&amp;#xA;&quot;);</span>
<span class="fc" id="L836">            break;</span>

         case 0x0D :    // '\r'
<span class="fc" id="L839">            this._writer.write(&quot;&amp;#xD;&quot;);</span>
<span class="fc" id="L840">            break;</span>

         default :
<span class="fc" id="L843">            this._writer.write(c);</span>
            break;
         }
      }

<span class="fc" id="L848">      this._writer.write(&quot;\&quot;&quot;);</span>
<span class="fc" id="L849">   }</span>

   /**
    * Normalizes a {@link org.w3c.dom.Comment} value
    *
    * @param currentPI
    * @throws IOException
    */
   void outputPItoWriter(ProcessingInstruction currentPI) throws IOException {
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">      if (currentPI == null) {</span>
<span class="nc" id="L859">        return;</span>
      }

<span class="fc" id="L862">      this._writer.write(&quot;&lt;?&quot;);</span>

<span class="fc" id="L864">      String target = currentPI.getTarget();</span>
<span class="fc" id="L865">      int length = target.length();</span>

<span class="fc bfc" id="L867" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L868">         char c = target.charAt(i);</span>

<span class="pc bpc" id="L870" title="1 of 2 branches missed.">         switch (c) {</span>

         case 0x0D :
<span class="nc" id="L873">            this._writer.write(&quot;&amp;#xD;&quot;);</span>
<span class="nc" id="L874">            break;</span>

         default :
<span class="fc" id="L877">            this._writer.write(c);</span>
            break;
         }
      }

<span class="fc" id="L882">      String data = currentPI.getData();</span>

<span class="fc" id="L884">      length = data.length();</span>

<span class="pc bpc" id="L886" title="1 of 4 branches missed.">      if ((data != null) &amp;&amp; (length &gt; 0)) {</span>
<span class="fc" id="L887">         this._writer.write(&quot; &quot;);</span>

<span class="fc bfc" id="L889" title="All 2 branches covered.">         for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L890">            char c = data.charAt(i);</span>

<span class="pc bpc" id="L892" title="1 of 2 branches missed.">            switch (c) {</span>

            case 0x0D :
<span class="nc" id="L895">               this._writer.write(&quot;&amp;#xD;&quot;);</span>
<span class="nc" id="L896">               break;</span>

            default :
<span class="fc" id="L899">               this._writer.write(c);</span>
               break;
            }
         }
      }

<span class="fc" id="L905">      this._writer.write(&quot;?&gt;&quot;);</span>
<span class="fc" id="L906">   }</span>

   /**
    * Method outputCommentToWriter
    *
    * @param currentComment
    * @throws IOException
    */
   void outputCommentToWriter(Comment currentComment) throws IOException {
<span class="pc bpc" id="L915" title="1 of 2 branches missed.">      if (currentComment == null) {</span>
<span class="nc" id="L916">        return;</span>
      }

<span class="fc" id="L919">      this._writer.write(&quot;&lt;!--&quot;);</span>

<span class="fc" id="L921">      String data = currentComment.getData();</span>
<span class="fc" id="L922">      int length = data.length();</span>

<span class="fc bfc" id="L924" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L925">         char c = data.charAt(i);</span>

<span class="pc bpc" id="L927" title="1 of 2 branches missed.">         switch (c) {</span>

         case 0x0D :
<span class="nc" id="L930">            this._writer.write(&quot;&amp;#xD;&quot;);</span>
<span class="nc" id="L931">            break;</span>

         default :
<span class="fc" id="L934">            this._writer.write(c);</span>
            break;
         }
      }

<span class="fc" id="L939">      this._writer.write(&quot;--&gt;&quot;);</span>
<span class="fc" id="L940">   }</span>

   /**
    * Method outputTextToWriter
    *
    * @param text
    * @throws IOException
    */
   void outputTextToWriter(String text) throws IOException {
<span class="pc bpc" id="L949" title="1 of 2 branches missed.">      if (text == null) {</span>
<span class="nc" id="L950">        return;</span>
      }

<span class="fc" id="L953">      int length = text.length();</span>

<span class="fc bfc" id="L955" title="All 2 branches covered.">      for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L956">         char c = text.charAt(i);</span>

<span class="fc bfc" id="L958" title="All 5 branches covered.">         switch (c) {</span>

         case '&amp;' :
<span class="fc" id="L961">            this._writer.write(&quot;&amp;amp;&quot;);</span>
<span class="fc" id="L962">            break;</span>

         case '&lt;' :
<span class="fc" id="L965">            this._writer.write(&quot;&amp;lt;&quot;);</span>
<span class="fc" id="L966">            break;</span>

         case '&gt;' :
<span class="fc" id="L969">            this._writer.write(&quot;&amp;gt;&quot;);</span>
<span class="fc" id="L970">            break;</span>

         case 0xD :
<span class="fc" id="L973">            this._writer.write(&quot;&amp;#xD;&quot;);</span>
<span class="fc" id="L974">            break;</span>

         default :
<span class="fc" id="L977">            this._writer.write(c);</span>
            break;
         }
      }
<span class="fc" id="L981">   }</span>

   /**
    * Method engineCanonicalizeXPathNodeSet
    *
    * @param xpathNodeSet
    * @param inclusiveNamespaces
    * @return
    * @throws CanonicalizationException
    */
   public byte[] engineCanonicalizeXPathNodeSet(
           Set xpathNodeSet, String inclusiveNamespaces)
              throws CanonicalizationException {

      /** @todo well, should we throw UnsupportedOperationException ? */
<span class="nc" id="L996">      throw new CanonicalizationException(</span>
         &quot;c14n.Canonicalizer.UnsupportedOperation&quot;);
   }

   /**
    * Method engineCanonicalizeSubTree
    *
    * @param rootNode
    * @param inclusiveNamespaces
    * @return
    * @throws CanonicalizationException
    */
   public byte[] engineCanonicalizeSubTree(
           Node rootNode, String inclusiveNamespaces)
              throws CanonicalizationException {

      /** @todo well, should we throw UnsupportedOperationException ? */
<span class="nc" id="L1013">      throw new CanonicalizationException(</span>
         &quot;c14n.Canonicalizer.UnsupportedOperation&quot;);
   }

   /**
    * Class C14nCtx
    *
    * @author $Author: dohy $
    * @version $Revision: 1.1.1.1 $
    */
   class C14nCtx {

      /** Field a */
      Map a;

      /** Field n */
      Map n;

      /**
       * Constructor C14nCtx
       *
       */
<span class="fc" id="L1035">      public C14nCtx() {</span>
<span class="fc" id="L1036">         this.a = new HashMap();</span>
<span class="fc" id="L1037">         this.n = new HashMap();</span>
<span class="fc" id="L1038">      }</span>

      /**
       * Constructor C14nCtx
       *
       * @param a
       * @param n
       */
<span class="nc" id="L1046">      public C14nCtx(Map a, Map n) {</span>
<span class="nc" id="L1047">         this.a = a;</span>
<span class="nc" id="L1048">         this.n = n;</span>
<span class="nc" id="L1049">      }</span>

      /**
       * Method copy
       *
       * @return
       */
      public C14nCtx copy() {

<span class="fc" id="L1058">         C14nCtx c = new C14nCtx();</span>

<span class="fc" id="L1060">         c.a = new HashMap(this.a);</span>
<span class="fc" id="L1061">         c.n = new HashMap(this.n);</span>

<span class="fc" id="L1063">         return c;</span>
      }
   }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>