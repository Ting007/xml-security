<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Canonicalizer20010315WithoutXPathSupport.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JaCoCo Ant Example</a> &gt; <a href="index.source.html" class="el_package">org.apache.xml.security.c14n.implementations</a> &gt; <span class="el_source">Canonicalizer20010315WithoutXPathSupport.java</span></div><h1>Canonicalizer20010315WithoutXPathSupport.java</h1><pre class="source lang-java linenums">/*
 * The Apache Software License, Version 1.1
 *
 *
 * Copyright (c) 1999 The Apache Software Foundation.  All rights
 * reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. The end-user documentation included with the redistribution,
 *    if any, must include the following acknowledgment:
 *       &quot;This product includes software developed by the
 *        Apache Software Foundation (http://www.apache.org/).&quot;
 *    Alternately, this acknowledgment may appear in the software itself,
 *    if and wherever such third-party acknowledgments normally appear.
 *
 * 4. The names &quot;&lt;WebSig&gt;&quot; and &quot;Apache Software Foundation&quot; must
 *    not be used to endorse or promote products derived from this
 *    software without prior written permission. For written
 *    permission, please contact apache@apache.org.
 *
 * 5. Products derived from this software may not be called &quot;Apache&quot;,
 *    nor may &quot;Apache&quot; appear in their name, without prior written
 *    permission of the Apache Software Foundation.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation and was
 * originally based on software copyright (c) 2001, Institute for
 * Data Communications Systems, &lt;http://www.nue.et-inf.uni-siegen.de/&gt;.
 * The development of this software was partly funded by the European
 * Commission in the &lt;WebSig&gt; project in the ISIS Programme.
 * For more information on the Apache Software Foundation, please see
 * &lt;http://www.apache.org/&gt;.
 */
package org.apache.xml.security.c14n.implementations;



import java.io.*;
import java.util.Vector;
import org.w3c.dom.*;
import org.w3c.dom.traversal.*;
import org.xml.sax.*;
import javax.xml.parsers.*;
import org.apache.log4j.*;
import org.apache.log4j.xml.DOMConfigurator;
import org.apache.xml.security.utils.XMLUtils;
import org.apache.xml.security.c14n.CanonicalizationException;
import org.apache.xml.security.utils.Constants;
import org.apache.xml.security.utils.I18n;
import org.apache.xml.security.c14n.Canonicalizer;
import org.apache.xml.security.c14n.CanonicalizerSpi;
import org.apache.xml.security.c14n.helper.C14nNodeFilter;
import org.apache.xml.security.c14n.helper.C14nHelper;


/**
 * This class implements the &lt;A
 * HREF=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315&quot;&gt;Canonical XML
 * Version 1.0&lt;/A&gt; specification.
 *
 * @author Christian Geuer-Pollmann
 * @since  REC-xml-c14n-20010315
 */
public abstract class Canonicalizer20010315WithoutXPathSupport
        extends CanonicalizerSpi {

   /** {@link org.apache.log4j} logging facility */
<span class="fc" id="L93">   static org.apache.log4j.Category cat =</span>
      org.apache.log4j.Category
         .getInstance(Canonicalizer20010315WithoutXPathSupport.class.getName());

   /**
    * indicates the current state of the document traversal
    *
    * @see CanonicalizerSpi#BEFORE_DOCUMENT_ELEM
    * @see CanonicalizerSpi#INSIDE_DOCUMENT_ELEM
    * @see CanonicalizerSpi#AFTER_DOCUMENT_ELEM
    */
<span class="fc" id="L104">   private short processingPos = CanonicalizerSpi.BEFORE_DOCUMENT_ELEM;</span>

   /** Field _xpathChecked */
<span class="fc" id="L107">   private boolean _xpathChecked = false;</span>

   /**
    * This method always returns true because this implementation is not XPath
    * based and all Nodes are visible
    *
    * @todo If we only canonicalize a sub Tree, we eventually have to change this
    * @param node
    * @return
    */
   public boolean engineVisible(Node node) {
<span class="nc" id="L118">      throw new UnsupportedOperationException(I18n</span>
         .translate(&quot;c14n.Canonicalizer.UnsupportedOperation&quot;));
   }

   /**
    * This method is only needed for XPath based implememtations
    *
    * @todo shall we throw Exceptions ?
    * @param node
    */
   public void engineMakeVisible(Node node) {
<span class="nc" id="L129">      throw new UnsupportedOperationException(I18n</span>
         .translate(&quot;c14n.Canonicalizer.UnsupportedOperation&quot;));
   }

   /**
    * This method is only needed for XPath based implememtations
    *
    * @todo shall we throw Exceptions ?
    * @param node
    */
   public void engineMakeInVisible(Node node) {
<span class="nc" id="L140">      throw new UnsupportedOperationException(I18n</span>
         .translate(&quot;c14n.Canonicalizer.UnsupportedOperation&quot;));
   }

   /**
    * This method is only needed for XPath based implememtations
    *
    * @todo shall we throw Exceptions ?
    * @param nodeList
    */
   public void engineSetXPathNodeSet(NodeList nodeList) {
<span class="nc" id="L151">      throw new UnsupportedOperationException(I18n</span>
         .translate(&quot;c14n.Canonicalizer.UnsupportedOperation&quot;));
   }

   /**
    * Constructor Canonicalizer20010315
    *
    * @param includeComments
    */
<span class="fc" id="L160">   public Canonicalizer20010315WithoutXPathSupport(boolean includeComments) {</span>

<span class="fc" id="L162">      this.engineSetIncludeComments(includeComments);</span>

<span class="fc bfc" id="L164" title="All 2 branches covered.">      if (includeComments) {</span>
<span class="fc" id="L165">         this.engineSetURI(Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS);</span>
<span class="fc" id="L166">         this.engineSetXPath(Canonicalizer.XPATH_C14N_WITH_COMMENTS);</span>
      } else {
<span class="fc" id="L168">         this.engineSetURI(Canonicalizer.ALGO_ID_C14N_OMIT_COMMENTS);</span>
<span class="fc" id="L169">         this.engineSetXPath(Canonicalizer.XPATH_C14N_OMIT_COMMENTS);</span>
      }
<span class="fc" id="L171">   }</span>

   /**
    * Method engineCanonicalize
    *
    * @param selectedNodes
    * @return
    * @throws CanonicalizationException
    */
   public byte[] engineCanonicalize(NodeList selectedNodes)
           throws CanonicalizationException {
<span class="nc" id="L182">      throw new CanonicalizationException(</span>
         &quot;c14n.Canonicalizer.UnsupportedOperation&quot;);
   }

   /**
    * This method is the work horse of the canonicalizer which canonicalizes
    * a Node and returns a byte[] array.
    *
    * @param node
    * @return
    * @throws CanonicalizationException
    */
   public byte[] engineCanonicalize(Node node)
           throws CanonicalizationException {

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">      if (node == null) {</span>
<span class="nc" id="L198">         Object exArgs[] = { &quot;null&quot;, &quot;null&quot; };</span>

<span class="nc" id="L200">         throw new CanonicalizationException(&quot;c14n.Canonicalizer.IllegalNode&quot;,</span>
                                             exArgs);
      }

      /*
       * check whether the correct XPath is set. This version can only handle
       * the core types from the spec.
       */
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">      if (!_xpathChecked) {</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">         if (this.engineGetIncludeComments()) {</span>

            /**
             * @todo these xpath Strings are not compared to be semantically equal,
             *  only char-by-char. Can we compare compiled XPathes?
             */
<span class="pc bpc" id="L215" title="1 of 2 branches missed.">            if (!this.engineGetXPathString()</span>
                    .equals(Canonicalizer.XPATH_C14N_WITH_COMMENTS)) {
<span class="nc" id="L217">               cat.fatal(&quot;initialized with wrong xpath \&quot;&quot; + engineGetXPath()</span>
                         + &quot;\&quot;&quot;);

<span class="nc" id="L220">               throw new RuntimeException(&quot;initialized with wrong xpath &quot;</span>
                                          + engineGetXPath());
            }
         } else {
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">            if (!this.engineGetXPathString()</span>
                    .equals(Canonicalizer.XPATH_C14N_OMIT_COMMENTS)) {
<span class="nc" id="L226">               cat.fatal(&quot;initialized with wrong xpath \&quot;&quot; + engineGetXPath()</span>
                         + &quot;\&quot;&quot;);

<span class="nc" id="L229">               throw new RuntimeException(&quot;initialized with wrong xpath &quot;</span>
                                          + engineGetXPath());
            }
         }

<span class="fc" id="L234">         this._xpathChecked = true;</span>
      }

<span class="fc" id="L237">      NodeFilter nodefilter =</span>
         new C14nNodeFilter(this.engineGetIncludeComments());
      Document document;

<span class="pc bpc" id="L241" title="1 of 2 branches missed.">      if (node.getNodeType() == Node.DOCUMENT_NODE) {</span>
<span class="fc" id="L242">         document = (Document) node;</span>
      } else {
<span class="nc" id="L244">         document = node.getOwnerDocument();</span>
      }

<span class="fc" id="L247">      boolean entityReferenceExpansion = true;</span>
<span class="fc" id="L248">      TreeWalker treewalker =</span>
         ((DocumentTraversal) document).createTreeWalker(node,
            NodeFilter.SHOW_ALL, nodefilter, entityReferenceExpansion);
      ByteArrayOutputStream bytearrayoutputstream;
      PrintWriter printwriter;

      try {
<span class="fc" id="L255">         bytearrayoutputstream = new ByteArrayOutputStream();</span>
<span class="fc" id="L256">         printwriter =</span>
            new PrintWriter(new OutputStreamWriter(bytearrayoutputstream,
                                                   Canonicalizer.ENCODING));
<span class="nc" id="L259">      } catch (UnsupportedEncodingException ex) {</span>
<span class="nc" id="L260">         Object exArgs[] = { Canonicalizer.ENCODING };</span>

<span class="nc" id="L262">         throw new CanonicalizationException(</span>
            &quot;c14n.Canonicalizer.UnsupportedEncoding&quot;, exArgs, ex);

         // return new byte[0];
<span class="fc" id="L266">      }</span>

<span class="fc" id="L268">      process(treewalker, printwriter);</span>
<span class="fc" id="L269">      printwriter.flush();</span>

<span class="fc" id="L271">      return bytearrayoutputstream.toByteArray();</span>
   }

   /**
    * Method process
    *
    * @param treewalker
    * @param printwriter
    * @throws CanonicalizationException
    */
   private void process(TreeWalker treewalker, PrintWriter printwriter)
           throws CanonicalizationException {

<span class="fc" id="L284">      Node currentNode = treewalker.getCurrentNode();</span>

<span class="pc bpc" id="L286" title="3 of 9 branches missed.">      switch (currentNode.getNodeType()) {</span>

      case Node.ENTITY_REFERENCE_NODE :
<span class="nc bnc" id="L289" title="All 2 branches missed.">         for (Node node1 = treewalker.firstChild(); node1 != null;</span>
<span class="nc" id="L290">                 node1 = treewalker.nextSibling()) {</span>
<span class="nc" id="L291">            process(treewalker, printwriter);</span>
         }

<span class="nc" id="L294">         treewalker.setCurrentNode(currentNode);</span>
<span class="nc" id="L295">         break;</span>

      case Node.ENTITY_NODE :
<span class="nc" id="L298">         cat.warn(&quot;Node.ENTITY_NODE called&quot;);</span>
<span class="nc" id="L299">         break;</span>

      case Node.ATTRIBUTE_NODE :
<span class="nc" id="L302">         Object[] exArgs = {</span>
            XMLUtils.getNodeTypeString(currentNode.getNodeType()),
            currentNode.getNodeName() };

<span class="nc" id="L306">         throw new CanonicalizationException(</span>
            &quot;c14n.Canonicalizer20010315.IllegalNode&quot;, exArgs);
      case Node.TEXT_NODE :
      case Node.CDATA_SECTION_NODE :
<span class="fc" id="L310">         printwriter</span>
            .print(C14nHelper.normalizeText(currentNode.getNodeValue()));
<span class="fc" id="L312">         break;</span>

      case Node.COMMENT_NODE :

         /*
          * Comment Nodes- Nothing if generating canonical XML without comments.
          * For canonical XML with comments, generate the opening comment
          * symbol (&lt;!--), the string value of the node, and the closing
          * comment symbol (--&gt;). Also, a trailing #xA is rendered after the
          * closing comment symbol for comment children of the root node with
          * a lesser document order than the document element, and a leading
          * #xA is rendered before the opening comment symbol of comment
          * children of the root node with a greater document order than the
          * document element. (Comment children of the root node represent
          * comments outside of the top-level document element and outside
          * of the document type declaration).
          *
          */
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">         if (this.engineGetIncludeComments()) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            if (processingPos == CanonicalizerSpi.AFTER_DOCUMENT_ELEM) {</span>
<span class="fc" id="L332">               printwriter.print(&quot;\n&quot;);</span>
            }

<span class="fc" id="L335">            printwriter.print(&quot;&lt;!--&quot;);</span>

            /** @todo Do we need really have to normalize Comments */
<span class="fc" id="L338">            printwriter</span>
               .print(C14nHelper.normalizeComment(currentNode.getNodeValue()));
<span class="fc" id="L340">            printwriter.print(&quot;--&gt;&quot;);</span>

<span class="pc bpc" id="L342" title="1 of 2 branches missed.">            if (processingPos == CanonicalizerSpi.BEFORE_DOCUMENT_ELEM) {</span>
<span class="nc" id="L343">               printwriter.print(&quot;\n&quot;);</span>
            }
         }
         break;

      case Node.PROCESSING_INSTRUCTION_NODE :

         /*
          * Processing Instruction (PI) Nodes- The opening PI symbol (&lt;?),
          * the PI target name of the node, a leading space and the string
          * value if it is not empty, and the closing PI symbol (?&gt;). If the
          * string value is empty, then the leading space is not added.
          * Also, a trailing #xA is rendered after the closing PI symbol for PI
          * children of the root node with a lesser document order than the
          * document element, and a leading #xA is rendered before the opening
          * PI symbol of PI children of the root node with a greater document
          * order than the document element.
          *
          */
<span class="fc bfc" id="L362" title="All 2 branches covered.">         if (processingPos == CanonicalizerSpi.AFTER_DOCUMENT_ELEM) {</span>
<span class="fc" id="L363">            printwriter.print(&quot;\n&quot;);</span>
         }

<span class="fc" id="L366">         printwriter.print(&quot;&lt;?&quot;);</span>
<span class="fc" id="L367">         printwriter.print(currentNode.getNodeName());</span>

<span class="fc" id="L369">         String s = currentNode.getNodeValue();</span>

<span class="pc bpc" id="L371" title="1 of 4 branches missed.">         if ((s != null) &amp;&amp; (s.length() &gt; 0)) {</span>
<span class="fc" id="L372">            printwriter.print(&quot; &quot;);</span>

            /** @todo Do we need really have to normalize PIs */
<span class="fc" id="L375">            printwriter.print(C14nHelper.normalizeProcessingInstruction(s));</span>
         }

<span class="fc" id="L378">         printwriter.print(&quot;?&gt;&quot;);</span>

<span class="fc bfc" id="L380" title="All 2 branches covered.">         if (processingPos == CanonicalizerSpi.BEFORE_DOCUMENT_ELEM) {</span>
<span class="fc" id="L381">            printwriter.print(&quot;\n&quot;);</span>
         }
         break;

      case Node.ELEMENT_NODE :
         // if (currentNode == currentNode.getOwnerDocument().getDocumentElement()) {
<span class="fc" id="L387">         processingPos = CanonicalizerSpi.INSIDE_DOCUMENT_ELEM;</span>
         // }
<span class="fc" id="L389">         Canonicalizer20010315.checkForRelativeNamespace(currentNode);</span>

<span class="fc" id="L391">         printwriter.print('&lt;');</span>
<span class="fc" id="L392">         printwriter.print(currentNode.getNodeName());</span>
<span class="fc" id="L393">         removeExtraNamespaces(currentNode);</span>

<span class="fc" id="L395">         NamedNodeMap namednodemap = currentNode.getAttributes();</span>
<span class="fc" id="L396">         Attr aattr[] = C14nHelper.sortAttributes(namednodemap);</span>

<span class="fc bfc" id="L398" title="All 2 branches covered.">         for (int i = 0; i &lt; aattr.length; i++) {</span>
<span class="fc" id="L399">            Attr attr = aattr[i];</span>

<span class="fc" id="L401">            printwriter.print(' ');</span>
<span class="fc" id="L402">            printwriter.print(attr.getNodeName());</span>
<span class="fc" id="L403">            printwriter.print(&quot;=\&quot;&quot;);</span>
<span class="fc" id="L404">            printwriter.print(C14nHelper.normalizeAttr(attr.getNodeValue()));</span>
<span class="fc" id="L405">            printwriter.print('&quot;');</span>
         }

<span class="fc" id="L408">         printwriter.print(&quot;&gt;&quot;);</span>

<span class="fc bfc" id="L410" title="All 2 branches covered.">         for (Node node1 = treewalker.firstChild(); node1 != null;</span>
<span class="fc" id="L411">                 node1 = treewalker.nextSibling()) {</span>
<span class="fc" id="L412">            process(treewalker, printwriter);</span>
         }

<span class="fc" id="L415">         treewalker.setCurrentNode(currentNode);</span>
<span class="fc" id="L416">         printwriter.print(&quot;&lt;/&quot;);</span>
<span class="fc" id="L417">         printwriter.print(currentNode.getNodeName());</span>
<span class="fc" id="L418">         printwriter.print('&gt;');</span>

<span class="fc bfc" id="L420" title="All 2 branches covered.">         if (currentNode</span>
                 == currentNode.getOwnerDocument().getDocumentElement()) {
<span class="fc" id="L422">            processingPos = CanonicalizerSpi.AFTER_DOCUMENT_ELEM;</span>
         }
         break;

      case Node.DOCUMENT_NODE :

         /**
          * Root Node- The root node is the parent of the top-level document
          * element. The result of processing each of its child nodes that
          * is in the node-set in document order. The root node does not
          * generate a byte order mark, XML declaration, nor anything from
          * within the document type declaration.
          *
          */
<span class="fc bfc" id="L436" title="All 2 branches covered.">         for (Node node1 = treewalker.firstChild(); node1 != null;</span>
<span class="fc" id="L437">                 node1 = treewalker.nextSibling()) {</span>
<span class="fc" id="L438">            process(treewalker, printwriter);</span>
         }

<span class="fc" id="L441">         treewalker.setCurrentNode(currentNode);</span>
<span class="fc" id="L442">         break;</span>

      default :
<span class="pc bpc" id="L445" title="1 of 2 branches missed.">         for (Node node1 = treewalker.firstChild(); node1 != null;</span>
<span class="nc" id="L446">                 node1 = treewalker.nextSibling()) {</span>
<span class="nc" id="L447">            process(treewalker, printwriter);</span>
         }

<span class="fc" id="L450">         treewalker.setCurrentNode(currentNode);</span>
         break;
      }
<span class="fc" id="L453">   }</span>

   /**
    * Namespace Nodes: A namespace node N is ignored if the nearest
    * ancestor element of the node's parent element that is in the
    * node-set has a namespace node in the node-set with the same local
    * name and value as N. Otherwise, process the namespace node N in
    * the same way as an attribute node, except assign the local name
    * xmlns to the default namespace node if it exists (in XPath, the
    * default namespace node has an empty URI and local name).
    *
    * @param node element to be cleaned up
    */
   private void removeExtraNamespaces(Node node) {

<span class="pc bpc" id="L468" title="1 of 2 branches missed.">      if (node.getNodeType() != Node.ELEMENT_NODE) {</span>
<span class="nc" id="L469">         cat.fatal(&quot;removeExtraNamespaces with &quot;</span>
                   + XMLUtils.getNodeTypeString(node.getNodeType())
                   + &quot; called. Has to get an ELEMENT&quot;);
      }

<span class="fc" id="L474">      Vector ancestorVector = XMLUtils.getAncestorElements(node);</span>
<span class="fc" id="L475">      Vector redundantAttrsVector = new Vector();</span>
<span class="fc" id="L476">      NamedNodeMap nodeAttributes = node.getAttributes();</span>

      // loop through all Attributes
<span class="fc bfc" id="L479" title="All 2 branches covered.">      nextNodeAttribute: for (int i = 0; i &lt; nodeAttributes.getLength(); i++) {</span>
<span class="fc" id="L480">         Attr nodeAttr = (Attr) nodeAttributes.item(i);</span>
<span class="fc" id="L481">         String nodeAttrName = nodeAttr.getNodeName();</span>
<span class="fc" id="L482">         String nodeAttrValue = nodeAttr.getValue();</span>

         // handle only namespace declarations
<span class="fc" id="L485">         boolean definesDefaultNS = nodeAttrName.equals(&quot;xmlns&quot;);</span>
<span class="fc" id="L486">         boolean definesArbitraryNS = nodeAttrName.startsWith(&quot;xmlns:&quot;);</span>

<span class="fc bfc" id="L488" title="All 2 branches covered.">         if (definesDefaultNS) {</span>
<span class="fc" id="L489">            boolean found = false;</span>

            /**
             * loop through all ancestors (parent elements) and
             * check for redundancy in ancestors
             */
<span class="fc bfc" id="L495" title="All 2 branches covered.">            nextAncestor: for (int j = 0; j &lt; ancestorVector.size(); j++) {</span>
<span class="fc" id="L496">               Node ancestorNode = (Node) ancestorVector.get(j);</span>
<span class="fc" id="L497">               NamedNodeMap ancestorAttributes = ancestorNode.getAttributes();</span>

               /**
                * if this element has no attributes (and no namespace defs),
                * we don't have to check it
                */
<span class="pc bpc" id="L503" title="1 of 2 branches missed.">               if (ancestorAttributes == null) {</span>
<span class="nc" id="L504">                  continue nextAncestor;</span>
               }

               // loop through the attributes of the current ancestor
<span class="fc" id="L508">               nextAncestorAttribute: for (int k = 0;</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">                                           k &lt; ancestorAttributes.getLength();</span>
<span class="fc" id="L510">                                           k++) {</span>
<span class="fc" id="L511">                  Attr ancestorAttr = (Attr) ancestorAttributes.item(k);</span>

                  // processNextAncestorAttribute if ancestorAttr does not define the defaultNS
<span class="fc bfc" id="L514" title="All 2 branches covered.">                  if (!ancestorAttr.getNodeName().equals(&quot;xmlns&quot;)) {</span>
<span class="fc" id="L515">                     continue nextAncestorAttribute;</span>
                  }

<span class="fc" id="L518">                  String ancestorAttrValue = ancestorAttr.getValue();</span>

                  // same namespace URI? then add to redundant attrs
<span class="fc bfc" id="L521" title="All 2 branches covered.">                  if (nodeAttrValue.equals(ancestorAttrValue)) {</span>

                     // cat.debug(&quot;&lt;&quot; + ((Element)node).getNodeName() + &quot; &quot; + nodeAttrName + &quot;=\&quot;&quot; + nodeAttrValue + &quot;\&quot;&gt; will be deleted in default NS handler&quot;);
<span class="fc" id="L524">                     redundantAttrsVector.add(nodeAttr);</span>

<span class="fc" id="L526">                     found = true;</span>
                  }

                  // handle next node attribute
                  continue nextNodeAttribute;
               }    // processNextAncestorAttribute
            }    // nextAncestor

            /*
             * Did we run up to the document element but did not find an
             * empty default namespace definition ?
             */
<span class="pc bpc" id="L538" title="1 of 4 branches missed.">            if (nodeAttrValue.equals(&quot;&quot;) &amp;&amp;!found) {</span>

               // cat.debug(&quot;&lt;&quot; + ((Element)node).getNodeName() + &quot; &quot; + nodeAttrName + &quot;=\&quot;&quot; + nodeAttrValue + &quot;\&quot;&gt; will be deleted in notFound section&quot;);
<span class="fc" id="L541">               redundantAttrsVector.add(nodeAttr);</span>
            }
<span class="fc bfc" id="L543" title="All 2 branches covered.">         } else if (definesArbitraryNS) {</span>

            /**
             * loop through all ancestors (parent elements) and
             * check for redundancy in ancestors
             */
<span class="fc bfc" id="L549" title="All 2 branches covered.">            nextAncestor: for (int j = 0; j &lt; ancestorVector.size(); j++) {</span>
<span class="fc" id="L550">               Node ancestorNode = (Node) ancestorVector.get(j);</span>
<span class="fc" id="L551">               NamedNodeMap ancestorAttributes = ancestorNode.getAttributes();</span>

               /**
                * if this element has no attributes (and no namespace defs),
                * we don't have to check it
                */
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">               if (ancestorAttributes == null) {</span>
<span class="nc" id="L558">                  continue nextAncestor;</span>
               }

               // loop through the attributes of the current ancestor
<span class="fc" id="L562">               nextAncestorAttribute: for (int k = 0;</span>
<span class="fc bfc" id="L563" title="All 2 branches covered.">                                           k &lt; ancestorAttributes.getLength();</span>
<span class="fc" id="L564">                                           k++) {</span>
<span class="fc" id="L565">                  Attr ancestorAttr = (Attr) ancestorAttributes.item(k);</span>

                  // wrong attribute name? then check the next ancestor attr
<span class="fc bfc" id="L568" title="All 2 branches covered.">                  if (!nodeAttrName.equals(ancestorAttr.getNodeName())) {</span>
<span class="fc" id="L569">                     continue nextAncestorAttribute;</span>
                  }

<span class="fc" id="L572">                  String ancestorAttrValue = ancestorAttr.getValue();</span>

                  /**
                   * same attribute value? then add to redundant
                   * attrs and stop searching ancestors
                   */
<span class="fc bfc" id="L578" title="All 2 branches covered.">                  if (nodeAttrValue.equals(ancestorAttrValue)) {</span>
<span class="fc" id="L579">                     redundantAttrsVector.add(nodeAttr);</span>
                  }

                  break nextAncestor;
               }    // processNextAncestorAttribute
            }    // nextAncestor
         }    // isNamespace
      }    // nodeAttribute

      /**
       * after collecting deletable namespace definitions, erase them
       */
<span class="fc bfc" id="L591" title="All 2 branches covered.">      for (int i = 0; i &lt; redundantAttrsVector.size(); i++) {</span>
<span class="fc" id="L592">         Attr attrToDelete = (Attr) redundantAttrsVector.get(i);</span>

<span class="fc" id="L594">         nodeAttributes.removeNamedItem(attrToDelete.getNodeName());</span>
      }
<span class="fc" id="L596">   }</span>

   /**
    * Method engineSetRemoveNSAttrs
    *
    * @param remove
    */
   public void engineSetRemoveNSAttrs(boolean remove) {
<span class="nc" id="L604">      throw new UnsupportedOperationException(I18n</span>
         .translate(&quot;c14n.Canonicalizer.UnsupportedOperation&quot;));
   }

   /**
    * Method engineGetRemoveNSAttrs
    *
    * @return
    */
   public boolean engineGetRemoveNSAttrs() {
<span class="nc" id="L614">      return false;</span>
   }

   static {
<span class="fc" id="L618">      org.apache.xml.security.Init.init();</span>
<span class="fc" id="L619">   }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>